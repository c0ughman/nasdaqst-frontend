<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NASDAQ Sentiment Dashboard</title>

    <!-- Translation System -->
    <script src="translations.js"></script>

    <!-- Clerk SDK -->
    <script
        async
        crossorigin="anonymous"
        data-clerk-publishable-key="pk_test_Zmxvd2luZy1naWJib24tNjUuY2xlcmsuYWNjb3VudHMuZGV2JA"
        src="https://flowing-gibbon-65.clerk.accounts.dev/npm/@clerk/clerk-js@5/dist/clerk.browser.js"
        type="text/javascript"
    ></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: black;
            min-height: 100vh;
            margin: 0;
            color: white;
            padding: 10px 0px;
        }

        .main-wrapper {
            width: 100%;
            max-width: 100%;
        }

        .container {
            width: 95%;
            display: grid;
            grid-template-columns: 1fr 3fr;
            grid-template-rows: minmax(0, 0.6fr) auto auto auto;
            row-gap: 18px;
            column-gap: 15px;
            margin: 0 auto;
        }

        .card {
            background: #282828;
            border-radius: 16px;
            padding: 22px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
        }

        .card.right-top {
            padding: 8px 32px;
        }

        .left-top {
            grid-column: 1;
            grid-row: 1 / 3;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding-top: 48px;
            padding-bottom: 48px;
            padding-left: 28px;
            padding-right: 28px;
            margin-top: 0px;
            margin-bottom: 20px;
            overflow: hidden;
            box-sizing: border-box;
        }

        .left-bottom {
            grid-column: 1;
            grid-row: 3 / 5;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .right-top {
            grid-column: 2;
            grid-row: 1;
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            align-items: center;
            margin-bottom: -12px;
            margin-top: -5px;
        }

        .right-top-item {
            background: #282828;
            border-radius: 12px;
            padding: 8px 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 70%;
            min-height: 44px;
        }

        .right-middle {
            grid-column: 2;
            grid-row: 2 / 5;
            display: flex;
            flex-direction: column;
            padding: 5px 18px;
            margin-top: -10px;
        }

        .right-middle .chart-header {
            margin-bottom: 8px;
        }

        .right-middle .chart-container {
            flex: 1;
        }

        .bottom-row {
            grid-column: 1 / -1;
            grid-row: 5;
            padding: 12px 19px 10px 19px;
            margin-top: -10px;
        }

        /* Logout link styles */
        .logout-link-container {
            grid-column: 1 / -1;
            display: flex;
            justify-content: flex-end;
            margin-top: -10px;
            margin-bottom: 20px;
            padding-top: 0;
        }

        .logout-link {
            color: #888;
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            transition: color 0.2s ease;
            cursor: pointer;
            margin-right: 30px;
        }

        .logout-link:hover {
            color: #fff;
        }

        /* Sentiment Score Styles */
        .score-label {
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 1.5px;
            color: #fff;
            margin-bottom: 10px;
            text-transform: capitalize;
        }

        .score-value {
            font-size: 64px;
            font-weight: 700;
            background: linear-gradient(135deg, #10b981 0%, #34d399 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1;
            margin-bottom: 6px;
            filter: drop-shadow(0 0 20px rgba(16, 185, 129, 0.3));
        }

        .score-status {
            font-size: 16px;
            font-weight: 600;
            color: #10b981;
            letter-spacing: 2px;
            text-shadow: 0 0 15px rgba(16, 185, 129, 0.4);
        }

        /* Time Zone Styles */
        .timezone-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 24px;
            width: 100%;
            align-items: center;
        }

        .nav-links {
            display: flex;
            gap: 24px;
            align-items: center;
        }

        .nav-link {
            color: #fff;
            font-size: 13px;
            font-weight: 500;
            text-decoration: none;
            cursor: pointer;
            transition: color 0.2s ease;
            white-space: nowrap;
        }

        .nav-link:hover {
            color: #ccc;
        }

        .time-zone-group {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .time-display {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .time-display:hover {
            opacity: 1;
        }

        .current-time {
            font-size: 15px;
            font-weight: 600;
            letter-spacing: -0.5px;
            color: #fff;
        }

        .timezone-chevron {
            font-size: 13px;
            color: #888;
            transition: transform 0.2s ease;
        }

        .time-display:hover .timezone-chevron {
            color: #ccc;
        }

        .timezone-dropdown {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 12px;
            padding: 8px;
            min-width: 420px;
            max-width: 500px;
            max-height: 400px;
            overflow-y: auto;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.8);
            opacity: 1;
        }

        .timezone-dropdown.show {
            display: block;
        }

        .timezone-option {
            padding: 10px 14px;
            color: #ccc;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 4px;
            opacity: 1;
            background: transparent;
        }

        .timezone-option:hover {
            background: #2a2a2a;
            color: white;
        }

        .timezone-option.active {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
            opacity: 1;
        }

        .timezone-option-main {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
        }

        .timezone-option-offset {
            display: inline-block;
            min-width: 60px;
            color: #10b981;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }

        .timezone-option-code {
            display: inline-block;
            padding: 2px 6px;
            background: #0f0f0f;
            border-radius: 6px;
            font-size: 10px;
            font-weight: 600;
            color: #888;
            font-family: 'Courier New', monospace;
            opacity: 1;
        }

        .timezone-option-datetime {
            font-size: 11px;
            color: #666;
            margin-left: 60px;
            font-family: 'Courier New', monospace;
        }

        .timezone-dropdown::-webkit-scrollbar {
            width: 8px;
        }

        .timezone-dropdown::-webkit-scrollbar-track {
            background: #0f0f0f;
            border-radius: 6px;
        }

        .timezone-dropdown::-webkit-scrollbar-thumb {
            background: #2a2a2a;
            border-radius: 6px;
        }

        .timezone-dropdown::-webkit-scrollbar-thumb:hover {
            background: #333;
        }

        .market-status {
            display: inline-block;
            padding: 6px 14px;
            background: rgba(16, 185, 129, 0.1);
            color: #10b981;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.5px;
            border: 1px solid rgba(16, 185, 129, 0.2);
        }

        .timezone-pills {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .timezone-pill {
            padding: 6px 14px;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 500;
            color: #888;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .timezone-pill:hover {
            background: #1f1f1f;
            border-color: #333;
            color: #ccc;
        }

        .timezone-pill.active {
            background: rgba(16, 185, 129, 0.1);
            border-color: rgba(16, 185, 129, 0.3);
            color: #10b981;
        }

        /* Quick Stats Styles */
        .stats-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 24px;
            color: #fff;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 0;
            border-bottom: 1px solid #1a1a1a;
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-size: 14px;
            color: #888;
            font-weight: 500;
        }

        .stat-value {
            font-size: 18px;
            font-weight: 600;
        }

        .stat-value.positive {
            color: #10b981;
            text-shadow: 0 0 10px rgba(16, 185, 129, 0.3);
        }

        .stat-value.negative {
            color: #ef4444;
            text-shadow: 0 0 10px rgba(239, 68, 68, 0.3);
        }

        .stat-value.neutral {
            color: #888;
        }

        /* Alert Badge */
        .alert-badge {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 8px;
            border: 1px solid rgba(239, 68, 68, 0.2);
        }

        /* Sentiment Drivers */
        .drivers-section {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .section-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
            color: #e0e0e0;
        }

        .drivers-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            flex: 1;
        }

        .drivers-grid-single {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 12px;
        }

        .driver-item {
            background: transparent;
            padding: 14px 18px;
            border-radius: 12px;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .driver-item:hover {
            background: transparent;
            transform: none;
        }

        .driver-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .driver-name {
            font-size: 14px;
            font-weight: 500;
            color: #ccc;
        }

        .driver-value {
            font-size: 16px;
            font-weight: 700;
        }

        .driver-value.positive {
            color: #10b981;
        }

        .driver-value.negative {
            color: #ef4444;
        }

        .progress-bar {
            height: 6px;
            background: #0f0f0f;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            border-radius: 6px;
            transition: width 1s ease;
        }

        .progress-fill.positive {
            background: linear-gradient(90deg, #10b981 0%, #34d399 100%);
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.5);
        }

        .progress-fill.negative {
            background: linear-gradient(90deg, #ef4444 0%, #f87171 100%);
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
        }

        /* Chart Section */
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .chart-title {
            font-size: 16px;
            font-weight: 600;
            color: #e0e0e0;
        }

        /* Nasdaq price toggle as checkbox */
        .price-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            color: #fff;
            font-size: 12px;
            user-select: none;
        }

        .price-toggle input[type="checkbox"] {
            width: 14px;
            height: 14px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            border: 1px solid #666;
            border-radius: 3px;
            background-color: #999;
            position: relative;
        }

        .price-toggle input[type="checkbox"]:checked {
            background-color: #ffffff;
            border-color: #ffffff;
        }

        .price-toggle input[type="checkbox"]:checked::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #000;
            font-size: 10px;
            font-weight: bold;
        }

        .chart-controls {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .timeframe-selector {
            display: flex;
            gap: 8px;
        }

        .timeframe-btn {
            padding: 6px 14px;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 10px;
            color: #888;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        .timeframe-btn:hover {
            background: #1f1f1f;
            border-color: #333;
            color: #ccc;
        }

        .timeframe-btn.active {
            background: rgba(255, 140, 66, 0.1);
            color: #ff8c42;
            border-color: rgba(255, 140, 66, 0.3);
        }

        .timezone-select {
            background: #1a1a1a;
            color: #ccc;
            border: 1px solid #2a2a2a;
            padding: 6px 32px 6px 12px;
            border-radius: 10px;
            font-size: 12px;
            font-family: inherit;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1.5L6 6.5L11 1.5' stroke='%23888888' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
        }

        .timezone-select:hover {
            background-color: #1f1f1f;
            border-color: #333;
        }

        .timezone-select:focus {
            outline: none;
            border-color: #ff8c42;
        }

        .chart-container {
            flex: 1;
            position: relative;
            background: #0f0f0f;
            border-radius: 12px;
            padding: 12px;
            min-height: 70px;
            max-height: 400px;
        }

        .market-status-indicator {
            position: absolute;
            bottom: 16px;
            left: 16px;
            font-size: 10px;
            color: #888;
            background: rgba(0, 0, 0, 0.5);
            padding: 4px 8px;
            border-radius: 4px;
            z-index: 100;
        }

        .market-status-indicator span {
            color: #aaa;
            font-weight: 500;
        }

        .chart-canvas {
            position: absolute;
            left: 50px;
            right: 20px;
            top: 0;
            bottom: 45px;
            cursor: crosshair;
        }

        .chart-hover-line {
            position: absolute;
            top: 0;
            bottom: 45px;
            width: 1px;
            background: transparent;
            border-left: 2px dashed rgba(255, 140, 66, 0.5);
            pointer-events: none;
            display: none;
        }

        .chart-time-label {
            position: absolute;
            bottom: 43px;
            left: 0;
            background: #ff8c42;
            color: #000;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            font-family: monospace;
            white-space: nowrap;
            pointer-events: none;
            z-index: 9999;
            display: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .chart-time-label.show {
            display: block;
        }

        .chart-tooltip {
            position: absolute;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 10px;
            padding: 8px 12px;
            color: white;
            font-size: 12px;
            font-weight: 500;
            pointer-events: none;
            display: none;
            white-space: nowrap;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .chart-tooltip .tooltip-label {
            color: #888;
            font-size: 10px;
            margin-bottom: 4px;
        }

        .chart-tooltip .tooltip-value {
            color: #ff8c42;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .chart-tooltip .tooltip-time {
            color: #666;
            font-size: 10px;
        }

        .y-axis {
            position: absolute;
            left: 0;
            top: 20px;
            bottom: 20px;
            width: 40px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            font-size: 11px;
            color: #fff;
            padding-right: 10px;
        }

        .y-axis-label {
            text-align: right;
        }

        .chart-line {
            position: absolute;
            left: 50px;
            right: 20px;
            top: 0;
            bottom: 20px;
            pointer-events: none;
        }

        .chart-line svg {
            width: 100%;
            height: 100%;
        }

        .chart-path {
            fill: none;
            stroke: url(#lineGradient);
            stroke-width: 3;
            stroke-linecap: round;
            stroke-linejoin: round;
            filter: drop-shadow(0 0 15px rgba(255, 140, 66, 0.6));
            opacity: 1;
        }

        .zero-line {
            position: absolute;
            left: 50px;
            right: 20px;
            top: 50%;
            height: 1px;
            background: rgba(136, 136, 136, 0.3);
            border-top: 1px dashed rgba(136, 136, 136, 0.3);
            pointer-events: none;
        }

        .market-gap-line {
            position: absolute;
            top: 0;
            bottom: 20px;
            width: 2px;
            background: none;
            border-left: 2px dashed rgba(255, 193, 7, 0.4);
            pointer-events: none;
            z-index: 5;
        }

        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 140, 66, 0.6);
            }
            50% {
                box-shadow: 0 0 30px rgba(255, 140, 66, 0.8);
            }
        }

        .x-axis {
            position: absolute;
            left: 50px;
            right: 20px;
            bottom: 25px;
            height: 20px;
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #fff;
        }

        .chart-legend {
            position: absolute;
            left: 50px;
            right: 20px;
            bottom: 0;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            font-size: 11px;
            color: #fff;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-color {
            width: 12px;
            height: 2px;
            border-radius: 1px;
        }

        .legend-color.orange {
            background-color: #ff8c42;
        }

        .legend-color.white {
            background-color: #ffffff;
        }

        /* News Feed */
        .news-feed {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .news-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .news-title {
            font-size: 18px;
            font-weight: 600;
            color: #e0e0e0;
        }

        .news-filter {
            display: flex;
            gap: 8px;
        }

        .filter-btn {
            padding: 6px 14px;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 10px;
            color: #888;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .filter-btn:hover {
            background: #1f1f1f;
            color: #ccc;
        }

        .filter-btn.active {
            background: rgba(16, 185, 129, 0.1);
            color: #10b981;
            border-color: rgba(16, 185, 129, 0.2);
        }

        .news-items {
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
            flex: 1;
        }

        .news-item-link {
            text-decoration: none;
            color: inherit;
            display: block;
        }

        .news-item {
            background: #0f0f0f;
            padding: 16px;
            border-radius: 12px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .news-item:hover {
            background: #1a1a1a;
            transform: translateY(-1px);
        }

        .news-item-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
        }

        .news-source {
            font-size: 11px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .sentiment-tag {
            padding: 3px 10px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .sentiment-tag.positive {
            background: rgba(16, 185, 129, 0.15);
            color: #10b981;
            border: 1px solid rgba(16, 185, 129, 0.2);
        }

        .sentiment-tag.negative {
            background: rgba(239, 68, 68, 0.15);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.2);
        }

        .sentiment-tag.neutral {
            background: rgba(136, 136, 136, 0.15);
            color: #888;
            border: 1px solid rgba(136, 136, 136, 0.2);
        }

        .news-headline {
            font-size: 14px;
            font-weight: 500;
            color: #fff;
            line-height: 1.4;
            margin-bottom: 6px;
        }

        .news-description {
            font-size: 12px;
            color: #888;
            line-height: 1.5;
            margin-bottom: 8px;
        }

        .news-time {
            font-size: 11px;
            color: #666;
        }


        /* Onboarding Modal */
        .onboarding-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .onboarding-modal-overlay.show {
            display: flex;
            opacity: 1;
        }

        .onboarding-modal {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 16px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 0;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            position: relative;
        }

        .onboarding-modal-content {
            padding: 40px 48px;
        }

        .onboarding-step {
            display: none;
        }

        .onboarding-step.active {
            display: block;
        }

        .onboarding-title {
            font-size: 28px;
            font-weight: 700;
            color: #fff;
            margin-bottom: 24px;
            text-align: center;
        }

        .onboarding-subtitle {
            font-size: 16px;
            color: #888;
            margin-bottom: 32px;
            text-align: center;
            line-height: 1.6;
        }

        .language-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 32px;
        }

        .language-option {
            background: #282828;
            border: 2px solid #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .language-option:hover {
            background: #2a2a2a;
            border-color: #ffffff;
        }

        .language-option.selected {
            background: rgba(255, 255, 255, 0.06);
            border-color: #ffffff;
        }

        .language-name {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 4px;
        }

        .language-code {
            font-size: 12px;
            color: #888;
        }

        .disclaimer-content {
            background: #0f0f0f;
            border-left: 4px solid #2a2a2a;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 32px;
        }

        .disclaimer-section {
            margin-bottom: 24px;
        }

        .disclaimer-section:last-child {
            margin-bottom: 0;
        }

        .disclaimer-heading {
            font-size: 18px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .disclaimer-text {
            font-size: 14px;
            color: #ccc;
            line-height: 1.8;
        }

        .disclaimer-text p {
            margin-bottom: 12px;
        }

        .disclaimer-text p:last-child {
            margin-bottom: 0;
        }

        .disclaimer-checkbox-container {
            margin-top: 24px;
            padding-top: 24px;
            border-top: 1px solid #2a2a2a;
        }

        .disclaimer-checkbox-label {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            cursor: pointer;
            font-size: 14px;
            color: #ccc;
            line-height: 1.6;
        }

        .disclaimer-checkbox {
            width: 20px;
            height: 20px;
            margin-top: 2px;
            cursor: pointer;
            flex-shrink: 0;
        }

        .onboarding-button {
            width: 100%;
            padding: 14px 32px;
            background: #ffffff;
            color: #000000;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        .onboarding-button:hover {
            background: #e0e0e0;
            transform: translateY(-1px);
        }

        .onboarding-button:disabled {
            background: #2a2a2a;
            color: #666;
            cursor: not-allowed;
            transform: none;
        }

        .onboarding-button:disabled:hover {
            background: #2a2a2a;
        }

        .onboarding-progress {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-bottom: 32px;
        }

        .progress-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #2a2a2a;
            transition: all 0.2s ease;
        }

        .progress-dot.active {
            background: #ffffff;
            width: 24px;
            border-radius: 4px;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            body {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr;
            }

            .header {
                grid-column: 1;
                grid-row: 2;
            }

            .sidebar {
                grid-column: 1;
                grid-row: 1;
                padding: 20px;
            }

            .main-wrapper {
                grid-column: 1;
                grid-row: 3;
            }

            .container {
                grid-template-columns: 1fr;
                height: auto;
            }

            .drivers-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .onboarding-modal-content {
                padding: 32px 24px;
            }

            .onboarding-title {
                font-size: 24px;
            }

            .language-options {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Onboarding Modal -->
    <div class="onboarding-modal-overlay" id="onboarding-modal-overlay">
        <div class="onboarding-modal">
            <div class="onboarding-modal-content">
                <!-- Progress Indicator -->
                <div class="onboarding-progress">
                    <div class="progress-dot active" id="progress-dot-1"></div>
                    <div class="progress-dot" id="progress-dot-2"></div>
                </div>

                <!-- Step 1: Language Selection -->
                <div class="onboarding-step active" id="step-language">
                    <h2 class="onboarding-title" data-i18n="onboarding.title.language">Select Your Language</h2>
                    <p class="onboarding-subtitle" data-i18n="onboarding.subtitle.language">Choose your preferred language for the dashboard</p>
                    <div class="language-options">
                        <div class="language-option" data-lang="en">
                            <div class="language-name">English</div>
                            <div class="language-code">EN</div>
                        </div>
                        <div class="language-option" data-lang="es">
                            <div class="language-name">Español</div>
                            <div class="language-code">ES</div>
                        </div>
                        <div class="language-option" data-lang="fr">
                            <div class="language-name">Français</div>
                            <div class="language-code">FR</div>
                        </div>
                        <div class="language-option" data-lang="de">
                            <div class="language-name">Deutsch</div>
                            <div class="language-code">DE</div>
                        </div>
                        <div class="language-option" data-lang="zh">
                            <div class="language-name">中文</div>
                            <div class="language-code">ZH</div>
                        </div>
                        <div class="language-option" data-lang="ja">
                            <div class="language-name">日本語</div>
                            <div class="language-code">JA</div>
                        </div>
                    </div>
                    <button class="onboarding-button" id="language-continue-btn" data-i18n="onboarding.button.continue" disabled>Continue</button>
                </div>

                <!-- Step 2: Disclaimer -->
                <div class="onboarding-step" id="step-disclaimer">
                    <h2 class="onboarding-title" data-i18n="onboarding.title.disclaimer">Important Disclaimer</h2>
                    <div class="disclaimer-content">
                        <div class="disclaimer-section">
                            <h3 class="disclaimer-heading">
                                <span>⚠️</span>
                                <span data-i18n="onboarding.disclaimer.heading">Risk Warning</span>
                            </h3>
                            <div class="disclaimer-text">
                                <p data-i18n="onboarding.disclaimer.text">Trading Futures, Forex, CFDs and Stocks involves a risk of loss. Please consider carefully if such trading is appropriate for you. Past performance is not indicative of future results. Any and all signals or educational advice provided by PhoenixBinary and/or Phoenix Algo, LLC and/or any indicators provided by aforementioned are for educational purposes only and do not constitute investment recommendations or advice.</p>
                            </div>
                        </div>
                        <div class="disclaimer-checkbox-container">
                            <label class="disclaimer-checkbox-label">
                                <input type="checkbox" id="disclaimer-checkbox" class="disclaimer-checkbox">
                                <span data-i18n="onboarding.disclaimer.checkbox">I understand and acknowledge the risks associated with trading</span>
                            </label>
                        </div>
                    </div>
                    <button class="onboarding-button" id="disclaimer-continue-btn" data-i18n="onboarding.button.continue" disabled>Continue</button>
                </div>
            </div>
        </div>
    </div>
    <div class="main-wrapper">
    <div class="container">
            <!-- Left Top: Title -->
            <div class="card left-top">
                <div style="display: flex; align-items: center; justify-content: space-between; width: 100%; gap: 32px;">
                    <div style="text-align: left; flex: 1;">
                        <div style="font-size: 40px; font-weight: 700; color: #fff; line-height: 0.9; margin-bottom: 4px;">NASDAQ</div>
                        <div style="font-size: 21px; font-weight: 400; color: #fff; line-height: 0.9;">Sentiment Tracker</div>
                    </div>
                    <div style="width: 65px; height: 65px; background: #1a1a1a; border-radius: 12px; display: flex; align-items: center; justify-content: center; color: #666; font-size: 10px; border: 2px dashed #333;">
                        Logo
                    </div>
                </div>
        </div>

            <!-- Left Bottom: Sentiment Score -->
            <div class="card left-bottom">
                <div class="score-label" data-i18n="dashboard.score.label">Composite Sentiment Score</div>
            <div class="score-value">100</div>
            <div class="score-status" data-i18n="dashboard.status.bullish">BULLISH</div>
        </div>

            <!-- Right Top: Navigation & Time -->
            <div class="right-top">
                <div class="right-top-item">
                    <a href="about.html" class="nav-link" data-i18n="nav.about">About Us</a>
                </div>
                <div class="right-top-item">
                    <a href="news.html" class="nav-link" data-i18n="nav.news">News</a>
                </div>
                <div class="right-top-item">
                    <a href="#" class="nav-link" id="language-selector" data-i18n="nav.language">Language</a>
                </div>
                <div class="right-top-item">
                    <a href="#" class="nav-link" id="logout-link" data-i18n="nav.logout">Logout</a>
                </div>
                <div class="right-top-item">
                    <div class="time-display" id="timezone-selector" style="position: relative;">
                        <span class="current-time" id="current-time">09:45:32</span>
                        <span class="timezone-chevron">▼</span>
                        <div class="timezone-dropdown" id="timezone-dropdown">
                            <!-- Timezone options will be populated dynamically -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Middle: Sentiment Drivers -->
            <div class="card right-middle">
                <h2 class="section-title" data-i18n="dashboard.drivers.title">Sentiment Drivers</h2>
                <div class="drivers-grid-single">
                    <div class="driver-item">
                        <div class="driver-header">
                            <span class="driver-name" data-i18n="dashboard.driver.indicators">Indicators</span>
                            <span class="driver-value negative">-1.2</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill negative" style="width: 30%"></div>
                        </div>
                    </div>

                    <div class="driver-item">
                        <div class="driver-header">
                            <span class="driver-name" data-i18n="dashboard.driver.social">Social Media</span>
                            <span class="driver-value positive">+0.5</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill positive" style="width: 65%"></div>
                        </div>
                    </div>

                    <div class="driver-item">
                        <div class="driver-header">
                            <span class="driver-name" data-i18n="dashboard.driver.news">News Sentiment</span>
                            <span class="driver-value positive">+0.1</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill positive" style="width: 55%"></div>
                        </div>
                    </div>



                    <!-- New Driver 1 -->
                    <div class="driver-item">
                        <div class="driver-header">
                            <span class="driver-name" data-i18n="dashboard.driver.recommendations">Recommendations</span>
                            <span class="driver-value positive">+0.3</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill positive" style="width: 60%"></div>
                        </div>
                    </div>

                    <!-- Market Breadth Driver -->
                    <div class="driver-item" style="opacity: 0;">
                        <div class="driver-header">
                            <span class="driver-name" data-i18n="dashboard.driver.breadth">Market Breadth</span>
                            <span class="driver-value positive">+0.7</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill positive" style="width: 75%"></div>
                        </div>
                    </div>

                    <!-- VIX Driver -->
                    <div class="driver-item">
                        <div class="driver-header">
                            <span class="driver-name" data-i18n="dashboard.driver.vix">VIX</span>
                            <span class="driver-value neutral">0.0</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill neutral" style="width: 50%"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Bottom Row: News Feed -->
            <!-- <div class="card bottom-row">
                <div class="news-feed">
                    <div class="news-header">
                        <div class="news-title">Live News Feed</div>
                        <div class="news-filter">
                            <button class="filter-btn active">All</button>
                            <button class="filter-btn">Positive</button>
                            <button class="filter-btn">Negative</button>
                            <button class="filter-btn">Breaking</button>
                        </div>
                    </div>
                    <div class="news-items">
                        <a href="https://www.bloomberg.com/markets" target="_blank" class="news-item-link">
                            <div class="news-item">
                                <div class="news-item-header">
                                    <span class="news-source">Bloomberg</span>
                                    <span class="sentiment-tag positive">POSITIVE</span>
                                </div>
                                <div class="news-headline">Tech stocks rally as inflation data comes in lower than expected</div>
                                <div class="news-time">2 minutes ago</div>
                            </div>
                        </a>
                        <a href="https://www.reuters.com/markets" target="_blank" class="news-item-link">
                            <div class="news-item">
                                <div class="news-item-header">
                                    <span class="news-source">Reuters</span>
                                    <span class="sentiment-tag positive">POSITIVE</span>
                                </div>
                                <div class="news-headline">NASDAQ futures surge on strong earnings reports from major tech companies</div>
                                <div class="news-time">8 minutes ago</div>
                            </div>
                        </a>
                        <a href="https://www.cnbc.com/markets" target="_blank" class="news-item-link">
                            <div class="news-item">
                                <div class="news-item-header">
                                    <span class="news-source">CNBC</span>
                                    <span class="sentiment-tag negative">NEGATIVE</span>
                                </div>
                                <div class="news-headline">Fed officials signal potential rate hike in upcoming meeting</div>
                                <div class="news-time">15 minutes ago</div>
                            </div>
                        </a>
                        <a href="https://www.wsj.com/markets" target="_blank" class="news-item-link">
                            <div class="news-item">
                                <div class="news-item-header">
                                    <span class="news-source">WSJ</span>
                                    <span class="sentiment-tag neutral">NEUTRAL</span>
                                </div>
                                <div class="news-headline">Market analysts discuss mixed signals from recent economic indicators</div>
                                <div class="news-time">22 minutes ago</div>
                            </div>
                        </a>
                        <a href="https://www.ft.com/markets" target="_blank" class="news-item-link">
                            <div class="news-item">
                                <div class="news-item-header">
                                    <span class="news-source">Financial Times</span>
                                    <span class="sentiment-tag positive">POSITIVE</span>
                                </div>
                                <div class="news-headline">Strong consumer spending data boosts market confidence heading into Q4</div>
                                <div class="news-time">35 minutes ago</div>
                            </div>
                        </a>
                    </div>
                </div>
            </div> -->

            <!-- Bottom Row: Historical Sentiment Trend -->
            <div class="card bottom-row" style="position: relative;">
                <div class="chart-header">
                    <div style="display: flex; align-items: center; gap: 24px;">
                        <span class="chart-title" data-i18n="dashboard.chart.title">Historical Sentiment Trend</span>
                        <label class="price-toggle" for="price-toggle" title="Toggle NASDAQ price">
                            <input type="checkbox" id="price-toggle" checked>
                            <span>Show NASDAQ</span>
                        </label>
                    </div>
                    <div class="chart-legend" style="position: static; left: auto; right: auto; bottom: auto; height: auto; display: flex; align-items: center; gap: 20px; font-size: 11px; margin-left: 9px;">
                        <div class="legend-item">
                            <div class="legend-color orange"></div>
                            <span>Sentiment Score</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color white"></div>
                            <span>NASDAQ</span>
                        </div>
                    </div>
                    <div class="chart-controls">
                        <div class="timeframe-selector">
                            <button class="timeframe-btn" data-timeframe="6h" data-i18n="dashboard.chart.timeframe.6h">Session</button>
                            <button class="timeframe-btn" data-timeframe="5m" data-i18n="dashboard.chart.timeframe.5m">5 min</button>
                            <button class="timeframe-btn" data-timeframe="15m" data-i18n="dashboard.chart.timeframe.15m">15 min</button>
                            <button class="timeframe-btn" data-timeframe="30m" data-i18n="dashboard.chart.timeframe.30m">30 min</button>
                            <button class="timeframe-btn active" data-timeframe="1h" data-i18n="dashboard.chart.timeframe.1h">1 hr</button>
                            <button class="timeframe-btn" data-timeframe="2h" data-i18n="dashboard.chart.timeframe.2h">2 hrs</button>
                            <button class="timeframe-btn" data-timeframe="4h" data-i18n="dashboard.chart.timeframe.4h">4 hrs</button>
                            <button class="timeframe-btn" data-timeframe="2d" data-i18n="dashboard.chart.timeframe.2d">2 days</button>
                            <button class="timeframe-btn" data-timeframe="3d" data-i18n="dashboard.chart.timeframe.3d">3 days</button>
                </div>
                    </div>
                </div>
                <div class="chart-container" id="chart-container" style="flex: 1; min-height: 340px;">
                    <div class="y-axis">
                        <span class="y-axis-label">+100</span>
                        <span class="y-axis-label">+50</span>
                        <span class="y-axis-label">0</span>
                        <span class="y-axis-label">-50</span>
                        <span class="y-axis-label">-100</span>
                    </div>
                    <div class="chart-canvas" id="chart-canvas">
                        <div class="zero-line"></div>
                        <div class="chart-line">
                            <svg viewBox="0 0 100 100" preserveAspectRatio="none" id="sentiment-chart">
                                <defs>
                                    <linearGradient id="lineGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                        <stop offset="0%" style="stop-color:#ff8c42;stop-opacity:1" />
                                        <stop offset="30%" style="stop-color:#ff7b52;stop-opacity:1" />
                                        <stop offset="60%" style="stop-color:#ff6b6b;stop-opacity:1" />
                                        <stop offset="100%" style="stop-color:#ef4444;stop-opacity:1" />
                                    </linearGradient>
                                </defs>
                                <path class="chart-path" d="" />
                            </svg>
                        </div>
                        <svg viewBox="0 0 100 100" preserveAspectRatio="none" id="chart-dots-svg" style="position: absolute; left: 0; right: 0; top: 0; bottom: 0; width: 100%; height: 100%; pointer-events: none;">
                            <g id="chart-dots"></g>
                            <g id="nasdaq-price-line"></g>
                        </svg>
                        <div class="chart-hover-line" id="hover-line"></div>
                        <div class="chart-time-label" id="time-label">00:00:00</div>
                        <div class="chart-tooltip" id="chart-tooltip">
                            <div class="tooltip-label">Sentiment Score</div>
                            <div class="tooltip-value">+56</div>
                            <div class="tooltip-price" id="tooltip-price" style="display: none; color: #ffffff; font-size: 12px; font-weight: 500; margin-top: 4px;">$0.00</div>
                            <div class="tooltip-time">14:32:45</div>
                        </div>
                    </div>
                    <div class="x-axis" id="x-axis-labels">
                        <span>-60m</span>
                        <span>-45m</span>
                        <span>-30m</span>
                        <span>-15m</span>
                        <span>Now</span>
                    </div>
                </div>

                <!-- Market Status Indicator (bottom-left) -->
                <div class="market-status-indicator" id="market-status-indicator" style="display: none;">
                    Market is currently closed. Latest data from <span id="market-close-time"></span>
                </div>
            </div>
        </div>
    </div>


    <script>
        // Clerk authentication check - redirect if not logged in
        window.addEventListener('load', async function() {
            try {
                // Wait for Clerk to be available
                if (!window.Clerk) {
                    // Wait a bit for async script to load
                    let retries = 0;
                    while (!window.Clerk && retries < 50) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        retries++;
                    }
                    
                    if (!window.Clerk) {
                        console.error('Clerk SDK failed to load');
                        window.location.href = '/index.html';
                        return;
                    }
                }
                
                await window.Clerk.load();
                
                // Check if user is authenticated
                if (!window.Clerk.user) {
                    window.location.href = '/index.html';
                    return;
                }

                // Check if onboarding is needed (initial sign-up)
                await checkAndShowOnboarding();
                
                // Setup logout functionality
                const logoutLink = document.getElementById('logout-link');
                if (logoutLink) {
                    logoutLink.addEventListener('click', async function(e) {
                        e.preventDefault();
                        try {
                            await window.Clerk.signOut();
                            window.location.href = '/index.html';
                        } catch (error) {
                            console.error('Error signing out:', error);
                            // Fallback: redirect anyway
                            window.location.href = '/index.html';
                        }
                    });
                }
            } catch (error) {
                console.error('Error loading Clerk:', error);
                // Redirect to index if Clerk fails to load
                window.location.href = '/index.html';
            }
        });

        // Timezone data embedded directly (to avoid CORS issues with local file access)
        const timezonesData = [
            {"offset": "-12:00", "name": "Baker Island Time", "code": "BIT"},
            {"offset": "-11:00", "name": "Samoa Standard Time", "code": "SST"},
            {"offset": "-10:00", "name": "Hawaii-Aleutian Standard Time", "code": "HST"},
            {"offset": "-09:30", "name": "Marquesas Islands Time", "code": "MART"},
            {"offset": "-09:00", "name": "Alaska Standard Time", "code": "AKST"},
            {"offset": "-08:00", "name": "Pacific Standard Time", "code": "PST"},
            {"offset": "-07:00", "name": "Mountain Standard Time", "code": "MST"},
            {"offset": "-06:00", "name": "Central Standard Time", "code": "CST"},
            {"offset": "-05:00", "name": "Eastern Standard Time", "code": "EST"},
            {"offset": "-04:00", "name": "Atlantic Standard Time", "code": "AST"},
            {"offset": "-03:30", "name": "Newfoundland Standard Time", "code": "NST"},
            {"offset": "-03:00", "name": "Argentina Time", "code": "ART"},
            {"offset": "-02:00", "name": "South Georgia Time", "code": "GST"},
            {"offset": "-01:00", "name": "Azores Standard Time", "code": "AZOST"},
            {"offset": "+00:00", "name": "Coordinated Universal Time", "code": "UTC"},
            {"offset": "+01:00", "name": "Central European Time", "code": "CET"},
            {"offset": "+02:00", "name": "Eastern European Time", "code": "EET"},
            {"offset": "+03:00", "name": "Moscow Standard Time", "code": "MSK"},
            {"offset": "+03:30", "name": "Iran Standard Time", "code": "IRST"},
            {"offset": "+04:00", "name": "Gulf Standard Time", "code": "GST"},
            {"offset": "+04:30", "name": "Afghanistan Time", "code": "AFT"},
            {"offset": "+05:00", "name": "Pakistan Standard Time", "code": "PKT"},
            {"offset": "+05:30", "name": "India Standard Time", "code": "IST"},
            {"offset": "+05:45", "name": "Nepal Time", "code": "NPT"},
            {"offset": "+06:00", "name": "Bangladesh Standard Time", "code": "BST"},
            {"offset": "+06:30", "name": "Myanmar Time", "code": "MMT"},
            {"offset": "+07:00", "name": "Indochina Time", "code": "ICT"},
            {"offset": "+08:00", "name": "China Standard Time", "code": "CST"},
            {"offset": "+08:45", "name": "Australian Central Western Standard Time", "code": "ACWST"},
            {"offset": "+09:00", "name": "Japan Standard Time", "code": "JST"},
            {"offset": "+09:30", "name": "Australian Central Standard Time", "code": "ACST"},
            {"offset": "+10:00", "name": "Australian Eastern Standard Time", "code": "AEST"},
            {"offset": "+10:30", "name": "Lord Howe Standard Time", "code": "LHST"},
            {"offset": "+11:00", "name": "Solomon Islands Time", "code": "SBT"},
            {"offset": "+12:00", "name": "New Zealand Standard Time", "code": "NZST"},
            {"offset": "+12:45", "name": "Chatham Islands Standard Time", "code": "CHAST"},
            {"offset": "+13:00", "name": "Tonga Time", "code": "TOT"},
            {"offset": "+14:00", "name": "Line Islands Time", "code": "LINT"}
        ];
        
        let currentTimezoneData = null;
        
        // Parse offset string to decimal hours (e.g., "-05:00" -> -5, "+05:30" -> 5.5)
        function parseOffset(offsetStr) {
            const sign = offsetStr.charAt(0) === '-' ? -1 : 1;
            const parts = offsetStr.substring(1).split(':');
            const hours = parseInt(parts[0]);
            const minutes = parseInt(parts[1]);
            return sign * (hours + minutes / 60);
        }
        
        // Format date and time for a given timezone
        function getTimezoneDateTime(offsetHours) {
            const now = new Date();
            const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
            const localTime = new Date(utc + (3600000 * offsetHours));
            
            const year = localTime.getFullYear();
            const month = String(localTime.getMonth() + 1).padStart(2, '0');
            const day = String(localTime.getDate()).padStart(2, '0');
            const hours = String(localTime.getHours()).padStart(2, '0');
            const minutes = String(localTime.getMinutes()).padStart(2, '0');
            const seconds = String(localTime.getSeconds()).padStart(2, '0');
            
            return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
        }
        
        // Update the main clock display
        function updateTime() {
            if (!currentTimezoneData) {
                // Default to local time if no timezone selected
                const now = new Date();
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');
                document.getElementById('current-time').textContent = `${hours}:${minutes}:${seconds}`;
                return;
            }
            
            const offsetHours = parseOffset(currentTimezoneData.offset);
            const now = new Date();
            const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
            const localTime = new Date(utc + (3600000 * offsetHours));
            
            const hours = String(localTime.getHours()).padStart(2, '0');
            const minutes = String(localTime.getMinutes()).padStart(2, '0');
            const seconds = String(localTime.getSeconds()).padStart(2, '0');
            document.getElementById('current-time').textContent = `${hours}:${minutes}:${seconds}`;
        }
        
        // Initialize timezone system
        function loadTimezones() {
            console.log('Initializing timezones...');
            console.log('Timezones loaded:', timezonesData.length);
            
            // Set default timezone to EST
            currentTimezoneData = timezonesData.find(tz => tz.code === 'EST') || timezonesData[0];
            console.log('Default timezone set to:', currentTimezoneData);
            
            populateTimezoneDropdown();
            updateTime();
        }
        
        // Populate the timezone dropdown with all options
        function populateTimezoneDropdown() {
            const dropdown = document.getElementById('timezone-dropdown');
            
            if (!dropdown) {
                console.error('Timezone dropdown element not found!');
                return;
            }
            
            console.log('Populating dropdown with', timezonesData.length, 'timezones');
            dropdown.innerHTML = '';
            
            timezonesData.forEach((tz, index) => {
                const offsetHours = parseOffset(tz.offset);
                const dateTime = getTimezoneDateTime(offsetHours);
                
                const option = document.createElement('div');
                option.className = 'timezone-option';
                if (currentTimezoneData && currentTimezoneData.code === tz.code) {
                    option.classList.add('active');
                }
                
                option.innerHTML = `
                    <div class="timezone-option-main">
                        <span class="timezone-option-offset">${tz.offset}</span>
                        <span class="timezone-option-code">${tz.code}</span>
                        <span>${tz.name}</span>
                    </div>
                    <div class="timezone-option-datetime">${dateTime}</div>
                `;
                
                option.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectTimezone(tz);
                });
                
                dropdown.appendChild(option);
            });
            
            console.log('Dropdown populated. Children count:', dropdown.children.length);
        }
        
        // Select a timezone
        function selectTimezone(tz) {
            currentTimezoneData = tz;
            
            // Update active state
            document.querySelectorAll('.timezone-option').forEach(opt => opt.classList.remove('active'));
            event.currentTarget.classList.add('active');
            
            // Update time immediately
            updateTime();
            
            // Update chart with new timezone
            if (typeof currentTimeframe !== 'undefined' && typeof updateChart === 'function') {
                updateChart(currentTimeframe);
            }
            
            // Close dropdown
            document.getElementById('timezone-dropdown').classList.remove('show');
            document.getElementById('timezone-selector').classList.remove('open');
        }
        
        // Update dropdown times every second
        function updateDropdownTimes() {
            const options = document.querySelectorAll('.timezone-option');
            timezonesData.forEach((tz, index) => {
                if (options[index]) {
                    const offsetHours = parseOffset(tz.offset);
                    const dateTime = getTimezoneDateTime(offsetHours);
                    const dateTimeElem = options[index].querySelector('.timezone-option-datetime');
                    if (dateTimeElem) {
                        dateTimeElem.textContent = dateTime;
                    }
                }
            });
        }
        
        // Animate progress bars on load
        window.addEventListener('load', () => {
            const progressBars = document.querySelectorAll('.progress-fill');
            progressBars.forEach(bar => {
                const width = bar.style.width;
                bar.style.width = '0';
                setTimeout(() => {
                    bar.style.width = width;
                }, 100);
            });
        });

        // Initialize timezones and dashboard after DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            loadTimezones();
            initializeDashboard();
        });
        
        // Update time every second
        setInterval(() => {
            updateTime();
            // Only update dropdown times if dropdown is open
            const dropdown = document.getElementById('timezone-dropdown');
            if (dropdown && dropdown.classList.contains('show')) {
                updateDropdownTimes();
            }
        }, 1000);

        // News filter buttons
        const filterBtns = document.querySelectorAll('.filter-btn');
        const newsItemLinks = document.querySelectorAll('.news-item-link');
        
        filterBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                filterBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                const filter = btn.textContent.toLowerCase();
                
                newsItemLinks.forEach(link => {
                    const sentimentTag = link.querySelector('.sentiment-tag');
                    const sentiment = sentimentTag ? sentimentTag.textContent.toLowerCase() : '';
                    
                    if (filter === 'all') {
                        link.style.display = 'block';
                    } else if (filter === 'breaking') {
                        // Show first 2 items for "breaking" news
                        const isBreaking = Array.from(newsItemLinks).indexOf(link) < 2;
                        link.style.display = isBreaking ? 'block' : 'none';
                    } else {
                        link.style.display = sentiment === filter ? 'block' : 'none';
                    }
                });
            });
        });

        // Timezone dropdown toggle - initialize after DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            const timezoneSelector = document.getElementById('timezone-selector');
            const timezoneDropdown = document.getElementById('timezone-dropdown');

            if (timezoneSelector && timezoneDropdown) {
                timezoneSelector.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('timezone-option')) {
                        timezoneDropdown.classList.toggle('show');
                        timezoneSelector.classList.toggle('open');
                        
                        // Update all dropdown times when opening
                        if (timezoneDropdown.classList.contains('show')) {
                            updateDropdownTimes();
                        }
                    }
                });

                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!timezoneSelector.contains(e.target)) {
                        timezoneDropdown.classList.remove('show');
                        timezoneSelector.classList.remove('open');
                    }
                });
            }
        });

        // Timeframe selector and chart update
        const timeframeBtns = document.querySelectorAll('.timeframe-btn');
        const xAxisLabels = document.getElementById('x-axis-labels');
        const chartPath = document.querySelector('.chart-path');
        let currentTimeframe = '1h'; // Declare timeframe variable globally
        
        // ===== REAL NASDAQ SENTIMENT DATA =====
        // Fetch real composite sentiment data from the API
        let sentimentDataset = [];
        let sentimentDataset2d = [];
        let sentimentDataset3d = [];
        let currentCompositeScore = 0;
        
        // API Base URL - adjust if needed
        // Dynamic API URL - detects localhost, file://, or production
        const API_BASE_URL = (
            window.location.protocol === 'file:' ||
            window.location.hostname === 'localhost' ||
            window.location.hostname === '127.0.0.1' ||
            window.location.hostname === ''
        ) ? 'http://localhost:8000/api'
          : (window.BACKEND_URL || 'https://nasdaqsentimenttracker-production.up.railway.app/api');

        // Fetch dashboard data (composite score + 3 drivers + historical data)
        async function fetchDashboardData() {
            try {
                console.log('🔄 Fetching dashboard data from API...');
                const response = await fetch(`${API_BASE_URL}/dashboard/`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                console.log('✓ Dashboard data received:', data.composite_score);
                
                // DEBUG: Check what the backend is actually sending for price data
                console.log('🔍 BACKEND RESPONSE DEBUG:');
                if (data.historical && data.historical.length > 0) {
                    console.log('📦 Raw historical[0]:', JSON.stringify(data.historical[0], null, 2));
                    console.log('📦 Keys in historical[0]:', Object.keys(data.historical[0]));
                    console.log('📦 "price" field exists?', 'price' in data.historical[0]);
                    console.log('📦 "price" value:', data.historical[0].price);
                    console.log('📦 Type of price:', typeof data.historical[0].price);
                }
 
                // Update current composite score
                currentCompositeScore = data.composite_score;

                // Update sentiment display and drivers
                updateSentimentDisplay(data);
                updateSentimentDrivers(data.drivers, data.vxn_index);
                updateMarketStatus(data.market_status);

                // Populate sentimentDataset for chart (24 hours)
                if (data.historical && data.historical.length > 0) {
                    console.log('📊 Mapping historical data - first raw point:', data.historical[0]);
                    sentimentDataset = data.historical.map(point => {
                        const mapped = {
                            timestamp: new Date(point.timestamp),
                            sentiment: point.composite_score,
                            price: point.price
                        };
                        return mapped;
                    });
                    console.log(`✓ Loaded ${sentimentDataset.length} historical data points (24h)`);
                    console.log('📊 First mapped point:', sentimentDataset[0]);
                    // Debug: Check price data
                    const pricesWithData = sentimentDataset.filter(p => p.price != null && !isNaN(p.price));
                    console.log(`📊 Price data check: ${pricesWithData.length}/${sentimentDataset.length} points have price data`);
                    if (pricesWithData.length > 0) {
                        console.log(`📊 Sample prices: ${pricesWithData.slice(0, 3).map(p => `$${p.price.toFixed(2)}`).join(', ')}`);
                    } else {
                        console.warn('⚠️ No prices found! Sample point:', sentimentDataset[0]);
                    }
                } else {
                    console.warn('⚠️  No historical data in API response');
                    sentimentDataset = [];
                }

                // Populate sentimentDataset2d for chart (2 days)
                if (data.historical_2d && data.historical_2d.length > 0) {
                    sentimentDataset2d = data.historical_2d.map(point => ({
                        timestamp: new Date(point.timestamp),
                        sentiment: point.composite_score,
                        price: point.price
                    }));
                    console.log(`✓ Loaded ${sentimentDataset2d.length} historical data points (2d)`);
                } else {
                    console.warn('⚠️  No 2-day historical data in API response');
                    sentimentDataset2d = [];
                }

                // Populate sentimentDataset3d for chart (3 days)
                if (data.historical_3d && data.historical_3d.length > 0) {
                    sentimentDataset3d = data.historical_3d.map(point => ({
                        timestamp: new Date(point.timestamp),
                        sentiment: point.composite_score,
                        price: point.price
                    }));
                    console.log(`✓ Loaded ${sentimentDataset3d.length} historical data points (3d)`);
                } else {
                    console.warn('⚠️  No 3-day historical data in API response');
                    sentimentDataset3d = [];
                }

                return data;
            } catch (error) {
                console.error('❌ Error fetching dashboard data:', error);
                // Fallback to default values
                currentCompositeScore = 0;
                sentimentDataset = [];
                sentimentDataset2d = [];
                sentimentDataset3d = [];
                updateSentimentDisplay({
                    composite_score: currentCompositeScore,
                    sentiment_label: 'NEUTRAL'
                });
                return null;
            }
        }
        
        // Fetch historical sentiment data for chart from dashboard endpoint
        async function fetchHistoricalData(timeframeMinutes = 240) {
            try {
                console.log('Fetching historical data from dashboard API...');
                const url = `${API_BASE_URL}/dashboard/`;
                console.log('API URL:', url);

                const response = await fetch(url);
                console.log('Response status:', response.status);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('Dashboard API response received');

                // Populate 24-hour dataset
                if (!data.historical || data.historical.length === 0) {
                    console.warn('No historical data points in API response');
                    sentimentDataset = [];
                } else {
                    sentimentDataset = data.historical.map(point => ({
                        timestamp: new Date(point.timestamp),
                        sentiment: point.composite_score,
                        price: point.price
                    }));
                    console.log('Converted 24h dataset length:', sentimentDataset.length);
                }

                // Populate 2-day dataset
                if (data.historical_2d && data.historical_2d.length > 0) {
                    sentimentDataset2d = data.historical_2d.map(point => ({
                        timestamp: new Date(point.timestamp),
                        sentiment: point.composite_score,
                        price: point.price
                    }));
                    console.log('Converted 2d dataset length:', sentimentDataset2d.length);
                } else {
                    sentimentDataset2d = [];
                }

                // Populate 3-day dataset
                if (data.historical_3d && data.historical_3d.length > 0) {
                    sentimentDataset3d = data.historical_3d.map(point => ({
                        timestamp: new Date(point.timestamp),
                        sentiment: point.composite_score,
                        price: point.price
                    }));
                    console.log('Converted 3d dataset length:', sentimentDataset3d.length);
                } else {
                    sentimentDataset3d = [];
                }

                return data;
            } catch (error) {
                console.error('Error fetching historical data:', error);
                console.error('Error details:', error.message);
                // Fallback to empty datasets
                sentimentDataset = [];
                sentimentDataset2d = [];
                sentimentDataset3d = [];
                return null;
            }
        }
        
        // Update sentiment display with real data
        function updateSentimentDisplay(data) {
            const scoreValueElement = document.querySelector('.score-value');
            const scoreStatus = document.querySelector('.score-status');

            if (!scoreValueElement || !scoreStatus) return;

            const sentiment = data.composite_score;
            const sentimentDisplay = sentiment > 0 ? `+${sentiment.toFixed(1)}` : sentiment.toFixed(1);

            // Update score value
            scoreValueElement.textContent = sentimentDisplay;

            // Update status and colors based on sentiment
            if (sentiment >= 30) {
                scoreStatus.textContent = t('dashboard.status.bullish');
                scoreStatus.setAttribute('data-i18n', 'dashboard.status.bullish');
                scoreStatus.style.color = '#10b981';
                scoreValueElement.style.background = 'linear-gradient(135deg, #10b981 0%, #34d399 100%)';
            } else if (sentiment >= -30) {
                scoreStatus.textContent = t('dashboard.status.neutral');
                scoreStatus.setAttribute('data-i18n', 'dashboard.status.neutral');
                scoreStatus.style.color = '#888';
                scoreValueElement.style.background = 'linear-gradient(135deg, #888 0%, #aaa 100%)';
            } else {
                scoreStatus.textContent = t('dashboard.status.bearish');
                scoreStatus.setAttribute('data-i18n', 'dashboard.status.bearish');
                scoreStatus.style.color = '#ef4444';
                scoreValueElement.style.background = 'linear-gradient(135deg, #ef4444 0%, #f87171 100%)';
            }

            // Apply text styling
            scoreValueElement.style.webkitBackgroundClip = 'text';
            scoreValueElement.style.webkitTextFillColor = 'transparent';
            scoreValueElement.style.backgroundClip = 'text';
        }

        // Track market status globally
        let isMarketOpen = true;

        // Update market status indicator
        function updateMarketStatus(marketStatus) {
            if (!marketStatus) return;

            const indicator = document.getElementById('market-status-indicator');
            const closeTimeSpan = document.getElementById('market-close-time');

            if (!indicator || !closeTimeSpan) return;

            // Update global market status
            isMarketOpen = marketStatus.is_open;

            if (marketStatus.is_open) {
                // Market is open - hide indicator
                indicator.style.display = 'none';
            } else {
                // Market is closed - show small indicator with timestamp
                const closeTime = new Date(marketStatus.last_close_time || new Date());
                const formattedTime = closeTime.toLocaleString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit',
                    timeZoneName: 'short'
                });
                closeTimeSpan.textContent = formattedTime;
                indicator.style.display = 'block';
            }
        }

        // Update sentiment drivers with real data from API
        function updateSentimentDrivers(drivers, vxnIndex) {
            if (!drivers) return;

            // Get driver elements
            const driverItems = document.querySelectorAll('.driver-item');

            // Convert VXN index to a sentiment score (-100 to +100)
            // VXN typically ranges from ~10 to ~40
            // Lower VXN = less volatility = more bullish
            // Higher VXN = more volatility = more bearish
            let vixScore = 0;
            if (vxnIndex) {
                // Normalize VXN: 15 is baseline (neutral), below is bullish, above is bearish
                // Scale: VXN 10 = +100, VXN 15 = 0, VXN 40 = -100
                vixScore = Math.max(-100, Math.min(100, ((15 - vxnIndex) / 15) * 100));
            }

            // Update the drivers with real data from API
            const driverData = [
                {
                    name: t('dashboard.driver.news'),
                    translationKey: 'dashboard.driver.news',
                    value: drivers.news_sentiment?.score || 0,
                    weight: drivers.news_sentiment?.weight || 40
                },
                {
                    name: t('dashboard.driver.social'),
                    translationKey: 'dashboard.driver.social',
                    value: drivers.social_media?.score || 0,
                    weight: drivers.social_media?.weight || 30
                },
                {
                    name: t('dashboard.driver.indicators'),
                    translationKey: 'dashboard.driver.indicators',
                    value: drivers.technical_indicators?.score || 0,
                    weight: drivers.technical_indicators?.weight || 30
                },
                {
                    name: t('dashboard.driver.recommendations'),
                    translationKey: 'dashboard.driver.recommendations',
                    value: drivers.analyst_recommendations?.score || 0,
                    weight: drivers.analyst_recommendations?.weight || 0
                },
                {
                    name: t('dashboard.driver.breadth'),
                    translationKey: 'dashboard.driver.breadth',
                    value: drivers.market_breadth?.score || 0, // Placeholder until implemented
                    weight: drivers.market_breadth?.weight || 0
                },
                {
                    name: t('dashboard.driver.vix'),
                    translationKey: 'dashboard.driver.vix',
                    value: vixScore,
                    weight: 0,
                    rawValue: vxnIndex // Store raw VXN value for display
                }
            ];

            driverData.forEach((driver, index) => {
                if (driverItems[index]) {
                    const driverItem = driverItems[index];
                    const nameElement = driverItem.querySelector('.driver-name');
                    const valueElement = driverItem.querySelector('.driver-value');
                    const progressFill = driverItem.querySelector('.progress-fill');

                    // Update name
                    if (nameElement) {
                        nameElement.textContent = driver.name;
                        // Add translation key as data attribute for future updates
                        if (driver.translationKey) {
                            nameElement.setAttribute('data-i18n', driver.translationKey);
                        }
                    }

                    // Update value with +/- sign
                    if (valueElement) {
                        // Special handling for VIX - show raw VXN value instead of normalized score
                        let displayValue;
                        if (driver.rawValue !== undefined) {
                            displayValue = driver.rawValue.toFixed(2);
                        } else {
                            displayValue = driver.value > 0 ? `+${driver.value.toFixed(1)}` : driver.value.toFixed(1);
                        }
                        valueElement.textContent = displayValue;

                        // Update color based on positive/negative
                        valueElement.classList.remove('positive', 'negative', 'neutral');
                        if (driver.value > 0) {
                            valueElement.classList.add('positive');
                        } else if (driver.value < 0) {
                            valueElement.classList.add('negative');
                        } else {
                            valueElement.classList.add('neutral');
                        }
                    }

                    // Update progress bar
                    if (progressFill) {
                        // Calculate width based on absolute value (0-100 scale)
                        // -80 and +80 both fill 80% of the bar
                        const width = Math.abs(driver.value);
                        const clampedWidth = Math.max(0, Math.min(100, width));

                        progressFill.style.width = `${clampedWidth}%`;

                        // Update color based on positive/negative
                        progressFill.classList.remove('positive', 'negative', 'neutral');
                        if (driver.value > 0) {
                            progressFill.classList.add('positive');
                        } else if (driver.value < 0) {
                            progressFill.classList.add('negative');
                        } else {
                            progressFill.classList.add('neutral');
                        }
                    }
                }
            });

            console.log('Sentiment drivers updated:', driverData);
        }
        
        // Helper function to create smooth SVG path from data points
        function createSmoothPath(points) {
            if (!points || points.length === 0) {
                console.log('No data points to create path');
                return '';
            }

            console.log('Creating path with', points.length, 'points:', points);

            // FIXED SCALE: Always use -100 to +100 range
            // This ensures 0 is always at the center (Y=50)
            const minSentiment = -100;
            const maxSentiment = 100;
            const sentimentRange = 200;

            console.log('Using fixed sentiment range: -100 to +100');

            // Convert sentiment to Y coordinate (0 to 100)
            // +100 sentiment = Y=0 (top of chart)
            // 0 sentiment = Y=50 (center line)
            // -100 sentiment = Y=100 (bottom of chart)
            const sentimentToY = (sentiment) => {
                // Map sentiment from [-100, 100] to [100, 0] (inverted Y axis)
                const y = 50 - (sentiment / 2);
                return Math.max(0, Math.min(100, y)); // Clamp between 0-100
            };

            // Start path at first point
            const x0 = 0;
            const y0 = sentimentToY(points[0].sentiment);
            let path = `M ${x0},${y0}`;

            // Create smooth curve through all points
            for (let i = 1; i < points.length; i++) {
                const x = (i / (points.length - 1)) * 100;
                const y = sentimentToY(points[i].sentiment);

                if (i === 1) {
                    // First curve - use quadratic bezier
                    const cx = x / 2;
                    const prevY = sentimentToY(points[0].sentiment);
                    path += ` Q ${cx},${prevY} ${x},${y}`;
                } else {
                    // Smooth curves using cubic bezier
                    const prevX = ((i - 1) / (points.length - 1)) * 100;
                    const prevY = sentimentToY(points[i - 1].sentiment);
                    const cx1 = prevX + (x - prevX) / 3;
                    const cy1 = prevY;
                    const cx2 = prevX + (x - prevX) * 2 / 3;
                    const cy2 = y;
                    path += ` C ${cx1},${cy1} ${cx2},${cy2} ${x},${y}`;
                }
            }

            console.log('Generated SVG path:', path);
            return path;
        }
        
        // Helper function to format time labels in HH:MM:SS format based on selected timezone
        function formatTimeLabel(minutesAgo) {
            const now = new Date();
            // Calculate the time by subtracting minutes
            const pastTime = new Date(now.getTime() - (minutesAgo * 60000));
            
            // Apply timezone offset if a timezone is selected
            let targetTime = pastTime;
            if (currentTimezoneData) {
                const offsetHours = parseOffset(currentTimezoneData.offset);
                const utc = pastTime.getTime() + (pastTime.getTimezoneOffset() * 60000);
                targetTime = new Date(utc + (3600000 * offsetHours));
            }
            
            const hours = String(targetTime.getHours()).padStart(2, '0');
            const minutes = String(targetTime.getMinutes()).padStart(2, '0');
            const seconds = String(targetTime.getSeconds()).padStart(2, '0');
            
            return `${hours}:${minutes}:${seconds}`;
        }
        
        // Timeframe configurations - how many minutes of data to show
        const timeframeConfig = {
            '5m': {
                minutes: 5,   // Show last 5 minutes of data
                labelCount: 5,
                label: '5min',
                dataset: 'sentimentDataset'
            },
            '15m': {
                minutes: 15,  // Show last 15 minutes
                labelCount: 5,
                label: '15min',
                dataset: 'sentimentDataset'
            },
            '30m': {
                minutes: 30,  // Show last 30 minutes
                labelCount: 6,
                label: '30min',
                dataset: 'sentimentDataset'
            },
            '1h': {
                minutes: 60,  // Show last 1 hour
                labelCount: 5,
                label: '1hr',
                dataset: 'sentimentDataset'
            },
            '2h': {
                minutes: 120, // Show last 2 hours
                labelCount: 6,
                label: '2hrs',
                dataset: 'sentimentDataset'
            },
            '4h': {
                minutes: 240, // Show last 4 hours
                labelCount: 6,
                label: '4hrs',
                dataset: 'sentimentDataset'
            },
            '6h': {
                minutes: 360, // Show last 6 hours (trading session)
                labelCount: 6,
                label: 'Session',
                dataset: 'sentimentDataset'
            },
            '2d': {
                minutes: 2880, // Show last 48 hours (2 days)
                labelCount: 8,
                label: '2days',
                dataset: 'sentimentDataset2d'
            },
            '3d': {
                minutes: 4320, // Show last 72 hours (3 days)
                labelCount: 10,
                label: '3days',
                dataset: 'sentimentDataset3d'
            }
        };

        function getDataForTimeframe(timeframe) {
            const config = timeframeConfig[timeframe];
            console.log(`\n=== Getting data for ${timeframe} (last ${config.minutes} minutes) ===`);

            // Select the appropriate dataset based on timeframe
            let activeDataset;
            if (config.dataset === 'sentimentDataset2d') {
                activeDataset = sentimentDataset2d;
                console.log('Using 2-day dataset');
            } else if (config.dataset === 'sentimentDataset3d') {
                activeDataset = sentimentDataset3d;
                console.log('Using 3-day dataset');
            } else {
                activeDataset = sentimentDataset;
                console.log('Using 24-hour dataset');
            }

            console.log('Total dataset length:', activeDataset.length);

            if (!activeDataset || activeDataset.length === 0) {
                console.log('❌ No sentiment data available for this timeframe');
                return { labels: [], path: '', dataPoints: [], count: 0 };
            }

            // Calculate cutoff time
            // When market is closed, use the last data point's time as "now"
            // When market is open, use current time
            const now = isMarketOpen
                ? new Date()
                : (activeDataset.length > 0 ? new Date(activeDataset[activeDataset.length - 1].timestamp) : new Date());
            
            let cutoffTime;
            let endTime; // For Session timeframe
            
            // Special handling for 'Session' (6h) - show all data from current trading day
            if (timeframe === '6h') {
                // Market hours: 9:30 AM - 4:00 PM Eastern Time
                // Get the current date in Eastern Time to determine the trading day
                const etFormatter = new Intl.DateTimeFormat('en-US', {
                    timeZone: 'America/New_York',
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit'
                });
                
                const parts = etFormatter.formatToParts(now);
                const etYear = parseInt(parts.find(p => p.type === 'year').value);
                const etMonth = parseInt(parts.find(p => p.type === 'month').value) - 1; // JS months are 0-indexed
                const etDay = parseInt(parts.find(p => p.type === 'day').value);
                
                // Helper function to convert ET time to UTC
                // Uses timezone-aware date parsing
                const etToUTC = (year, month, day, hour, minute) => {
                    // Create ISO string for the ET time
                    const isoStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}T${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}:00`;
                    
                    // Try EST (UTC-5) first
                    let testUTC = new Date(isoStr + '-05:00');
                    let etParts = new Intl.DateTimeFormat('en-US', {
                        timeZone: 'America/New_York',
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: false
                    }).formatToParts(testUTC);
                    
                    // Check if this matches our target
                    let matches = parseInt(etParts.find(p => p.type === 'year').value) === year &&
                                 parseInt(etParts.find(p => p.type === 'month').value) === (month + 1) &&
                                 parseInt(etParts.find(p => p.type === 'day').value) === day &&
                                 parseInt(etParts.find(p => p.type === 'hour').value) === hour &&
                                 parseInt(etParts.find(p => p.type === 'minute').value) === minute;
                    
                    // If not, try EDT (UTC-4)
                    if (!matches) {
                        testUTC = new Date(isoStr + '-04:00');
                    }
                    
                    return testUTC;
                };
                
                // Market open: 9:30 AM ET in UTC
                cutoffTime = etToUTC(etYear, etMonth, etDay, 9, 30);
                
                // Market close: 4:00 PM ET in UTC
                endTime = etToUTC(etYear, etMonth, etDay, 16, 0);
                
                console.log('Session timeframe: Current trading day in ET:', `${etYear}-${String(etMonth + 1).padStart(2, '0')}-${String(etDay).padStart(2, '0')}`);
                console.log('Session timeframe: Market open (9:30 AM ET):', cutoffTime.toISOString());
                console.log('Session timeframe: Market close (4:00 PM ET):', endTime.toISOString());
            } else {
                cutoffTime = new Date(now.getTime() - (config.minutes * 60 * 1000));
                endTime = null;
            }
            
            console.log('Cutoff time:', cutoffTime.toISOString());
            if (endTime) console.log('End time:', endTime.toISOString());
            console.log('Reference time (now):', now.toISOString());
            console.log('Market status:', isMarketOpen ? 'OPEN' : 'CLOSED');

            // Filter data points within the timeframe using actual timestamps
            let filteredData;
            if (timeframe === '6h' && endTime) {
                // For Session, filter between market open and close (or current time if market is open)
                const upperBound = isMarketOpen ? now : endTime;
                filteredData = activeDataset.filter(d => d.timestamp >= cutoffTime && d.timestamp <= upperBound);
            } else {
                filteredData = activeDataset.filter(d => d.timestamp >= cutoffTime);
            }
            console.log('✓ Filtered data points:', filteredData.length);

            // Check if we have enough data
            if (filteredData.length < 3) {
                console.log('⚠️  Not enough data points:', filteredData.length);
                return {
                    labels: [],
                    path: '',
                    dataPoints: [],
                    count: filteredData.length,
                    error: 'Not enough data - need at least 3 data points'
                };
            }

            // Sort by timestamp (oldest first for left-to-right chart)
            filteredData.sort((a, b) => a.timestamp - b.timestamp);

            console.log('First point:', filteredData[0].timestamp.toISOString(), '=', filteredData[0].sentiment);
            console.log('Last point:', filteredData[filteredData.length - 1].timestamp.toISOString(), '=', filteredData[filteredData.length - 1].sentiment);

            // Detect market gaps (periods longer than 1 hour between data points)
            const gaps = [];
            for (let i = 1; i < filteredData.length; i++) {
                const timeDiff = (filteredData[i].timestamp - filteredData[i - 1].timestamp) / (1000 * 60); // minutes
                if (timeDiff > 60) { // Gap longer than 1 hour indicates market close
                    gaps.push({
                        index: i,
                        duration: timeDiff,
                        start: filteredData[i - 1].timestamp,
                        end: filteredData[i].timestamp
                    });
                    console.log(`📊 Detected market gap: ${Math.round(timeDiff / 60)}h between ${filteredData[i - 1].timestamp.toLocaleString()} and ${filteredData[i].timestamp.toLocaleString()}`);
                }
            }

            // Use ALL data points for the chart path (smooth line)
            const allPoints = filteredData.map((d, index) => ({
                x: (index / (filteredData.length - 1)) * 100,
                sentiment: d.sentiment,
                price: d.price,
                timestamp: d.timestamp,
                timeLabel: d.timestamp.toLocaleTimeString('en-US', {
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                })
            }));

            // Select evenly spaced points for X-axis labels
            const labelIndices = [];
            const step = (filteredData.length - 1) / (config.labelCount - 1);
            for (let i = 0; i < config.labelCount; i++) {
                const index = Math.round(i * step);
                labelIndices.push(Math.min(index, filteredData.length - 1));
            }

            // Helper function to format timestamp with timezone support
            const formatTimestampLabel = (timestamp) => {
                let displayTime = timestamp;

                // Apply timezone offset if selected
                if (currentTimezoneData) {
                    const offsetHours = parseOffset(currentTimezoneData.offset);
                    const utc = timestamp.getTime() + (timestamp.getTimezoneOffset() * 60000);
                    displayTime = new Date(utc + (3600000 * offsetHours));
                }

                return displayTime.toLocaleTimeString('en-US', {
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                });
            };

            // Generate labels from selected indices
            const labels = [];
            labelIndices.forEach(index => {
                const point = filteredData[index];
                labels.push(formatTimestampLabel(point.timestamp));
            });

            console.log('✓ Generated', allPoints.length, 'data points for path,', labels.length, 'labels for X-axis');

            // Generate smooth path using ALL data points
            const path = createSmoothPath(allPoints);

            return {
                labels,
                path,
                dataPoints: allPoints,
                gaps: gaps,
                count: allPoints.length,
                timeRange: `${config.label} (${allPoints.length} points)`
            };
        }
        
        async function updateChart(timeframe) {
            try {
                console.log('=== UPDATE CHART START ===');
                console.log('Timeframe:', timeframe);

                // Get data for the selected timeframe (no need to fetch - we already have 24h of data)
                const data = getDataForTimeframe(timeframe);

                console.log('Chart update - timeframe:', timeframe, 'data points:', data.count || 0);

                // Handle "not enough data" case
                if (data.error) {
                    console.warn(data.error);
                    chartPath.setAttribute('d', '');
                    const dotsContainer = document.getElementById('chart-dots');
                    if (dotsContainer) dotsContainer.innerHTML = '';
                    xAxisLabels.innerHTML = `<span style="color: #ef4444; font-weight: 600;">⚠️ Not Enough Data</span>
                                            <span style="color: #888; margin-left: 10px; font-size: 12px;">(${data.count} point${data.count !== 1 ? 's' : ''} - need at least 3)</span>`;
                    return;
                }

                if (!data.path || data.path === '' || !data.dataPoints || data.dataPoints.length === 0) {
                    console.warn('No data to display');
                    chartPath.setAttribute('d', '');
                    xAxisLabels.innerHTML = '<span style="color: #666;">No data available - waiting for analysis to run...</span>';
                    return;
                }

                // Update X-axis labels (without data count - moved to header)
                if (data.labels && data.labels.length > 0) {
                    const labelsHtml = data.labels.map(label =>
                        `<span>${label}</span>`
                    ).join('');

                    xAxisLabels.innerHTML = labelsHtml;
                } else {
                    xAxisLabels.innerHTML = '<span>Loading...</span>';
                }

                // Hide the original curved path (we're using the new smooth line with dots instead)
                // console.log('Setting chart path:', data.path);
                chartPath.setAttribute('d', '');  // Clear the old path

                // Verify path was cleared
                // const verifyPath = chartPath.getAttribute('d');
                // console.log('Path verification:', verifyPath);

                // Update Y-axis labels based on actual data range
                if (data.dataPoints && data.dataPoints.length > 0) {
                    updateYAxisLabels(data.dataPoints);
                }

                // Add data point dots for better visibility
                drawDataPointDots(data.dataPoints);

                // Draw market gap lines
                drawMarketGapLines(data.gaps || [], data.dataPoints);

                // Draw Nasdaq price overlay if enabled, otherwise clear it
                if (window.nasdaqPriceEnabled) {
                    drawNasdaqPriceLine(data.dataPoints);
                } else {
                    // Clear the price line when toggle is off
                    const nasdaqContainer = document.getElementById('nasdaq-price-line');
                    if (nasdaqContainer) {
                        nasdaqContainer.innerHTML = '';
                    }
                }

                // Store current data points for hover functionality
                window.currentChartData = data.dataPoints;

                console.log('=== UPDATE CHART COMPLETE ===');
            } catch (error) {
                console.error('Error updating chart:', error);
                console.error('Stack trace:', error.stack);
            }
        }
        
        // Draw data point dots and connecting lines for better visibility
        function drawDataPointDots(dataPoints) {
            const dotsContainer = document.getElementById('chart-dots');
            if (!dotsContainer) return;

            // Clear existing dots
            dotsContainer.innerHTML = '';

            if (!dataPoints || dataPoints.length === 0) return;

            // FIXED SCALE: Always use -100 to +100 range (same as createSmoothPath)
            // This ensures 0 is always at the center (Y=50)
            const sentimentToY = (sentiment) => {
                // Map sentiment from [-100, 100] to [100, 0] (inverted Y axis)
                // +100 sentiment = Y=0 (top of chart)
                // 0 sentiment = Y=50 (center line)
                // -100 sentiment = Y=100 (bottom of chart)
                const y = 50 - (sentiment / 2);
                return Math.max(0, Math.min(100, y)); // Clamp between 0-100
            };

            // Create smooth path connecting all dots
            if (dataPoints.length > 1) {
                let pathD = `M ${dataPoints[0].x},${sentimentToY(dataPoints[0].sentiment)}`;

                for (let i = 1; i < dataPoints.length; i++) {
                    const x = dataPoints[i].x;
                    const y = sentimentToY(dataPoints[i].sentiment);

                    if (i === 1 && dataPoints.length === 2) {
                        // For just 2 points, draw a straight line
                        pathD += ` L ${x},${y}`;
                    } else {
                        // Use quadratic bezier for smooth curves
                        const prevX = dataPoints[i - 1].x;
                        const prevY = sentimentToY(dataPoints[i - 1].sentiment);
                        const cpX = (prevX + x) / 2;
                        const cpY = (prevY + y) / 2;
                        pathD += ` Q ${cpX},${cpY} ${x},${y}`;
                    }
                }

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathD);
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', '#ff8c42');
                path.setAttribute('stroke-width', '0.25');
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('stroke-linejoin', 'round');
                path.setAttribute('opacity', '0.9');
                dotsContainer.appendChild(path);
            }

            // Dots removed per user preference - just showing smooth line
            console.log(`Drew sentiment line with ${dataPoints.length} data points`);
        }

        // Draw vertical dotted lines for market gaps
        function drawMarketGapLines(gaps, dataPoints) {
            // Remove existing gap lines
            const existingLines = document.querySelectorAll('.market-gap-line');
            existingLines.forEach(line => line.remove());

            if (!gaps || gaps.length === 0 || !dataPoints || dataPoints.length === 0) {
                return;
            }

            const chartContainer = document.getElementById('chart-container');
            if (!chartContainer) return;

            // Draw a vertical line at each gap
            gaps.forEach(gap => {
                // Find the x position for this gap (at the start of the gap index)
                const xPercent = (gap.index / (dataPoints.length - 1)) * 100;

                // Create the gap line element
                const gapLine = document.createElement('div');
                gapLine.className = 'market-gap-line';
                gapLine.style.left = `calc(50px + (100% - 70px) * ${xPercent / 100})`;

                chartContainer.appendChild(gapLine);

                console.log(`📊 Drew market gap line at ${xPercent.toFixed(1)}% (${Math.round(gap.duration / 60)}h gap)`);
            });
        }

        // Update Y-axis labels with fixed scale (-100 to +100)
        function updateYAxisLabels(dataPoints) {
            const yAxis = document.querySelector('.y-axis');
            if (yAxis) {
                // FIXED SCALE: Always show -100 to +100 with 0 at center
                yAxis.innerHTML = `
                    <span class="y-axis-label">+100</span>
                    <span class="y-axis-label">+50</span>
                    <span class="y-axis-label">0</span>
                    <span class="y-axis-label">-50</span>
                    <span class="y-axis-label">-100</span>
                `;
            }
        }

        // Draw Nasdaq price line overlay
        function drawNasdaqPriceLine(dataPoints) {
            console.log('🎨 drawNasdaqPriceLine called, toggle enabled:', window.nasdaqPriceEnabled);
            const nasdaqContainer = document.getElementById('nasdaq-price-line');
            if (!nasdaqContainer) {
                console.error('❌ nasdaq-price-line container not found');
                return;
            }

            // Clear existing line
            nasdaqContainer.innerHTML = '';

            if (!dataPoints || dataPoints.length === 0) {
                console.warn('⚠️ No dataPoints provided');
                return;
            }

            console.log(`📊 Checking ${dataPoints.length} data points for price data...`);
            // Filter out points without price data
            const pricePoints = dataPoints.filter(p => p.price != null && !isNaN(p.price));
            console.log(`📊 Found ${pricePoints.length} points with valid price data`);
            
            if (pricePoints.length === 0) {
                console.warn('❌ No Nasdaq price data available after filtering');
                console.log('Sample dataPoint:', dataPoints[0]);
                return;
            }
            
            console.log('✅ Drawing price line with:', pricePoints.length, 'points');
            console.log('Sample prices:', pricePoints.slice(0, 3).map(p => `$${p.price?.toFixed(2)}`).join(', '));

            // Calculate median price for current time window
            const prices = pricePoints.map(p => p.price).sort((a, b) => a - b);
            const medianPrice = prices.length % 2 === 0
                ? (prices[prices.length / 2 - 1] + prices[prices.length / 2]) / 2
                : prices[Math.floor(prices.length / 2)];

            // Find min/max prices for scaling
            const minPrice = Math.min(...prices);
            const maxPrice = Math.max(...prices);

            console.log(`📊 Price range: $${minPrice.toFixed(2)} - $${maxPrice.toFixed(2)}, Median: $${medianPrice.toFixed(2)}`);

            // Store for tooltip
            window.nasdaqPriceScale = { medianPrice, minPrice, maxPrice };

            // Map price to Y coordinate (0-100)
            // Median price maps to Y=50 (center line, same as sentiment 0)
            const priceToY = (price) => {
                const maxOffset = Math.max(Math.abs(minPrice - medianPrice), Math.abs(maxPrice - medianPrice));
                if (maxOffset === 0) return 50;

                const priceOffset = price - medianPrice;
                const normalizedOffset = priceOffset / maxOffset;
                const y = 50 - (normalizedOffset * 40);

                return Math.max(10, Math.min(90, y));
            };

            // Create smooth path connecting all price points
            if (pricePoints.length > 1) {
                let pathD = `M ${pricePoints[0].x},${priceToY(pricePoints[0].price)}`;

                for (let i = 1; i < pricePoints.length; i++) {
                    const x = pricePoints[i].x;
                    const y = priceToY(pricePoints[i].price);

                    if (i === 1 && pricePoints.length === 2) {
                        pathD += ` L ${x},${y}`;
                    } else {
                        const prevX = pricePoints[i - 1].x;
                        const prevY = priceToY(pricePoints[i - 1].price);
                        const cpX = (prevX + x) / 2;
                        const cpY = (prevY + y) / 2;
                        pathD += ` Q ${cpX},${cpY} ${x},${y}`;
                    }
                }

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathD);
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', '#ffffff');
                path.setAttribute('stroke-width', '0.1');  // Very thin line
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('stroke-linejoin', 'round');
                path.setAttribute('opacity', '0.9');  // Increased opacity for better visibility
                nasdaqContainer.appendChild(path);

                console.log(`✅ Drew Nasdaq price line with ${pricePoints.length} points`);
                console.log(`📍 Median price (center): $${medianPrice.toFixed(2)}`);
                console.log(`📍 Price range: $${minPrice.toFixed(2)} - $${maxPrice.toFixed(2)}`);
            }
        }

        // Nasdaq price overlay toggle state - DEFAULT TO TRUE so line shows immediately
        window.nasdaqPriceEnabled = true;

        // Checkbox toggle handler
        const priceToggleCheckbox = document.getElementById('price-toggle');
        if (priceToggleCheckbox) {
            priceToggleCheckbox.checked = true;
            priceToggleCheckbox.addEventListener('change', async () => {
                window.nasdaqPriceEnabled = !!priceToggleCheckbox.checked;
                console.log(`☑️ Show Nasdaq: ${window.nasdaqPriceEnabled}`);
                await updateChart(currentTimeframe);
            });
        }

        timeframeBtns.forEach(btn => {
            btn.addEventListener('click', async () => {
                timeframeBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                const timeframe = btn.dataset.timeframe;
                await updateChart(timeframe);
                currentTimeframe = timeframe; // Update current timeframe for hover
            });
        });
        
        // Initialize the dashboard
        async function initializeDashboard() {
            try {
                console.log('Initializing NASDAQ Sentiment Dashboard...');
                console.log('Current time:', new Date().toISOString());

                // Fetch dashboard data (composite score + drivers)
                const dashboardData = await fetchDashboardData();
                if (dashboardData) {
                    console.log('Dashboard data loaded - Composite score:', dashboardData.composite_score);
                    console.log('Drivers:', dashboardData.drivers);
                }

                // Initialize chart with default timeframe (1h = last 3 hours)
                currentTimeframe = '1h';
                await updateChart(currentTimeframe);

                console.log('Dashboard initialized successfully');
            } catch (error) {
                console.error('Error initializing dashboard:', error);
                // Show fallback values
                const scoreElement = document.querySelector('.score-value');
                const statusElement = document.querySelector('.score-status');
                if (scoreElement) scoreElement.textContent = '0.0';
                if (statusElement) statusElement.textContent = 'LOADING...';
            }
        }

        // Update data periodically (every 60 seconds) - only when market is open
        setInterval(async () => {
            // Only refresh if market is open
            if (!isMarketOpen) {
                console.log('Market is closed - skipping auto-refresh');
                return;
            }

            try {
                console.log('Auto-refreshing dashboard data...');
                await fetchDashboardData();
                await updateChart(currentTimeframe);
            } catch (error) {
                console.error('Error updating dashboard:', error);
            }
        }, 60000); // Check every 60 seconds

        // Chart hover functionality
        const chartCanvas = document.getElementById('chart-canvas');
        const hoverLine = document.getElementById('hover-line');
        const timeLabel = document.getElementById('time-label');
        const tooltip = document.getElementById('chart-tooltip');
        const tooltipValue = tooltip.querySelector('.tooltip-value');
        const tooltipTime = tooltip.querySelector('.tooltip-time');

        function interpolateValue(x, dataPoints) {
            if (!dataPoints || dataPoints.length === 0) return { value: 0, time: 'Now', timestamp: new Date(), price: null };
            
            // Find the two closest data points
            let before = dataPoints[0];
            let after = dataPoints[dataPoints.length - 1];
            
            for (let i = 0; i < dataPoints.length - 1; i++) {
                if (x >= dataPoints[i].x && x <= dataPoints[i + 1].x) {
                    before = dataPoints[i];
                    after = dataPoints[i + 1];
                    break;
                }
            }
            
            // Linear interpolation for sentiment value
            const ratio = (x - before.x) / (after.x - before.x);
            const value = before.sentiment + ratio * (after.sentiment - before.sentiment);
            
            // Linear interpolation for price (if available)
            let price = null;
            if (before.price != null && after.price != null) {
                price = before.price + ratio * (after.price - before.price);
            } else if (before.price != null) {
                price = before.price;
            } else if (after.price != null) {
                price = after.price;
            }
            
            // Use the closest data point's time
            const closestPoint = ratio < 0.5 ? before : after;
            const time = closestPoint.timeLabel || closestPoint.timestamp?.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            }) || 'N/A';
            
            return { value: Math.round(value), time: time, timestamp: closestPoint.timestamp, price: price };
        }

        chartCanvas.addEventListener('mousemove', (e) => {
            const rect = chartCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            
            // Calculate position as percentage (0-100)
            const percentX = (x / rect.width) * 100;
            
            // Use the globally stored current chart data
            if (!window.currentChartData) return;
            
            // Interpolate the value based on X position
            const result = interpolateValue(percentX, window.currentChartData);
            
            // Show hover line
            hoverLine.style.display = 'block';
            hoverLine.style.left = x + 'px';
            
            // Show time label at bottom of hover line
            timeLabel.classList.add('show');
            const labelWidth = 90; // Approximate width of the time label
            const labelX = Math.max(0, Math.min(x - (labelWidth / 2), rect.width - labelWidth));
            timeLabel.style.left = labelX + 'px';
            timeLabel.innerHTML = `<strong>${result.time}</strong>`;
            
            // Show tooltip with actual data (add +/- sign for sentiment)
            tooltip.style.display = 'block';
            const sentimentDisplay = result.value > 0 ? `+${result.value}` : result.value;
            tooltipValue.textContent = sentimentDisplay;
            tooltipTime.textContent = result.time;
            
            // Show/hide Nasdaq price based on toggle state
            const tooltipPrice = document.getElementById('tooltip-price');
            if (tooltipPrice) {
                if (window.nasdaqPriceEnabled && result.price != null) {
                    tooltipPrice.style.display = 'block';
                    tooltipPrice.textContent = `$${result.price.toFixed(2)}`;
                } else {
                    tooltipPrice.style.display = 'none';
                }
            }
            
            // Position tooltip
            const tooltipX = x + 15;
            const tooltipY = e.clientY - rect.top - 60;
            
            tooltip.style.left = tooltipX + 'px';
            tooltip.style.top = tooltipY + 'px';
            
            // Adjust tooltip position if it goes off screen
            if (tooltipX + tooltip.offsetWidth > rect.width) {
                tooltip.style.left = (x - tooltip.offsetWidth - 15) + 'px';
            }
            if (tooltipY < 0) {
                tooltip.style.top = '10px';
            }
        });

        chartCanvas.addEventListener('mouseleave', () => {
            hoverLine.style.display = 'none';
            timeLabel.classList.remove('show');
            tooltip.style.display = 'none';
        });

        // Hover tooltip functionality
        const hoverTooltip = document.getElementById('hover-tooltip');
        const tooltipText = document.getElementById('tooltip-text');
        const tooltipElements = document.querySelectorAll('.has-tooltip');

        tooltipElements.forEach(element => {
            element.addEventListener('mouseenter', (e) => {
                const text = element.getAttribute('data-tooltip');
                
                tooltipText.textContent = text;
                hoverTooltip.classList.add('show');
                
                // Position tooltip near cursor
                updateTooltipPosition(e);
            });

            element.addEventListener('mousemove', (e) => {
                updateTooltipPosition(e);
            });

            element.addEventListener('mouseleave', () => {
                hoverTooltip.classList.remove('show');
            });
        });

        function updateTooltipPosition(e) {
            const offsetX = 15;
            const offsetY = 15;
            let x = e.clientX + offsetX;
            let y = e.clientY + offsetY;

            // Keep tooltip on screen
            const tooltipRect = hoverTooltip.getBoundingClientRect();
            if (x + tooltipRect.width > window.innerWidth) {
                x = e.clientX - tooltipRect.width - offsetX;
            }
            if (y + tooltipRect.height > window.innerHeight) {
                y = e.clientY - tooltipRect.height - offsetY;
            }

            hoverTooltip.style.left = x + 'px';
            hoverTooltip.style.top = y + 'px';
        }

        // ===== ONBOARDING MODAL FUNCTIONALITY =====
        
        /**
         * Check if user needs onboarding and show modal if needed
         * Uses localStorage to track completion per user
         */
        async function checkAndShowOnboarding() {
            try {
                const user = window.Clerk.user;
                if (!user) return;

                const userId = user.id;
                const onboardingKey = `onboarding_completed_${userId}`;
                
                // Check if user has already completed onboarding
                const hasCompletedOnboarding = localStorage.getItem(onboardingKey) === 'true';
                
                if (!hasCompletedOnboarding) {
                    // Show onboarding modal
                    showOnboardingModal();
                }
            } catch (error) {
                console.error('Error checking onboarding status:', error);
            }
        }

        /**
         * Show the onboarding modal
         */
        function showOnboardingModal() {
            const overlay = document.getElementById('onboarding-modal-overlay');
            if (overlay) {
                overlay.classList.add('show');
                // Prevent body scroll
                document.body.style.overflow = 'hidden';
            }
        }

        /**
         * Hide the onboarding modal
         */
        function hideOnboardingModal() {
            const overlay = document.getElementById('onboarding-modal-overlay');
            if (overlay) {
                overlay.classList.remove('show');
                // Restore body scroll
                document.body.style.overflow = '';
            }
        }

        /**
         * Mark onboarding as completed
         */
        async function completeOnboarding(selectedLanguage) {
            try {
                const user = window.Clerk.user;
                if (!user) return;

                const userId = user.id;
                const onboardingKey = `onboarding_completed_${userId}`;
                
                // Save selected language (optional, for future use)
                if (selectedLanguage) {
                    localStorage.setItem(`user_language_${userId}`, selectedLanguage);
                }
                
                // Mark onboarding as completed
                localStorage.setItem(onboardingKey, 'true');
                
                // Hide modal
                hideOnboardingModal();
            } catch (error) {
                console.error('Error completing onboarding:', error);
                // Hide modal anyway
                hideOnboardingModal();
            }
        }

        // Initialize onboarding modal functionality
        document.addEventListener('DOMContentLoaded', () => {
            const languageOptions = document.querySelectorAll('.language-option');
            const languageContinueBtn = document.getElementById('language-continue-btn');
            const disclaimerContinueBtn = document.getElementById('disclaimer-continue-btn');
            const stepLanguage = document.getElementById('step-language');
            const stepDisclaimer = document.getElementById('step-disclaimer');
            const progressDot1 = document.getElementById('progress-dot-1');
            const progressDot2 = document.getElementById('progress-dot-2');

            let selectedLanguage = null;

            // Language selection
            languageOptions.forEach(option => {
                option.addEventListener('click', () => {
                    // Remove previous selection
                    languageOptions.forEach(opt => opt.classList.remove('selected'));

                    // Select new option
                    option.classList.add('selected');
                    selectedLanguage = option.dataset.lang;

                    // Apply language immediately
                    setLanguage(selectedLanguage);

                    // Enable continue button
                    languageContinueBtn.disabled = false;
                });
            });

            // Continue from language step
            languageContinueBtn.addEventListener('click', () => {
                if (!selectedLanguage) return;

                // Switch to disclaimer step
                stepLanguage.classList.remove('active');
                stepDisclaimer.classList.add('active');

                // Update progress dots
                progressDot1.classList.remove('active');
                progressDot2.classList.add('active');
            });

            // Disclaimer checkbox handling
            const disclaimerCheckbox = document.getElementById('disclaimer-checkbox');
            if (disclaimerCheckbox) {
                disclaimerCheckbox.addEventListener('change', () => {
                    // Enable/disable continue button based on checkbox state
                    disclaimerContinueBtn.disabled = !disclaimerCheckbox.checked;
                });
            }

            // Continue from disclaimer step (complete onboarding)
            disclaimerContinueBtn.addEventListener('click', () => {
                completeOnboarding(selectedLanguage);
            });
        });

        // Language selector functionality for main navigation
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Setting up language selector...');
            const languageSelector = document.getElementById('language-selector');
            console.log('Language selector element:', languageSelector);
            if (languageSelector) {
                languageSelector.addEventListener('click', (e) => {
                    e.preventDefault();
                    console.log('Language selector clicked!');
                    showLanguageModal();
                });
                console.log('Language selector event listener added');
            } else {
                console.error('Language selector element not found!');
            }
        });

        // Show language selection modal
        function showLanguageModal() {
            const languages = [
                { code: 'en', name: 'English', nativeName: 'English' },
                { code: 'es', name: 'Spanish', nativeName: 'Español' },
                { code: 'fr', name: 'French', nativeName: 'Français' },
                { code: 'de', name: 'German', nativeName: 'Deutsch' },
                { code: 'zh', name: 'Chinese', nativeName: '中文' },
                { code: 'ja', name: 'Japanese', nativeName: '日本語' }
            ];

            const currentLang = getCurrentLanguage();

            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(4px);
                z-index: 10000; display: flex; align-items: center; justify-content: center;
            `;

            const content = document.createElement('div');
            content.style.cssText = `
                background: #1a1a1a; border: 1px solid #2a2a2a; border-radius: 16px;
                max-width: 500px; width: 90%; padding: 40px 48px; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            `;

            const title = document.createElement('h2');
            title.textContent = 'Select Language';
            title.style.cssText = `
                font-size: 28px; font-weight: 700; color: #fff;
                margin-bottom: 24px; text-align: center;
            `;

            const langGrid = document.createElement('div');
            langGrid.style.cssText = `
                display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 24px;
            `;

            languages.forEach(lang => {
                const langBtn = document.createElement('div');
                langBtn.style.cssText = `
                    background: #0f0f0f; border: 2px solid ${lang.code === currentLang ? '#10b981' : '#2a2a2a'};
                    border-radius: 12px; padding: 16px; cursor: pointer; transition: all 0.2s ease;
                    display: flex; flex-direction: column; gap: 4px; text-align: center;
                `;

                langBtn.innerHTML = `
                    <div style="font-size: 16px; font-weight: 600; color: ${lang.code === currentLang ? '#10b981' : '#fff'};">${lang.nativeName}</div>
                    <div style="font-size: 12px; color: #888; text-transform: uppercase; letter-spacing: 1px;">${lang.code}</div>
                `;

                langBtn.addEventListener('mouseenter', () => {
                    if (lang.code !== currentLang) {
                        langBtn.style.background = '#1a1a1a';
                        langBtn.style.borderColor = '#333';
                    }
                });

                langBtn.addEventListener('mouseleave', () => {
                    if (lang.code !== currentLang) {
                        langBtn.style.background = '#0f0f0f';
                        langBtn.style.borderColor = '#2a2a2a';
                    }
                });

                langBtn.addEventListener('click', () => {
                    setLanguage(lang.code);
                    document.body.removeChild(modal);
                });

                langGrid.appendChild(langBtn);
            });

            const closeBtn = document.createElement('button');
            closeBtn.textContent = 'Close';
            closeBtn.style.cssText = `
                width: 100%; padding: 14px 32px; background: #ffffff; color: #000000;
                border: none; border-radius: 12px; font-size: 16px; font-weight: 600;
                cursor: pointer; transition: all 0.2s ease; font-family: inherit;
            `;

            closeBtn.addEventListener('mouseenter', () => {
                closeBtn.style.background = '#e0e0e0';
            });

            closeBtn.addEventListener('mouseleave', () => {
                closeBtn.style.background = '#ffffff';
            });

            closeBtn.addEventListener('click', () => {
                document.body.removeChild(modal);
            });

            content.appendChild(title);
            content.appendChild(langGrid);
            content.appendChild(closeBtn);
            modal.appendChild(content);

            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });

            document.body.appendChild(modal);
        }
    </script>
</body>
</html>

