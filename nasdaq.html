<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NASDAQ Sentiment Dashboard</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">

    <!-- Translation System -->
    <script src="translations.js"></script>

    <!-- Clerk SDK -->
    <script
        async
        crossorigin="anonymous"
        data-clerk-publishable-key="pk_test_Zmxvd2luZy1naWJib24tNjUuY2xlcmsuYWNjb3VudHMuZGV2JA"
        src="https://flowing-gibbon-65.clerk.accounts.dev/npm/@clerk/clerk-js@5/dist/clerk.browser.js"
        type="text/javascript"
    ></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            overflow: hidden;
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: radial-gradient(ellipse at top, #0a0a0a 0%, #000000 50%);
            background-attachment: fixed;
            min-height: 100vh;
            max-height: 100vh;
            margin: 0;
            color: white;
            padding: 10px 0px;
            overflow: hidden;
            height: 100%;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(16, 185, 129, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 140, 66, 0.03) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .main-wrapper {
            width: 100%;
            max-width: 100%;
            position: relative;
            z-index: 1;
        }

        .container {
            width: 95%;
            display: grid;
            grid-template-columns: 0.7fr 3.3fr;
            grid-template-rows: minmax(0, 0.6fr) auto auto auto auto auto auto;
            row-gap: 18px;
            column-gap: 15px;
            margin: 0 auto;
        }

        .card {
            background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 22px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(255, 255, 255, 0.05);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
        }

        .card:hover {
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .card.right-top {
            padding: 8px 32px;
        }

        .left-column-wrapper {
            grid-column: 1;
            grid-row: 1 / 7;
            display: grid;
            grid-template-rows: 3fr 7fr;
            row-gap: 18px;
        }

        .left-top {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding-top: 24px;
            padding-bottom: 24px;
            padding-left: 16px;
            padding-right: 16px;
            margin-top: -5px;
            margin-bottom: 0px;
            overflow: hidden;
            box-sizing: border-box;
        }

        .left-bottom {
            display: flex;
            flex-direction: column;
            padding: 22px;
            margin-top: 0px;
        }

        .right-top {
            grid-column: 2;
            grid-row: 1 / 2;
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 8px;
            align-items: center;
            margin-bottom: 70px;
            margin-top: -5px;
            position: relative;
            z-index: 100;
        }

        .right-top-item {
            background: linear-gradient(135deg, #1f1f1f 0%, #2a2a2a 100%);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 8px 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 70%;
            min-height: 44px;
            position: relative;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .right-top-item:hover {
            background: linear-gradient(135deg, #2a2a2a 0%, #333333 100%);
            border-color: rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }


        .bottom-row {
            grid-column: 2;
            grid-row: 2 / 7;
            padding: 12px 19px 0px 19px;
            margin-top: -10px;
            position: relative;
            z-index: 1;
        }

        /* Logout link styles */
        .logout-link-container {
            grid-column: 1 / -1;
            display: flex;
            justify-content: flex-end;
            margin-top: -10px;
            margin-bottom: 20px;
            padding-top: 0;
        }

        .logout-link {
            color: #888;
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            transition: color 0.2s ease;
            cursor: pointer;
            margin-right: 30px;
        }

        .logout-link:hover {
            color: #fff;
        }

        /* Sentiment Score Styles */
        .score-label {
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 1.5px;
            color: #fff;
            margin-bottom: 10px;
            text-transform: capitalize;
        }

        .score-value {
            font-size: 64px;
            font-weight: 700;
            background: linear-gradient(135deg, #10b981 0%, #34d399 50%, #10b981 100%);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1;
            margin-bottom: 6px;
            filter: drop-shadow(0 0 20px rgba(16, 185, 129, 0.4));
            animation: gradient-shift 3s ease infinite;
        }

        @keyframes gradient-shift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .score-status {
            font-size: 16px;
            font-weight: 600;
            color: #10b981;
            letter-spacing: 2px;
            text-shadow: 0 0 15px rgba(16, 185, 129, 0.4);
        }

        /* Time Zone Styles */
        .timezone-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 24px;
            width: 100%;
            align-items: center;
        }

        .nav-links {
            display: flex;
            gap: 24px;
            align-items: center;
        }

        .nav-link {
            color: #fff;
            font-size: 13px;
            font-weight: 500;
            text-decoration: none;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            position: relative;
            padding: 4px 8px;
            border-radius: 6px;
        }

        .nav-link::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            width: 0;
            height: 2px;
            background: linear-gradient(90deg, #10b981, #34d399);
            transition: all 0.3s ease;
            transform: translateX(-50%);
        }

        .nav-link:hover {
            color: #10b981;
            background: rgba(16, 185, 129, 0.1);
        }

        .nav-link:hover::after {
            width: 80%;
        }

        .time-zone-group {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .time-display {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .time-display:hover {
            opacity: 1;
        }

        .current-time {
            font-size: 15px;
            font-weight: 600;
            letter-spacing: -0.5px;
            color: #fff;
        }

        .timezone-chevron {
            font-size: 13px;
            color: #888;
            transition: transform 0.2s ease;
        }

        .time-display:hover .timezone-chevron {
            color: #ccc;
        }

        .timezone-dropdown {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 12px;
            padding: 8px;
            min-width: 420px;
            max-width: 500px;
            max-height: 400px;
            overflow-y: auto;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.8);
            opacity: 1;
        }

        .timezone-dropdown.show {
            display: block;
        }

        .timezone-option {
            padding: 10px 14px;
            color: #ccc;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 4px;
            opacity: 1;
            background: transparent;
        }

        .timezone-option:hover {
            background: #2a2a2a;
            color: white;
        }

        .timezone-option.active {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
            opacity: 1;
        }

        .timezone-option-main {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
        }

        .timezone-option-offset {
            display: inline-block;
            min-width: 60px;
            color: #10b981;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }

        .timezone-option-code {
            display: inline-block;
            padding: 2px 6px;
            background: #0f0f0f;
            border-radius: 6px;
            font-size: 10px;
            font-weight: 600;
            color: #888;
            font-family: 'Courier New', monospace;
            opacity: 1;
        }

        .timezone-option-datetime {
            font-size: 11px;
            color: #666;
            margin-left: 60px;
            font-family: 'Courier New', monospace;
        }

        .timezone-dropdown::-webkit-scrollbar {
            width: 8px;
        }

        .timezone-dropdown::-webkit-scrollbar-track {
            background: #0f0f0f;
            border-radius: 6px;
        }

        .timezone-dropdown::-webkit-scrollbar-thumb {
            background: #2a2a2a;
            border-radius: 6px;
        }

        .timezone-dropdown::-webkit-scrollbar-thumb:hover {
            background: #333;
        }

        /* Indices Dropdown Styles */
        .indices-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .indices-selector:hover {
            opacity: 0.8;
        }

        .indices-label {
            font-size: 13px;
            font-weight: 500;
            color: #fff;
        }

        .indices-chevron {
            font-size: 13px;
            color: #888;
            transition: transform 0.2s ease;
        }

        .indices-selector:hover .indices-chevron {
            color: #ccc;
        }

        .indices-dropdown {
            position: absolute;
            top: calc(100% + 8px);
            left: 0;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 12px;
            padding: 8px;
            min-width: 150px;
            display: none;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.8);
        }

        .indices-dropdown.show {
            display: block;
        }

        .indices-option {
            padding: 10px 14px;
            color: #ccc;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.2s ease;
            margin-bottom: 4px;
            background: transparent;
        }

        .indices-option:hover {
            background: #2a2a2a;
            color: white;
        }

        .indices-option.active {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .market-status {
            display: inline-block;
            padding: 6px 14px;
            background: rgba(16, 185, 129, 0.1);
            color: #10b981;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.5px;
            border: 1px solid rgba(16, 185, 129, 0.2);
        }

        .timezone-pills {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .timezone-pill {
            padding: 6px 14px;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 500;
            color: #888;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .timezone-pill:hover {
            background: #1f1f1f;
            border-color: #333;
            color: #ccc;
        }

        .timezone-pill.active {
            background: rgba(16, 185, 129, 0.1);
            border-color: rgba(16, 185, 129, 0.3);
            color: #10b981;
        }

        /* Quick Stats Styles */
        .stats-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 24px;
            color: #fff;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 0;
            border-bottom: 1px solid #1a1a1a;
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-size: 14px;
            color: #888;
            font-weight: 500;
        }

        .stat-value {
            font-size: 18px;
            font-weight: 600;
        }

        .stat-value.positive {
            color: #10b981;
            text-shadow: 0 0 10px rgba(16, 185, 129, 0.3);
        }

        .stat-value.negative {
            color: #ef4444;
            text-shadow: 0 0 10px rgba(239, 68, 68, 0.3);
        }

        .stat-value.neutral {
            color: #888;
        }

        /* Alert Badge */
        .alert-badge {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 8px;
            border: 1px solid rgba(239, 68, 68, 0.2);
        }

        /* Sentiment Drivers */
        .drivers-section {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .section-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
            color: #e0e0e0;
        }

        .drivers-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            flex: 1;
        }

        .drivers-grid-single {
            display: flex;
            flex-direction: column;
            gap: 12px;
            flex: 1;
        }

        .driver-item {
            background: rgba(255, 255, 255, 0.02);
            padding: 14px 18px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(10px);
            flex-direction: column;
            justify-content: space-between;
        }

        .driver-item:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .driver-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        /* Driver Eye Icons - styles handled by .eye-icon-btn above */

        .driver-name {
            cursor: pointer;
            user-select: none;
        }

        /* Hide checkboxes for drivers without historical data */
        #checkbox-social,
        #checkbox-recommendations,
        #checkbox-vix {
            display: none;
        }

        .driver-name {
            font-size: 14px;
            font-weight: 500;
            color: #ccc;
        }

        .driver-value {
            font-size: 16px;
            font-weight: 700;
        }

        .driver-value.positive {
            color: #10b981;
        }

        .driver-value.negative {
            color: #ef4444;
        }

        .progress-bar {
            height: 8px;
            background: rgba(15, 15, 15, 0.8);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .progress-fill {
            height: 100%;
            border-radius: 8px;
            transition: width 1s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .progress-fill.positive {
            background: linear-gradient(90deg, #10b981 0%, #34d399 50%, #10b981 100%);
            background-size: 200% 100%;
            box-shadow: 0 0 12px rgba(16, 185, 129, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.2);
            animation: gradient-flow 3s ease infinite;
        }

        @keyframes gradient-flow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .progress-fill.negative {
            background: linear-gradient(90deg, #ef4444 0%, #f87171 50%, #ef4444 100%);
            background-size: 200% 100%;
            box-shadow: 0 0 12px rgba(239, 68, 68, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.2);
            animation: gradient-flow 3s ease infinite;
        }

        .progress-fill.neutral {
            background: linear-gradient(90deg, #888 0%, #aaa 50%, #888 100%);
            background-size: 200% 100%;
            box-shadow: 0 0 12px rgba(136, 136, 136, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        /* Chart Section */
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            flex-wrap: nowrap;
            gap: 16px;
        }

        .chart-title {
            font-size: 16px;
            font-weight: 600;
            color: #e0e0e0;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .chart-type-toggle {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 4px 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #e0e0e0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .chart-type-toggle::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .chart-type-toggle:hover::before {
            left: 100%;
        }
        
        .chart-type-toggle svg {
            width: 12px;
            height: 12px;
            transition: transform 0.3s ease;
        }

        .chart-type-toggle:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.1) 100%);
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        /* Granular data toggle (Second/Tick) */
        .granular-toggle {
            display: flex;
            gap: 4px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 4px;
            padding: 2px;
        }

        .granular-btn {
            padding: 2px 8px;
            background: transparent;
            border: none;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
            color: #888;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .granular-btn:hover {
            color: #ccc;
            background: rgba(255, 255, 255, 0.08);
        }

        .granular-btn.active {
            background: rgba(255, 140, 66, 0.15);
            color: #ff8c42;
        }

        /* Nasdaq price toggle as checkbox */
        .price-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            color: #fff;
            font-size: 12px;
            user-select: none;
        }

        .price-toggle input[type="checkbox"] {
            width: 10px;
            height: 10px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            border: 1px solid #666;
            border-radius: 3px;
            background-color: #999;
            position: relative;
        }

        .price-toggle input[type="checkbox"]:checked {
            background-color: #ffffff;
            border-color: #ffffff;
        }

        .price-toggle input[type="checkbox"]:checked::after {
            content: 'âœ“';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #000;
            font-size: 10px;
            font-weight: bold;
        }

        .chart-controls {
            display: flex;
            gap: 6px;
            align-items: center;
            flex-shrink: 1;
            min-width: 0;
        }

        .timeframe-selector {
            display: flex;
            gap: 8px;
        }

        .timeframe-btn {
            padding: 6px 12px;
            background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #888;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: inherit;
            position: relative;
            overflow: hidden;
        }

        .timeframe-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .timeframe-btn:hover::before {
            left: 100%;
        }

        .timeframe-btn:hover {
            background: linear-gradient(135deg, #2a2a2a 0%, #333333 100%);
            border-color: rgba(255, 255, 255, 0.2);
            color: #fff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .timeframe-btn.active {
            background: linear-gradient(135deg, rgba(255, 140, 66, 0.2) 0%, rgba(255, 140, 66, 0.1) 100%);
            color: #ff8c42;
            border: 1px solid rgba(255, 140, 66, 0.4);
            box-shadow: 0 0 12px rgba(255, 140, 66, 0.3);
        }

        .timeframe-btn.active:hover {
            box-shadow: 0 0 16px rgba(255, 140, 66, 0.5);
        }

        .timezone-select {
            background: #1a1a1a;
            color: #ccc;
            border: 1px solid #2a2a2a;
            padding: 6px 32px 6px 12px;
            border-radius: 10px;
            font-size: 12px;
            font-family: inherit;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1.5L6 6.5L11 1.5' stroke='%23888888' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
        }

        .timezone-select:hover {
            background-color: #1f1f1f;
            border-color: #333;
        }

        .timezone-select:focus {
            outline: none;
            border-color: #ff8c42;
        }

        .chart-container {
            flex: 1;
            position: relative;
            background: #0f0f0f;
            border-radius: 12px;
            padding: 12px 0px 0px 0px;
            min-height: 70px;
            overflow: hidden;
        }

        .chart-side-panel {
            background: #000000;
            border: 1px solid #ffffff;
            position: absolute;
            top: 20px;
            right: 40px;
            bottom: 20px;
            width: 25px;
            pointer-events: none;
        }

        .chart-side-panel-second {
            background: #000000;
            border: 1px solid #ffffff;
            position: absolute;
            top: 20px;
            right: 10px;
            bottom: 20px;
            width: 25px;
            pointer-events: none;
        }

        .market-status-indicator {
            position: absolute;
            bottom: 16px;
            left: 16px;
            font-size: 10px;
            color: #888;
            background: rgba(0, 0, 0, 0.5);
            padding: 4px 8px;
            border-radius: 4px;
            z-index: 100;
        }

        .market-status-indicator span {
            color: #aaa;
            font-weight: 500;
        }

        .charts-wrapper {
            position: relative;
        }
        

        .chart-canvas {
            position: absolute;
            top: 0;
            left: 20px;
            right: 10%;
            bottom: 0;
            width: calc(90% - 20px);
            height: 100%;
            cursor: crosshair;
        }

        .unified-hover-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 1px;
            background: transparent;
            border-left: 2px dashed rgba(255, 140, 66, 0.5);
            pointer-events: none;
            display: none;
            z-index: 10;
        }

        .chart-time-label {
            position: absolute;
            bottom: 150px;
            left: 0;
            background: #ff8c42;
            color: #000;
            padding: 2px 6px;
            border-radius: 2px;
            font-size: 9px;
            font-weight: bold;
            font-family: monospace;
            white-space: nowrap;
            pointer-events: none;
            z-index: 9999;
            display: none;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
        }
        
        .chart-time-label.show {
            display: block;
        }

        .chart-tooltip {
            position: absolute;
            background: rgba(26, 26, 26, 0.15);
            backdrop-filter: blur(0.8px);
            -webkit-backdrop-filter: blur(0.8px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 2px 5px;
            color: white;
            font-size: 9px;
            font-weight: 500;
            pointer-events: none;
            display: none;
            white-space: nowrap;
            z-index: 100;
            box-shadow: none;
        }

        .chart-tooltip .tooltip-label {
            color: #888;
            font-size: 7px;
            margin-bottom: 1px;
        }

        .chart-tooltip .tooltip-value {
            color: #ffffff;
            font-size: 10px;
            font-weight: 600;
            margin-bottom: 1px;
        }

        .chart-tooltip .tooltip-time {
            color: #999;
            font-size: 7px;
        }
        
        #chart-tooltip .tooltip-time {
            display: none;
        }

        .chart-tooltip .tooltip-sentiment {
            color: #ff8c42;
            font-size: 10px;
            font-weight: 500;
            margin-top: 2px;
        }

        .y-axis {
            position: absolute;
            left: 0;
            top: 20px;
            bottom: 20px;
            width: 40px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            font-size: 11px;
            color: #fff;
            padding-right: 10px;
        }

        .y-axis-label {
            text-align: right;
        }

        .chart-line {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            pointer-events: none;
        }

        .chart-line svg {
            width: 100%;
            height: 100%;
        }

        .chart-path {
            fill: none;
            stroke: url(#lineGradient);
            stroke-width: 3;
            stroke-linecap: round;
            stroke-linejoin: round;
            filter: drop-shadow(0 0 15px rgba(255, 140, 66, 0.6));
            opacity: 1;
        }

        .zero-line {
            position: absolute;
            left: 50px;
            right: 20px;
            top: 50%;
            height: 1px;
            background: rgba(136, 136, 136, 0.3);
            border-top: 1px dashed rgba(136, 136, 136, 0.3);
            pointer-events: none;
        }

        .market-gap-line {
            position: absolute;
            top: 0;
            bottom: 20px;
            width: 2px;
            background: none;
            border-left: 2px dashed rgba(255, 193, 7, 0.4);
            pointer-events: none;
            z-index: 5;
        }

        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 140, 66, 0.6);
            }
            50% {
                box-shadow: 0 0 30px rgba(255, 140, 66, 0.8);
            }
        }

        .x-axis {
            position: absolute;
            left: 20px;
            right: 10%;
            bottom: 0;
            height: 20px;
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #fff;
        }

        .chart-oscillator-container {
            position: relative;
            height: 115px;
            margin-top: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
            background: #000000;
        }

        .chart-oscillator {
            position: absolute;
            top: 0;
            left: 20px;
            right: 10%;
            bottom: 50px;
            width: calc(90% - 20px);
            height: calc(100% - 50px);
            cursor: crosshair;
        }

        .oscillator-expand-btn {
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            width: 24px;
            height: 24px;
            background: rgba(26, 26, 26, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }

        .chart-oscillator-container:hover .oscillator-expand-btn {
            opacity: 1;
        }

        .oscillator-expand-btn:hover {
            background: rgba(26, 26, 26, 0.95);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .oscillator-expand-btn svg {
            stroke: #888;
            transition: stroke 0.2s ease;
        }

        .oscillator-expand-btn:hover svg {
            stroke: #fff;
        }

        .oscillator-expand-btn .expand-icon,
        .oscillator-expand-btn .collapse-icon {
            width: 14px;
            height: 14px;
            margin: 0 auto;
            display: block;
        }

        .oscillator-x-axis {
            position: absolute;
            left: 20px;
            right: 10%;
            bottom: -25px;
            height: 20px;
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #fff;
            z-index: 15;
        }

        /* Oscillator Y-axis */
        .oscillator-y-axis {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 20px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 8px 2px;
            z-index: 10;
        }

        .oscillator-y-axis span {
            font-size: 9.5px;
            color: #888;
            text-align: right;
            line-height: 1;
        }

        /* Oscillator Sentiment Score Panel */
        .oscillator-score-panel {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 10%;
            background: #1a1a1a;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
            border-left: 1px solid #333;
            z-index: 5;
        }

        .oscillator-score-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
        }

        .oscillator-score-value {
            font-size: 24px;
            font-weight: 600;
            color: #ff8c42;
            line-height: 1;
        }

        .oscillator-score-label {
            font-size: 8px;
            font-weight: 500;
            color: #666;
            margin-top: 2px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Eye Icon Button Styles */
        .eye-icon-btn {
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            margin-bottom: 4px;
        }

        .eye-icon-btn:hover {
            opacity: 0.7;
        }

        .eye-icon {
            width: 12.8px;
            height: 12.8px;
            stroke: #888;
            transition: stroke 0.2s ease;
        }

        .eye-icon-btn.active .eye-icon {
            stroke: #ff8c42;
        }

        .eye-icon-btn.driver-eye.active .eye-icon {
            stroke: #ec4899;
        }

        #eye-news.active .eye-icon {
            stroke: #ec4899;
        }

        #eye-indicators.active .eye-icon {
            stroke: #3b82f6;
        }

        #eye-summary.active .eye-icon {
            stroke: #ff8c42;
        }

        /* Oscillator Scale Selector in Score Panel */
        .oscillator-scale-selector-container {
            display: none;
            flex-direction: column;
            gap: 3px;
            align-items: center;
        }

        .oscillator-scale-selector-container.visible {
            display: flex;
        }

        #scale-fixed:checked + label,
        #scale-visible:checked + label,
        #scale-full:checked + label,
        #scale-signal:checked + label,
        #scale-news:checked + label,
        #scale-weighted:checked + label,
        #scale-news-composite:checked + label,
        #scale-news-price:checked + label,
        #scale-candle-decay:checked + label {
            background: rgba(255, 140, 66, 0.2) !important;
            border-color: #ff8c42 !important;
            color: #ff8c42 !important;
        }

        .oscillator-score-panel label:hover {
            background: rgba(255, 140, 66, 0.1) !important;
            border-color: #666 !important;
        }

        /* Candle-Decay Quick Button (9th View) */
        .candle-decay-quick-btn {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #444;
            border-radius: 2px;
            padding: 4px;
            cursor: pointer;
            color: #888;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            margin-top: 8px;
        }

        .candle-decay-quick-btn:hover {
            background: rgba(255, 140, 66, 0.1) !important;
            border-color: #666 !important;
        }

        .candle-decay-quick-btn.active {
            background: rgba(168, 85, 247, 0.2) !important;
            border-color: #a855f7 !important;
            color: #a855f7 !important;
        }

        .chart-scrollbar-container {
            position: relative;
            margin-top: 5px;
            margin-bottom: 0;
            height: 16px;
            display: flex;
            align-items: center;
            width: 100%;
        }

        .chart-scrollbar {
            width: 100%;
            height: 3px;
            -webkit-appearance: none;
            appearance: none;
            background: #333;
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

        .chart-scrollbar::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 40px;
            height: 15px;
            background: #999;
            border-radius: 7.5px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .chart-scrollbar::-webkit-slider-thumb:hover {
            background: #fff;
        }

        .chart-scrollbar::-moz-range-thumb {
            width: 40px;
            height: 15px;
            background: #999;
            border-radius: 7.5px;
            cursor: pointer;
            border: none;
            transition: background 0.15s;
        }

        .chart-scrollbar::-moz-range-thumb:hover {
            background: #fff;
        }

        .chart-legend {
            position: absolute;
            left: 50px;
            right: 20px;
            bottom: 0;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            font-size: 11px;
            color: #fff;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-color {
            width: 12px;
            height: 2px;
            border-radius: 1px;
        }

        .legend-color.orange {
            background-color: #ff8c42;
        }

        .legend-color.white {
            background-color: #ffffff;
        }

        /* News Feed */
        .news-feed {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .news-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .news-title {
            font-size: 18px;
            font-weight: 600;
            color: #e0e0e0;
        }

        .news-filter {
            display: flex;
            gap: 8px;
        }

        .filter-btn {
            padding: 6px 14px;
            background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #888;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .filter-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .filter-btn:hover::before {
            left: 100%;
        }

        .filter-btn:hover {
            background: linear-gradient(135deg, #2a2a2a 0%, #333333 100%);
            border-color: rgba(255, 255, 255, 0.2);
            color: #fff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .filter-btn.active {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.2) 0%, rgba(16, 185, 129, 0.1) 100%);
            color: #10b981;
            border-color: rgba(16, 185, 129, 0.4);
            box-shadow: 0 0 12px rgba(16, 185, 129, 0.3);
        }

        .filter-btn.active:hover {
            box-shadow: 0 0 16px rgba(16, 185, 129, 0.5);
        }

        .news-items {
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
            flex: 1;
        }

        .news-item-link {
            text-decoration: none;
            color: inherit;
            display: block;
        }

        .news-item {
            background: #0f0f0f;
            padding: 16px;
            border-radius: 12px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .news-item:hover {
            background: #1a1a1a;
        }

        .news-item-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
        }

        .news-source {
            font-size: 11px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .sentiment-tag {
            padding: 3px 10px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .sentiment-tag.positive {
            background: rgba(16, 185, 129, 0.15);
            color: #10b981;
            border: 1px solid rgba(16, 185, 129, 0.2);
        }

        .sentiment-tag.negative {
            background: rgba(239, 68, 68, 0.15);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.2);
        }

        .sentiment-tag.neutral {
            background: rgba(136, 136, 136, 0.15);
            color: #888;
            border: 1px solid rgba(136, 136, 136, 0.2);
        }

        .news-headline {
            font-size: 14px;
            font-weight: 500;
            color: #fff;
            line-height: 1.4;
            margin-bottom: 6px;
        }

        .news-description {
            font-size: 12px;
            color: #888;
            line-height: 1.5;
            margin-bottom: 8px;
        }

        .news-time {
            font-size: 11px;
            color: #666;
        }


        /* Onboarding Modal */
        .onboarding-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .onboarding-modal-overlay.show {
            display: flex;
            opacity: 1;
        }

        .onboarding-modal {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 16px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 0;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            position: relative;
        }

        .onboarding-modal-content {
            padding: 40px 48px;
        }

        .onboarding-step {
            display: none;
        }

        .onboarding-step.active {
            display: block;
        }

        .onboarding-title {
            font-size: 28px;
            font-weight: 700;
            color: #fff;
            margin-bottom: 24px;
            text-align: center;
        }

        .onboarding-subtitle {
            font-size: 16px;
            color: #888;
            margin-bottom: 32px;
            text-align: center;
            line-height: 1.6;
        }

        .language-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 32px;
        }

        .language-option {
            background: #282828;
            border: 2px solid #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .language-option:hover {
            background: #2a2a2a;
            border-color: #ffffff;
        }

        .language-option.selected {
            background: rgba(255, 255, 255, 0.06);
            border-color: #ffffff;
        }

        .language-name {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 4px;
        }

        .language-code {
            font-size: 12px;
            color: #888;
        }

        .disclaimer-content {
            background: #0f0f0f;
            border-left: 4px solid #2a2a2a;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 32px;
        }

        .disclaimer-section {
            margin-bottom: 24px;
        }

        .disclaimer-section:last-child {
            margin-bottom: 0;
        }

        .disclaimer-heading {
            font-size: 18px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .disclaimer-text {
            font-size: 14px;
            color: #ccc;
            line-height: 1.8;
        }

        .disclaimer-text p {
            margin-bottom: 12px;
        }

        .disclaimer-text p:last-child {
            margin-bottom: 0;
        }

        .disclaimer-checkbox-container {
            margin-top: 24px;
            padding-top: 24px;
            border-top: 1px solid #2a2a2a;
        }

        .disclaimer-checkbox-label {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            cursor: pointer;
            font-size: 14px;
            color: #ccc;
            line-height: 1.6;
        }

        .disclaimer-checkbox {
            width: 20px;
            height: 20px;
            margin-top: 2px;
            cursor: pointer;
            flex-shrink: 0;
        }
        
        .disclaimer-checkbox:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .disclaimer-checkbox-label:has(.disclaimer-checkbox:disabled) {
            cursor: not-allowed;
            opacity: 0.7;
        }

        .onboarding-button {
            width: 100%;
            padding: 14px 32px;
            background: #ffffff;
            color: #000000;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        .onboarding-button:hover {
            background: #e0e0e0;
        }

        .onboarding-button:disabled {
            background: #2a2a2a;
            color: #666;
            cursor: not-allowed;
            transform: none;
        }

        .onboarding-button:disabled:hover {
            background: #2a2a2a;
        }

        .onboarding-progress {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-bottom: 32px;
        }

        .progress-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #2a2a2a;
            transition: all 0.2s ease;
        }

        .progress-dot.active {
            background: #ffffff;
            width: 24px;
            border-radius: 4px;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            body {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr;
            }

            .header {
                grid-column: 1;
                grid-row: 2;
            }

            .sidebar {
                grid-column: 1;
                grid-row: 1;
                padding: 20px;
            }

            .main-wrapper {
                grid-column: 1;
                grid-row: 3;
            }

            .container {
                grid-template-columns: 1fr;
                height: auto;
            }

            .drivers-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .onboarding-modal-content {
                padding: 32px 24px;
            }

            .onboarding-title {
                font-size: 24px;
            }

            .language-options {
                grid-template-columns: 1fr;
            }
        }

        /* Legal Disclaimer Modal - Shows on every page load */
        .disclaimer-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.50);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            z-index: 99999;
            display: none;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .disclaimer-modal-overlay.show {
            display: flex !important;
            opacity: 1 !important;
        }

        .disclaimer-modal {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 16px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 0;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9);
            position: relative;
        }

        .disclaimer-modal-content {
            padding: 40px 48px;
        }

        .disclaimer-modal-title {
            font-size: 28px;
            font-weight: 700;
            color: #fff;
            margin-bottom: 16px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        .disclaimer-modal-title img {
            width: 32px;
            height: 32px;
        }

        /* Level 1: Enter Button Screen */
        .disclaimer-modal-level-1 {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 400px;
            padding: 48px;
        }

        .disclaimer-modal-level-1 .disclaimer-modal-content {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 48px;
        }

        .disclaimer-enter-button {
            width: 100%;
            min-height: 200px;
            padding: 48px;
            background: #ffffff;
            color: #000000;
            border: none;
            border-radius: 24px;
            font-size: 48px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
            text-transform: uppercase;
            letter-spacing: 4px;
            box-shadow: 0 8px 32px rgba(255, 255, 255, 0.2);
        }

        .disclaimer-enter-button:hover {
            background: #e0e0e0;
            box-shadow: 0 12px 48px rgba(255, 255, 255, 0.3);
        }

        .disclaimer-enter-button:disabled {
            background: #2a2a2a;
            color: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .disclaimer-enter-button:disabled:hover {
            background: #2a2a2a;
            transform: none;
        }

        /* Level 2: Disclaimer Content */
        .disclaimer-modal-level-2 {
            display: none;
        }

        .disclaimer-modal-button {
            width: 100%;
            padding: 14px 32px;
            background: #ffffff;
            color: #000000;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        .disclaimer-modal-button:hover {
            background: #e0e0e0;
        }

        .disclaimer-modal-button:disabled {
            background: #2a2a2a;
            color: #666;
            cursor: not-allowed;
            transform: none;
        }

        .disclaimer-modal-button:disabled:hover {
            background: #2a2a2a;
        }

        @media (max-width: 768px) {
            .disclaimer-modal-content {
                padding: 32px 24px;
            }

            .disclaimer-modal-title {
                font-size: 24px;
            }

            .disclaimer-modal-level-1 {
                min-height: 300px;
                padding: 32px;
            }

            .disclaimer-modal-level-1 .disclaimer-modal-content {
                gap: 32px;
            }

            .disclaimer-enter-button {
                min-height: 150px;
                padding: 32px;
                font-size: 36px;
                letter-spacing: 3px;
            }
        }
    </style>
    <!-- Disclaimer Modal Script -->
    <script src="js/disclaimer-modal.js"></script>
</head>
<body>
    <!-- Legal Disclaimer Modal - Shows on every page load -->
    <div class="disclaimer-modal-overlay" id="disclaimer-modal-overlay">
        <div class="disclaimer-modal">
            <!-- Level 1: Title and Enter Button -->
            <div class="disclaimer-modal-level-1" id="disclaimer-level-1">
                <div class="disclaimer-modal-content">
                    <h2 class="disclaimer-modal-title">
                        <img src="favicon.ico" alt="Sentiment Tracker">
                        <span>Sentiment Tracker</span>
                    </h2>
                    <button id="disclaimer-enter-button" class="disclaimer-enter-button">ENTER</button>
                </div>
            </div>

            <!-- Level 2: Disclaimer Content (hidden initially) -->
            <div class="disclaimer-modal-level-2" id="disclaimer-level-2" style="display: none;">
                <div class="disclaimer-modal-content">
                    <div class="disclaimer-content">
                        <div class="disclaimer-section">
                            <h3 class="disclaimer-heading">
                                <span>âš ï¸</span>
                                <span data-i18n="onboarding.disclaimer.heading">Risk Warning</span>
                            </h3>
                            <div class="disclaimer-text">
                                <p data-i18n="onboarding.disclaimer.text">Trading Futures, Forex, CFDs and Stocks involves a risk of loss. Please consider carefully if such trading is appropriate for you. Past performance is not indicative of future results. Any and all signals or educational advice provided by PhoenixBinary and/or Phoenix Algo, LLC and/or any indicators provided by aforementioned are for educational purposes only and do not constitute investment recommendations or advice.</p>
                            </div>
                        </div>
                        <div class="disclaimer-checkbox-container">
                            <label class="disclaimer-checkbox-label">
                                <input type="checkbox" id="disclaimer-modal-checkbox" class="disclaimer-checkbox">
                                <span data-i18n="onboarding.disclaimer.checkbox">I understand and acknowledge the risks associated with trading</span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Onboarding Modal -->
    <div class="onboarding-modal-overlay" id="onboarding-modal-overlay">
        <div class="onboarding-modal">
            <div class="onboarding-modal-content">
                <!-- Progress Indicator -->
                <div class="onboarding-progress">
                    <div class="progress-dot active" id="progress-dot-1"></div>
                    <div class="progress-dot" id="progress-dot-2"></div>
                </div>

                <!-- Step 1: Language Selection -->
                <div class="onboarding-step active" id="step-language">
                    <h2 class="onboarding-title" data-i18n="onboarding.title.language">Select Your Language</h2>
                    <p class="onboarding-subtitle" data-i18n="onboarding.subtitle.language">Choose your preferred language for the dashboard</p>
                    <div class="language-options">
                        <div class="language-option" data-lang="en">
                            <div class="language-name">English</div>
                            <div class="language-code">EN</div>
                        </div>
                        <div class="language-option" data-lang="es">
                            <div class="language-name">EspaÃ±ol</div>
                            <div class="language-code">ES</div>
                        </div>
                        <div class="language-option" data-lang="fr">
                            <div class="language-name">FranÃ§ais</div>
                            <div class="language-code">FR</div>
                        </div>
                        <div class="language-option" data-lang="de">
                            <div class="language-name">Deutsch</div>
                            <div class="language-code">DE</div>
                        </div>
                        <div class="language-option" data-lang="zh">
                            <div class="language-name">ä¸­æ–‡</div>
                            <div class="language-code">ZH</div>
                        </div>
                        <div class="language-option" data-lang="ja">
                            <div class="language-name">æ—¥æœ¬èªž</div>
                            <div class="language-code">JA</div>
                        </div>
                    </div>
                    <button class="onboarding-button" id="language-continue-btn" data-i18n="onboarding.button.continue" disabled>Continue</button>
                </div>

                <!-- Step 2: Disclaimer -->
                <div class="onboarding-step" id="step-disclaimer">
                    <h2 class="onboarding-title" data-i18n="onboarding.title.disclaimer">Important Disclaimer</h2>
                    <div class="disclaimer-content">
                        <div class="disclaimer-section">
                            <h3 class="disclaimer-heading">
                                <span>âš ï¸</span>
                                <span data-i18n="onboarding.disclaimer.heading">Risk Warning</span>
                            </h3>
                            <div class="disclaimer-text">
                                <p data-i18n="onboarding.disclaimer.text">Trading Futures, Forex, CFDs and Stocks involves a risk of loss. Please consider carefully if such trading is appropriate for you. Past performance is not indicative of future results. Any and all signals or educational advice provided by PhoenixBinary and/or Phoenix Algo, LLC and/or any indicators provided by aforementioned are for educational purposes only and do not constitute investment recommendations or advice.</p>
                            </div>
                        </div>
                        <div class="disclaimer-checkbox-container">
                            <label class="disclaimer-checkbox-label">
                                <input type="checkbox" id="disclaimer-checkbox" class="disclaimer-checkbox">
                                <span data-i18n="onboarding.disclaimer.checkbox">I understand and acknowledge the risks associated with trading</span>
                            </label>
                        </div>
                    </div>
                    <button class="onboarding-button" id="disclaimer-continue-btn" data-i18n="onboarding.button.continue" disabled>Continue</button>
                </div>
            </div>
        </div>
    </div>
    <div class="main-wrapper">
    <div class="container">
            <!-- Left Column Wrapper -->
            <div class="left-column-wrapper">
                <!-- Left Top: Title -->
                <div class="card left-top">
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; gap: 16px;">
                        <div style="text-align: left;">
                            <div style="font-size: 40px; font-weight: 700; color: #fff; line-height: 0.9; margin-bottom: 4px;">Sentiment</div>
                            <div style="font-size: 40px; font-weight: 700; color: #fff; line-height: 0.9;">Tracker</div>
                        </div>
                        <div style="width: 85px; height: 85px; background: #1a1a1a; border-radius: 12px; display: flex; align-items: center; justify-content: center; color: #666; font-size: 12px; border: 2px dashed #333;">
                            Logo
                        </div>
                    </div>
                </div>

                <!-- Left Bottom: Sentiment Drivers -->
                <div class="card left-bottom">
                    <h2 class="section-title" data-i18n="dashboard.drivers.title">Sentiment Drivers</h2>
                    <div class="drivers-grid-single">
                        <div class="driver-item">
                            <div class="driver-header">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <button type="button" class="eye-icon-btn driver-eye active" data-line="summary" id="eye-summary" title="Toggle composite score line">
                                        <svg class="eye-icon eye-closed" width="12.8" height="12.8" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
                                            <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
                                            <line x1="1" y1="1" x2="23" y2="23"></line>
                                        </svg>
                                        <svg class="eye-icon eye-open" width="12.8" height="12.8" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                            <circle cx="12" cy="12" r="3"></circle>
                                        </svg>
                                    </button>
                                    <span class="driver-name">Summary</span>
                                </div>
                                <span class="driver-value positive">+0.0</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill positive" style="width: 50%"></div>
                            </div>
                        </div>

                        <div class="driver-item">
                            <div class="driver-header">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <button type="button" class="eye-icon-btn driver-eye" data-line="news" id="eye-news" title="Toggle news sentiment line">
                                        <svg class="eye-icon eye-closed" width="12.8" height="12.8" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
                                            <line x1="1" y1="1" x2="23" y2="23"></line>
                                        </svg>
                                        <svg class="eye-icon eye-open" width="12.8" height="12.8" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
                                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                            <circle cx="12" cy="12" r="3"></circle>
                                        </svg>
                                    </button>
                                    <span class="driver-name" data-i18n="dashboard.driver.news">News</span>
                                </div>
                                <span class="driver-value negative">-1.2</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill negative" style="width: 30%"></div>
                            </div>
                        </div>

                        <div class="driver-item">
                            <div class="driver-header">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <button type="button" class="eye-icon-btn driver-eye" data-line="indicators" id="eye-indicators" title="Toggle technical indicators line">
                                        <svg class="eye-icon eye-closed" width="12.8" height="12.8" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
                                            <line x1="1" y1="1" x2="23" y2="23"></line>
                                        </svg>
                                        <svg class="eye-icon eye-open" width="12.8" height="12.8" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
                                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                            <circle cx="12" cy="12" r="3"></circle>
                                        </svg>
                                    </button>
                                    <span class="driver-name" data-i18n="dashboard.driver.indicators">Indicators</span>
                                </div>
                                <span class="driver-value positive">+0.1</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill positive" style="width: 55%"></div>
                            </div>
                        </div>

                        <div class="driver-item">
                            <div class="driver-header">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <input type="checkbox" class="driver-checkbox" data-driver="social" id="checkbox-social">
                                    <label for="checkbox-social" class="driver-name" data-i18n="dashboard.driver.social">Social Media</label>
                                </div>
                                <span class="driver-value positive">+0.5</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill positive" style="width: 65%"></div>
                            </div>
                        </div>

                        <!-- New Driver 1 -->
                        <div class="driver-item">
                            <div class="driver-header">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <input type="checkbox" class="driver-checkbox" data-driver="recommendations" id="checkbox-recommendations">
                                    <label for="checkbox-recommendations" class="driver-name" data-i18n="dashboard.driver.recommendations">Recommendations</label>
                                </div>
                                <span class="driver-value positive">+0.3</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill positive" style="width: 60%"></div>
                            </div>
                        </div>

                        <!-- VIX Driver -->
                        <div class="driver-item">
                            <div class="driver-header">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <input type="checkbox" class="driver-checkbox" data-driver="vix" id="checkbox-vix">
                                    <label for="checkbox-vix" class="driver-name" data-i18n="dashboard.driver.vix">VIX</label>
                                </div>
                                <span class="driver-value neutral">0.0</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill neutral" style="width: 50%"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Top: Navigation & Time -->
            <div class="right-top">
                <div class="right-top-item">
                    <a href="about.html" class="nav-link" data-i18n="nav.about">About Us</a>
                </div>
                <div class="right-top-item">
                    <div class="indices-selector" id="indices-selector">
                        <span class="indices-label" data-i18n="nav.indices">Indices</span>
                        <span class="indices-chevron">â–¼</span>
                        <div class="indices-dropdown" id="indices-dropdown">
                            <div class="indices-option active" data-index="nasdaq">Nasdaq</div>
                        </div>
                    </div>
                </div>
                <div class="right-top-item">
                    <a href="news.html" class="nav-link" data-i18n="nav.news">News</a>
                </div>
                <div class="right-top-item">
                    <a href="#" class="nav-link" data-i18n="nav.trading">Trading</a>
                </div>
                <div class="right-top-item">
                    <a href="#" class="nav-link" id="language-selector" data-i18n="nav.language">Language</a>
                </div>
                <div class="right-top-item">
                    <a href="#" class="nav-link" id="logout-link" data-i18n="nav.logout">Logout</a>
                </div>
                <div class="right-top-item">
                    <div class="time-display" id="timezone-selector" style="position: relative;">
                        <span class="current-time" id="current-time">09:45:32</span>
                        <span class="timezone-chevron">â–¼</span>
                        <div class="timezone-dropdown" id="timezone-dropdown">
                            <!-- Timezone options will be populated dynamically -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Bottom Row: News Feed -->
            <!-- <div class="card bottom-row">
                <div class="news-feed">
                    <div class="news-header">
                        <div class="news-title">Live News Feed</div>
                        <div class="news-filter">
                            <button class="filter-btn active">All</button>
                            <button class="filter-btn">Positive</button>
                            <button class="filter-btn">Negative</button>
                            <button class="filter-btn">Breaking</button>
                        </div>
                    </div>
                    <div class="news-items">
                        <a href="https://www.bloomberg.com/markets" target="_blank" class="news-item-link">
                            <div class="news-item">
                                <div class="news-item-header">
                                    <span class="news-source">Bloomberg</span>
                                    <span class="sentiment-tag positive">POSITIVE</span>
                                </div>
                                <div class="news-headline">Tech stocks rally as inflation data comes in lower than expected</div>
                                <div class="news-time">2 minutes ago</div>
                            </div>
                        </a>
                        <a href="https://www.reuters.com/markets" target="_blank" class="news-item-link">
                            <div class="news-item">
                                <div class="news-item-header">
                                    <span class="news-source">Reuters</span>
                                    <span class="sentiment-tag positive">POSITIVE</span>
                                </div>
                                <div class="news-headline">NASDAQ futures surge on strong earnings reports from major tech companies</div>
                                <div class="news-time">8 minutes ago</div>
                            </div>
                        </a>
                        <a href="https://www.cnbc.com/markets" target="_blank" class="news-item-link">
                            <div class="news-item">
                                <div class="news-item-header">
                                    <span class="news-source">CNBC</span>
                                    <span class="sentiment-tag negative">NEGATIVE</span>
                                </div>
                                <div class="news-headline">Fed officials signal potential rate hike in upcoming meeting</div>
                                <div class="news-time">15 minutes ago</div>
                            </div>
                        </a>
                        <a href="https://www.wsj.com/markets" target="_blank" class="news-item-link">
                            <div class="news-item">
                                <div class="news-item-header">
                                    <span class="news-source">WSJ</span>
                                    <span class="sentiment-tag neutral">NEUTRAL</span>
                                </div>
                                <div class="news-headline">Market analysts discuss mixed signals from recent economic indicators</div>
                                <div class="news-time">22 minutes ago</div>
                            </div>
                        </a>
                        <a href="https://www.ft.com/markets" target="_blank" class="news-item-link">
                            <div class="news-item">
                                <div class="news-item-header">
                                    <span class="news-source">Financial Times</span>
                                    <span class="sentiment-tag positive">POSITIVE</span>
                                </div>
                                <div class="news-headline">Strong consumer spending data boosts market confidence heading into Q4</div>
                                <div class="news-time">35 minutes ago</div>
                            </div>
                        </a>
                    </div>
                </div>
            </div> -->

            <!-- Bottom Row: Historical Sentiment Trend -->
            <div class="card bottom-row" style="position: relative;">
                <div class="chart-header">
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <span class="chart-title" data-i18n="dashboard.chart.title">NASDAQ</span>
                        <button id="chart-type-toggle" class="chart-type-toggle" title="Toggle chart type">
                            <svg id="line-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>
                            </svg>
                            <svg id="candle-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display: none;">
                                <line x1="12" y1="2" x2="12" y2="6"></line>
                                <rect x="8" y="6" width="8" height="12" fill="currentColor"></rect>
                                <line x1="12" y1="18" x2="12" y2="22"></line>
                            </svg>
                        </button>
                        
                        <!-- Granular Data Toggle (Second/Tick) - Only visible for â‰¤1h timeframes -->
                        <div id="granular-toggle" class="granular-toggle" style="display: none;">
                            <button class="granular-btn active" data-type="second" title="1-Second Candles">Second</button>
                            <button class="granular-btn" data-type="tick" title="100-Tick Candles">Tick</button>
                        </div>
                    </div>
                    <div class="chart-controls">
                        <div class="timeframe-selector">
                            <button class="timeframe-btn active" data-timeframe="6h" data-i18n="dashboard.chart.timeframe.6h">Session</button>
                            <button class="timeframe-btn" data-timeframe="1m" data-i18n="dashboard.chart.timeframe.1m">1m</button>
                            <button class="timeframe-btn" data-timeframe="5m" data-i18n="dashboard.chart.timeframe.5m">5m</button>
                            <button class="timeframe-btn" data-timeframe="15m" data-i18n="dashboard.chart.timeframe.15m">15m</button>
                            <button class="timeframe-btn" data-timeframe="30m" data-i18n="dashboard.chart.timeframe.30m">30m</button>
                            <button class="timeframe-btn" data-timeframe="1h" data-i18n="dashboard.chart.timeframe.1h">1h</button>
                            <button class="timeframe-btn" data-timeframe="2h" data-i18n="dashboard.chart.timeframe.2h">2h</button>
                            <button class="timeframe-btn" data-timeframe="4h" data-i18n="dashboard.chart.timeframe.4h">4h</button>
                            <button class="timeframe-btn" data-timeframe="2d" data-i18n="dashboard.chart.timeframe.2d">2d</button>
                            <button class="timeframe-btn" data-timeframe="3d" data-i18n="dashboard.chart.timeframe.3d">3d</button>
                        </div>
                    </div>
                </div>

                <!-- Unified Charts Wrapper -->
                <div class="charts-wrapper" id="charts-wrapper">
                    <!-- Main Chart Container -->
                    <div class="chart-container" id="chart-container" style="flex: 1; min-height: 450px; display: flex; flex-direction: column;">
                        <div style="position: relative; flex: 1; min-height: 340px;">
                        <div class="chart-canvas" id="chart-canvas">
                            <div class="chart-line">
                                <svg viewBox="0 0 100 100" preserveAspectRatio="none" id="sentiment-chart">
                                    <defs>
                                        <linearGradient id="lineGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                            <stop offset="0%" style="stop-color:#ff8c42;stop-opacity:1" />
                                            <stop offset="30%" style="stop-color:#ff7b52;stop-opacity:1" />
                                            <stop offset="60%" style="stop-color:#ff6b6b;stop-opacity:1" />
                                            <stop offset="100%" style="stop-color:#ef4444;stop-opacity:1" />
                                        </linearGradient>
                                    </defs>
                                    <path class="chart-path" d="" />
                                </svg>
                            </div>
                            <svg viewBox="0 0 100 100" preserveAspectRatio="none" id="chart-dots-svg" style="position: absolute; left: 0; right: 0; top: 0; bottom: 0; width: 100%; height: 100%; pointer-events: none;">
                                <g id="chart-dots"></g>
                                <g id="nasdaq-price-line"></g>
                            </svg>
                            <div class="chart-tooltip" id="chart-tooltip">
                                <div class="tooltip-label">Nasdaq Price</div>
                                <div class="tooltip-value">$0.00</div>
                                <div class="tooltip-sentiment" id="tooltip-sentiment">Score: +0</div>
                                <div class="tooltip-time">14:32:45</div>
                            </div>
                        </div>
                        <div class="x-axis" id="x-axis-labels">
                            <span>-60m</span>
                            <span>-45m</span>
                            <span>-30m</span>
                            <span>-15m</span>
                            <span>Now</span>
                        </div>
                        </div>
                        
                        <!-- Volume Chart (below price chart) -->
                        <div class="volume-container" id="volume-container" style="height: 70px; flex-shrink: 0;">
                            <svg viewBox="0 0 100 100" preserveAspectRatio="none" id="volume-chart-svg" style="width: 100%; height: 100%; padding-left: 20px; padding-right: 10%;">
                                <g id="volume-bars"></g>
                            </svg>
                        </div>
                        
                        <div class="chart-side-panel"></div>
                        <div class="chart-side-panel-second"></div>
                    </div>

                    <!-- Oscillator -->
                    <div class="chart-oscillator-container">
                        <div class="oscillator-y-axis" id="oscillator-y-axis"></div>
                        <div class="chart-oscillator" id="chart-oscillator"></div>
                        <div class="oscillator-x-axis" id="oscillator-x-axis"></div>
                        <!-- Current Sentiment Score Panel -->
                        <div class="oscillator-score-panel">
                            <!-- Expand/Collapse Icon -->
                        <button type="button" class="oscillator-expand-btn" id="oscillator-expand-btn" title="Toggle visible window scale">
                            <svg class="expand-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                                </svg>
                            <svg class="collapse-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
                                <path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path>
                                </svg>
                            </button>
                            <!-- Score Display -->
                            <div class="oscillator-score-display">
                                <div class="oscillator-score-value" id="oscillator-current-score">+0</div>
                                <div class="oscillator-score-label">Score</div>
                            </div>

                            <!-- Candle-Decay Mode Button (9th View) - Always Visible -->
                            <button type="button" class="candle-decay-quick-btn" id="candle-decay-quick-btn" title="Candle-Based Decay Mode - News up signals with candle-triggered decay">
                                <svg width="12" height="12" viewBox="0 0 16 16" fill="none">
                                    <path d="M4 12 L4 8 L6 6 L6 12" stroke="currentColor" stroke-width="1.5" fill="none"/>
                                    <path d="M10 12 L10 4 L12 6 L12 12" stroke="currentColor" stroke-width="1.5" fill="none"/>
                                </svg>
                            </button>

                            <!-- Scale Mode Selector - 2 rows of 3 buttons -->
                            <div id="oscillator-scale-selector" class="oscillator-scale-selector-container">
                                <!-- First Row -->
                                <div style="display: flex; flex-direction: row; gap: 3px; align-items: center;">
                                    <input type="radio" id="scale-fixed" name="oscillator-scale" value="fixed" style="display: none;">
                                    <label for="scale-fixed" title="Fixed scale: -100 to +100" style="display: flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 2px; background: rgba(0, 0, 0, 0.3); border: 1px solid #444; cursor: pointer; color: #888; transition: all 0.2s ease;">
                                        <svg width="9" height="9" viewBox="0 0 16 16" fill="none">
                                            <rect x="2" y="2" width="12" height="12" stroke="currentColor" stroke-width="1.5" rx="1"/>
                                            <line x1="2" y1="8" x2="14" y2="8" stroke="currentColor" stroke-width="1"/>
                                        </svg>
                                    </label>

                                    <input type="radio" id="scale-visible" name="oscillator-scale" value="visible" checked style="display: none;">
                                    <label for="scale-visible" title="Scale to visible window" style="display: flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 2px; background: rgba(0, 0, 0, 0.3); border: 1px solid #444; cursor: pointer; color: #888; transition: all 0.2s ease;">
                                        <svg width="9" height="9" viewBox="0 0 16 16" fill="none">
                                            <rect x="2" y="2" width="12" height="12" stroke="currentColor" stroke-width="1.5" rx="1"/>
                                            <path d="M5 8 L8 5 L11 10 L14 6" stroke="currentColor" stroke-width="1.5" fill="none"/>
                                        </svg>
                                    </label>

                                    <input type="radio" id="scale-full" name="oscillator-scale" value="full" style="display: none;">
                                    <label for="scale-full" title="Scale to full timeframe" style="display: flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 2px; background: rgba(0, 0, 0, 0.3); border: 1px solid #444; cursor: pointer; color: #888; transition: all 0.2s ease;">
                                        <svg width="9" height="9" viewBox="0 0 16 16" fill="none">
                                            <rect x="2" y="2" width="12" height="12" stroke="currentColor" stroke-width="1.5" rx="1"/>
                                            <path d="M2 8 L5 5 L8 10 L11 4 L14 9" stroke="currentColor" stroke-width="1.5" fill="none"/>
                                        </svg>
                                    </label>
                                </div>

                                <!-- Second Row -->
                                <div style="display: flex; flex-direction: row; gap: 3px; align-items: center;">
                                    <!-- Signal Mode Toggle -->
                                    <input type="radio" id="scale-signal" name="oscillator-scale" value="signal" style="display: none;">
                                    <label for="scale-signal" id="signal-mode-toggle" title="Signal Mode (News UP / Technical DOWN) - Fixed scale: -100 to +100" style="display: flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 2px; background: rgba(0, 0, 0, 0.3); border: 1px solid #444; cursor: pointer; color: #888; transition: all 0.2s ease;">
                                        <svg width="9" height="9" viewBox="0 0 16 16" fill="none">
                                            <path d="M8 2 L8 14" stroke="currentColor" stroke-width="1.5"/>
                                            <path d="M4 6 L8 2 L12 6" stroke="currentColor" stroke-width="1.5" fill="none"/>
                                            <path d="M4 10 L8 14 L12 10" stroke="currentColor" stroke-width="1.5" fill="none"/>
                                        </svg>
                                    </label>

                                    <!-- News Score Mode Toggle -->
                                    <input type="radio" id="scale-news" name="oscillator-scale" value="news" style="display: none;">
                                    <label for="scale-news" id="news-mode-toggle" title="News Score Mode - Shows news score only" style="display: flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 2px; background: rgba(0, 0, 0, 0.3); border: 1px solid #444; cursor: pointer; color: #888; transition: all 0.2s ease;">
                                        <svg width="9" height="9" viewBox="0 0 16 16" fill="none">
                                            <path d="M3 8 L6 5 L9 8 L13 4" stroke="currentColor" stroke-width="1.5" fill="none"/>
                                            <circle cx="8" cy="8" r="1.5" fill="currentColor"/>
                                        </svg>
                                    </label>

                                    <!-- Weighted Average Mode Toggle -->
                                    <input type="radio" id="scale-weighted" name="oscillator-scale" value="weighted" style="display: none;">
                                    <label for="scale-weighted" id="weighted-mode-toggle" title="Weighted Average Mode - Mix of signal-based score and conventional sentiment" style="display: flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 2px; background: rgba(0, 0, 0, 0.3); border: 1px solid #444; cursor: pointer; color: #888; transition: all 0.2s ease;">
                                        <svg width="9" height="9" viewBox="0 0 16 16" fill="none">
                                            <path d="M2 8 L6 4 L10 8 L14 4" stroke="currentColor" stroke-width="1.5" fill="none"/>
                                            <path d="M2 12 L6 8 L10 12 L14 8" stroke="currentColor" stroke-width="1.5" fill="none"/>
                                        </svg>
                                    </label>
                                </div>

                                <!-- Third Row -->
                                <div style="display: flex; flex-direction: row; gap: 3px; align-items: center;">
                                    <!-- News + Composite Mode Toggle -->
                                    <input type="radio" id="scale-news-composite" name="oscillator-scale" value="news-composite" style="display: none;">
                                    <label for="scale-news-composite" id="news-composite-mode-toggle" title="News + Composite Mode - Composite score + (news tracking score Ã— 0.7)" style="display: flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 2px; background: rgba(0, 0, 0, 0.3); border: 1px solid #444; cursor: pointer; color: #888; transition: all 0.2s ease;">
                                        <svg width="9" height="9" viewBox="0 0 16 16" fill="none">
                                            <path d="M3 8 L6 5 L9 8 L13 4" stroke="currentColor" stroke-width="1.5" fill="none"/>
                                            <path d="M2 8 L6 4 L10 8 L14 4" stroke="currentColor" stroke-width="1.5" fill="none" opacity="0.6"/>
                                        </svg>
                                    </label>

                                    <!-- News + Price Mode Toggle -->
                                    <input type="radio" id="scale-news-price" name="oscillator-scale" value="news-price" style="display: none;">
                                    <label for="scale-news-price" id="news-price-mode-toggle" title="News + Price Mode - Stock price + (news tracking score Ã— 0.7)" style="display: flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 2px; background: rgba(0, 0, 0, 0.3); border: 1px solid #444; cursor: pointer; color: #888; transition: all 0.2s ease;">
                                        <svg width="9" height="9" viewBox="0 0 16 16" fill="none">
                                            <path d="M3 8 L6 5 L9 8 L13 4" stroke="currentColor" stroke-width="1.5" fill="none"/>
                                            <path d="M2 12 L8 4 L14 12" stroke="currentColor" stroke-width="1.5" fill="none" opacity="0.6"/>
                                        </svg>
                                    </label>

                                    <!-- Candle-Based Decay Mode Toggle -->
                                    <input type="radio" id="scale-candle-decay" name="oscillator-scale" value="candle-decay" style="display: none;">
                                    <label for="scale-candle-decay" id="candle-decay-mode-toggle" title="Candle-Based Decay Mode - News up signals with candle-triggered decay" style="display: flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 2px; background: rgba(0, 0, 0, 0.3); border: 1px solid #444; cursor: pointer; color: #888; transition: all 0.2s ease;">
                                        <svg width="9" height="9" viewBox="0 0 16 16" fill="none">
                                            <path d="M4 12 L4 8 L6 6 L6 12" stroke="currentColor" stroke-width="1.5" fill="none"/>
                                            <path d="M10 12 L10 4 L12 6 L12 12" stroke="currentColor" stroke-width="1.5" fill="none"/>
                                        </svg>
                                    </label>
                                </div>
                            </div>
                        </div>
                        <div class="chart-tooltip" id="oscillator-tooltip">
                            <div class="tooltip-label">Sentiment Score</div>
                            <div class="tooltip-value" style="color: #ff8c42;">+0</div>
                            <div class="tooltip-time">14:32:45</div>
                        </div>
                        <!-- Market Status Indicator (inside oscillator) -->
                        <div class="market-status-indicator" id="market-status-indicator" style="display: none;">
                            Market is currently closed. Latest data from <span id="market-close-time"></span>
                        </div>
                    </div>

                    <!-- Horizontal Scrollbar for Historical Data -->
                    <div class="chart-scrollbar-container" id="chart-scrollbar-container">
                        <input type="range" class="chart-scrollbar" id="chart-scrollbar" min="0" max="100" value="100" step="1">
                    </div>

                    <!-- Unified Hover Elements (span both charts) -->
                    <div class="unified-hover-line" id="unified-hover-line"></div>
                    <div class="chart-time-label" id="time-label">00:00:00</div>
                </div>
            </div>
        </div>
    </div>


    <script>
        // Clerk authentication check - redirect if not logged in
        window.addEventListener('load', async function() {
            try {
                // Wait for Clerk to be available
                if (!window.Clerk) {
                    // Wait a bit for async script to load
                    let retries = 0;
                    while (!window.Clerk && retries < 50) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        retries++;
                    }
                    
                    if (!window.Clerk) {
                        console.error('Clerk SDK failed to load');
                        window.location.href = '/index.html';
                        return;
                    }
                }
                
                await window.Clerk.load();
                
                // Check if user is authenticated
                if (!window.Clerk.user) {
                    window.location.href = '/index.html';
                    return;
                }

                // Note: Onboarding check is now handled by the disclaimer modal
                // The disclaimer modal will call checkAndShowOnboarding() after user acknowledges
                // This ensures disclaimer shows first, then onboarding if needed
                
                // Setup logout functionality
                const logoutLink = document.getElementById('logout-link');
                if (logoutLink) {
                    logoutLink.addEventListener('click', async function(e) {
                        e.preventDefault();
                        try {
                            await window.Clerk.signOut();
                            window.location.href = '/index.html';
                        } catch (error) {
                            console.error('Error signing out:', error);
                            // Fallback: redirect anyway
                            window.location.href = '/index.html';
                        }
                    });
                }
            } catch (error) {
                console.error('Error loading Clerk:', error);
                // Redirect to index if Clerk fails to load
                window.location.href = '/index.html';
            }
        });

        // Timezone data embedded directly (to avoid CORS issues with local file access)
        const timezonesData = [
            {"offset": "-12:00", "name": "Baker Island Time", "code": "BIT"},
            {"offset": "-11:00", "name": "Samoa Standard Time", "code": "SST"},
            {"offset": "-10:00", "name": "Hawaii-Aleutian Standard Time", "code": "HST"},
            {"offset": "-09:30", "name": "Marquesas Islands Time", "code": "MART"},
            {"offset": "-09:00", "name": "Alaska Standard Time", "code": "AKST"},
            {"offset": "-08:00", "name": "Pacific Standard Time", "code": "PST"},
            {"offset": "-07:00", "name": "Mountain Standard Time", "code": "MST"},
            {"offset": "-06:00", "name": "Central Standard Time", "code": "CST"},
            {"offset": "-05:00", "name": "Eastern Standard Time", "code": "EST"},
            {"offset": "-04:00", "name": "Atlantic Standard Time", "code": "AST"},
            {"offset": "-03:30", "name": "Newfoundland Standard Time", "code": "NST"},
            {"offset": "-03:00", "name": "Argentina Time", "code": "ART"},
            {"offset": "-02:00", "name": "South Georgia Time", "code": "GST"},
            {"offset": "-01:00", "name": "Azores Standard Time", "code": "AZOST"},
            {"offset": "+00:00", "name": "Coordinated Universal Time", "code": "UTC"},
            {"offset": "+01:00", "name": "Central European Time", "code": "CET"},
            {"offset": "+02:00", "name": "Eastern European Time", "code": "EET"},
            {"offset": "+03:00", "name": "Moscow Standard Time", "code": "MSK"},
            {"offset": "+03:30", "name": "Iran Standard Time", "code": "IRST"},
            {"offset": "+04:00", "name": "Gulf Standard Time", "code": "GST"},
            {"offset": "+04:30", "name": "Afghanistan Time", "code": "AFT"},
            {"offset": "+05:00", "name": "Pakistan Standard Time", "code": "PKT"},
            {"offset": "+05:30", "name": "India Standard Time", "code": "IST"},
            {"offset": "+05:45", "name": "Nepal Time", "code": "NPT"},
            {"offset": "+06:00", "name": "Bangladesh Standard Time", "code": "BST"},
            {"offset": "+06:30", "name": "Myanmar Time", "code": "MMT"},
            {"offset": "+07:00", "name": "Indochina Time", "code": "ICT"},
            {"offset": "+08:00", "name": "China Standard Time", "code": "CST"},
            {"offset": "+08:45", "name": "Australian Central Western Standard Time", "code": "ACWST"},
            {"offset": "+09:00", "name": "Japan Standard Time", "code": "JST"},
            {"offset": "+09:30", "name": "Australian Central Standard Time", "code": "ACST"},
            {"offset": "+10:00", "name": "Australian Eastern Standard Time", "code": "AEST"},
            {"offset": "+10:30", "name": "Lord Howe Standard Time", "code": "LHST"},
            {"offset": "+11:00", "name": "Solomon Islands Time", "code": "SBT"},
            {"offset": "+12:00", "name": "New Zealand Standard Time", "code": "NZST"},
            {"offset": "+12:45", "name": "Chatham Islands Standard Time", "code": "CHAST"},
            {"offset": "+13:00", "name": "Tonga Time", "code": "TOT"},
            {"offset": "+14:00", "name": "Line Islands Time", "code": "LINT"}
        ];
        
        let currentTimezoneData = null;
        
        // Parse offset string to decimal hours (e.g., "-05:00" -> -5, "+05:30" -> 5.5)
        function parseOffset(offsetStr) {
            const sign = offsetStr.charAt(0) === '-' ? -1 : 1;
            const parts = offsetStr.substring(1).split(':');
            const hours = parseInt(parts[0]);
            const minutes = parseInt(parts[1]);
            return sign * (hours + minutes / 60);
        }
        
        // Format date and time for a given timezone
        function getTimezoneDateTime(offsetHours) {
            const now = new Date();
            const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
            const localTime = new Date(utc + (3600000 * offsetHours));
            
            const year = localTime.getFullYear();
            const month = String(localTime.getMonth() + 1).padStart(2, '0');
            const day = String(localTime.getDate()).padStart(2, '0');
            const hours = String(localTime.getHours()).padStart(2, '0');
            const minutes = String(localTime.getMinutes()).padStart(2, '0');
            const seconds = String(localTime.getSeconds()).padStart(2, '0');
            
            return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
        }
        
        // Update the main clock display
        function updateTime() {
            if (!currentTimezoneData) {
                // Default to local time if no timezone selected
                const now = new Date();
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');
                document.getElementById('current-time').textContent = `${hours}:${minutes}:${seconds}`;
                return;
            }
            
            const offsetHours = parseOffset(currentTimezoneData.offset);
            const now = new Date();
            const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
            const localTime = new Date(utc + (3600000 * offsetHours));
            
            const hours = String(localTime.getHours()).padStart(2, '0');
            const minutes = String(localTime.getMinutes()).padStart(2, '0');
            const seconds = String(localTime.getSeconds()).padStart(2, '0');
            document.getElementById('current-time').textContent = `${hours}:${minutes}:${seconds}`;
        }
        
        // Initialize timezone system
        function loadTimezones() {
            console.log('Initializing timezones...');
            console.log('Timezones loaded:', timezonesData.length);
            
            // Set default timezone to EST
            currentTimezoneData = timezonesData.find(tz => tz.code === 'EST') || timezonesData[0];
            console.log('Default timezone set to:', currentTimezoneData);
            
            populateTimezoneDropdown();
            updateTime();
        }
        
        // Populate the timezone dropdown with all options
        function populateTimezoneDropdown() {
            const dropdown = document.getElementById('timezone-dropdown');
            
            if (!dropdown) {
                console.error('Timezone dropdown element not found!');
                return;
            }
            
            console.log('Populating dropdown with', timezonesData.length, 'timezones');
            dropdown.innerHTML = '';
            
            timezonesData.forEach((tz, index) => {
                const offsetHours = parseOffset(tz.offset);
                const dateTime = getTimezoneDateTime(offsetHours);
                
                const option = document.createElement('div');
                option.className = 'timezone-option';
                if (currentTimezoneData && currentTimezoneData.code === tz.code) {
                    option.classList.add('active');
                }
                
                option.innerHTML = `
                    <div class="timezone-option-main">
                        <span class="timezone-option-offset">${tz.offset}</span>
                        <span class="timezone-option-code">${tz.code}</span>
                        <span>${tz.name}</span>
                    </div>
                    <div class="timezone-option-datetime">${dateTime}</div>
                `;
                
                option.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectTimezone(tz);
                });
                
                dropdown.appendChild(option);
            });
            
            console.log('Dropdown populated. Children count:', dropdown.children.length);
        }
        
        // Select a timezone
        function selectTimezone(tz) {
            currentTimezoneData = tz;
            
            // Update active state
            document.querySelectorAll('.timezone-option').forEach(opt => opt.classList.remove('active'));
            event.currentTarget.classList.add('active');
            
            // Update time immediately
            updateTime();
            
            // Update chart with new timezone
            if (typeof currentTimeframe !== 'undefined' && typeof updateChart === 'function') {
                updateChart(currentTimeframe);
            }
            
            // Close dropdown
            document.getElementById('timezone-dropdown').classList.remove('show');
            document.getElementById('timezone-selector').classList.remove('open');
        }
        
        // Update dropdown times every second
        function updateDropdownTimes() {
            const options = document.querySelectorAll('.timezone-option');
            timezonesData.forEach((tz, index) => {
                if (options[index]) {
                    const offsetHours = parseOffset(tz.offset);
                    const dateTime = getTimezoneDateTime(offsetHours);
                    const dateTimeElem = options[index].querySelector('.timezone-option-datetime');
                    if (dateTimeElem) {
                        dateTimeElem.textContent = dateTime;
                    }
                }
            });
        }
        
        // Animate progress bars on load
        window.addEventListener('load', () => {
            const progressBars = document.querySelectorAll('.progress-fill');
            progressBars.forEach(bar => {
                const width = bar.style.width;
                bar.style.width = '0';
                setTimeout(() => {
                    bar.style.width = width;
                }, 100);
            });
        });

        // Initialize timezones and dashboard after DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            loadTimezones();
            initializeDashboard();
        });
        
        // Update time every second
        setInterval(() => {
            updateTime();
            // Only update dropdown times if dropdown is open
            const dropdown = document.getElementById('timezone-dropdown');
            if (dropdown && dropdown.classList.contains('show')) {
                updateDropdownTimes();
            }
        }, 1000);

        // News filter buttons
        const filterBtns = document.querySelectorAll('.filter-btn');
        const newsItemLinks = document.querySelectorAll('.news-item-link');
        
        filterBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                filterBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                const filter = btn.textContent.toLowerCase();
                
                newsItemLinks.forEach(link => {
                    const sentimentTag = link.querySelector('.sentiment-tag');
                    const sentiment = sentimentTag ? sentimentTag.textContent.toLowerCase() : '';
                    
                    if (filter === 'all') {
                        link.style.display = 'block';
                    } else if (filter === 'breaking') {
                        // Show first 2 items for "breaking" news
                        const isBreaking = Array.from(newsItemLinks).indexOf(link) < 2;
                        link.style.display = isBreaking ? 'block' : 'none';
                    } else {
                        link.style.display = sentiment === filter ? 'block' : 'none';
                    }
                });
            });
        });

        // Timezone dropdown toggle - initialize after DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            const timezoneSelector = document.getElementById('timezone-selector');
            const timezoneDropdown = document.getElementById('timezone-dropdown');

            if (timezoneSelector && timezoneDropdown) {
                timezoneSelector.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('timezone-option')) {
                        timezoneDropdown.classList.toggle('show');
                        timezoneSelector.classList.toggle('open');
                        
                        // Update all dropdown times when opening
                        if (timezoneDropdown.classList.contains('show')) {
                            updateDropdownTimes();
                        }
                    }
                });

                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!timezoneSelector.contains(e.target)) {
                        timezoneDropdown.classList.remove('show');
                        timezoneSelector.classList.remove('open');
                    }
                });
            }

            // Indices dropdown toggle
            const indicesSelector = document.getElementById('indices-selector');
            const indicesDropdown = document.getElementById('indices-dropdown');

            if (indicesSelector && indicesDropdown) {
                indicesSelector.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('indices-option')) {
                        indicesDropdown.classList.toggle('show');
                    }
                });

                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!indicesSelector.contains(e.target)) {
                        indicesDropdown.classList.remove('show');
                    }
                });

                // Handle indices option selection
                const indicesOptions = document.querySelectorAll('.indices-option');
                indicesOptions.forEach(option => {
                    option.addEventListener('click', (e) => {
                        e.stopPropagation();
                        
                        // Update active state
                        indicesOptions.forEach(opt => opt.classList.remove('active'));
                        option.classList.add('active');
                        
                        // Get selected index
                        const selectedIndex = option.getAttribute('data-index');
                        console.log('Selected index:', selectedIndex);
                        
                        // Close dropdown
                        indicesDropdown.classList.remove('show');
                        
                        // You can add additional functionality here when more indices are added
                        // For now, only Nasdaq is available
                    });
                });
            }
        });

        // Timeframe selector and chart update
        const timeframeBtns = document.querySelectorAll('.timeframe-btn');
        const xAxisLabels = document.getElementById('x-axis-labels');
        const chartPath = document.querySelector('.chart-path');
        let currentTimeframe = '6h'; // Declare timeframe variable globally
        let scrollPosition = 100; // 100 = rightmost (most recent data), 0 = leftmost (oldest data)
        let chartType = 'candlestick'; // 'line' or 'candlestick'
        
        // ===== REAL NASDAQ SENTIMENT DATA =====
        // Fetch real composite sentiment data from the API
        let sentimentDataset = [];
        let sentimentDataset2d = [];
        let sentimentDataset3d = [];
        let currentCompositeScore = 0;

        // Global signal state cache - maps timestamp to signal value (+100, 0, -100)
        // Calculated once from complete dataset for consistency across all timeframes
        let globalSignalCache = new Map();
        
        // ===== GRANULAR DATA (SECOND & TICK CANDLES) =====
        let secondCandlesDataset = [];
        let tickCandlesDataset = [];
        let granularDataType = 'second'; // 'second' or 'tick'
        let lastGranularTimestamp = null;
        let granularRefreshInterval = null;
        
        // API Base URL - adjust if needed
        // Dynamic API URL - detects localhost, file://, or production
        const API_BASE_URL = (
            window.location.protocol === 'file:' ||
            window.location.hostname === 'localhost' ||
            window.location.hostname === '127.0.0.1' ||
            window.location.hostname === ''
        ) ? 'http://localhost:8000/api'
          : (window.BACKEND_URL || 'https://nasdaqsentimenttracker-production.up.railway.app/api');

        // Fetch dashboard data (composite score + 3 drivers + historical data)
        async function fetchDashboardData() {
            try {
                console.log('ðŸ”„ Fetching dashboard data from API...');
                const response = await fetch(`${API_BASE_URL}/dashboard/`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                console.log('âœ“ Dashboard data received:', data.composite_score);
                
                // DEBUG: Check what the backend is actually sending for price data
                console.log('ðŸ” BACKEND RESPONSE DEBUG:');
                if (data.historical && data.historical.length > 0) {
                    console.log('ðŸ“¦ Raw historical[0]:', JSON.stringify(data.historical[0], null, 2));
                    console.log('ðŸ“¦ Keys in historical[0]:', Object.keys(data.historical[0]));
                    console.log('ðŸ“¦ "price" field exists?', 'price' in data.historical[0]);
                    console.log('ðŸ“¦ "price" value:', data.historical[0].price);
                    console.log('ðŸ“¦ Type of price:', typeof data.historical[0].price);
                }
 
                // Update current composite score
                currentCompositeScore = data.composite_score;

                // Update sentiment display and drivers
                updateSentimentDisplay(data);
                updateSentimentDrivers(data.drivers, data.vxn_index, data.composite_score);

                // Populate sentimentDataset for chart (24 hours)
                if (data.historical && data.historical.length > 0) {
                    console.log('ðŸ“Š Mapping historical data - first raw point:', data.historical[0]);
                    sentimentDataset = data.historical.map(point => {
                        const mapped = {
                            timestamp: new Date(point.timestamp),
                            sentiment: point.composite_score,
                            price: point.price,
                            // OHLC data for candlestick charts
                            open: point.open,
                            high: point.high,
                            low: point.low,
                            volume: point.volume,
                            // Include individual driver scores (using actual API field names)
                            news: point.news_composite || null,
                            indicators: point.technical_composite || null
                        };
                        return mapped;
                    });
                    console.log(`âœ“ Loaded ${sentimentDataset.length} historical data points (24h)`);
                    console.log('ðŸ“Š First mapped point:', sentimentDataset[0]);
                    // Debug: Check price data
                    const pricesWithData = sentimentDataset.filter(p => p.price != null && !isNaN(p.price));
                    console.log(`ðŸ“Š Price data check: ${pricesWithData.length}/${sentimentDataset.length} points have price data`);
                    if (pricesWithData.length > 0) {
                        console.log(`ðŸ“Š Sample prices: ${pricesWithData.slice(0, 3).map(p => `$${p.price.toFixed(2)}`).join(', ')}`);
                    } else {
                        console.warn('âš ï¸ No prices found! Sample point:', sentimentDataset[0]);
                    }
                } else {
                    console.warn('âš ï¸  No historical data in API response');
                    sentimentDataset = [];
                }

                // Populate sentimentDataset2d for chart (2 days)
                if (data.historical_2d && data.historical_2d.length > 0) {
                    sentimentDataset2d = data.historical_2d.map(point => ({
                        timestamp: new Date(point.timestamp),
                        sentiment: point.composite_score,
                        price: point.price,
                        open: point.open,
                        high: point.high,
                        low: point.low,
                        volume: point.volume,
                        news: point.news_composite || null,
                        indicators: point.technical_composite || null
                    }));
                    console.log(`âœ“ Loaded ${sentimentDataset2d.length} historical data points (2d)`);
                } else {
                    console.warn('âš ï¸  No 2-day historical data in API response');
                    sentimentDataset2d = [];
                }

                // Populate sentimentDataset3d for chart (3 days)
                if (data.historical_3d && data.historical_3d.length > 0) {
                    sentimentDataset3d = data.historical_3d.map(point => ({
                        timestamp: new Date(point.timestamp),
                        sentiment: point.composite_score,
                        price: point.price,
                        open: point.open,
                        high: point.high,
                        low: point.low,
                        volume: point.volume,
                        news: point.news_composite || null,
                        indicators: point.technical_composite || null
                    }));
                    console.log(`âœ“ Loaded ${sentimentDataset3d.length} historical data points (3d)`);
                } else {
                    console.warn('âš ï¸  No 3-day historical data in API response');
                    sentimentDataset3d = [];
                }

                // Build global signal cache from complete dataset for consistency across all timeframes
                buildGlobalSignalCache();

                // Update market status AFTER datasets are populated so we can use latest timestamp
                updateMarketStatus(data.market_status);

                return data;
            } catch (error) {
                console.error('âŒ Error fetching dashboard data:', error);
                // Fallback to default values
                currentCompositeScore = 0;
                sentimentDataset = [];
                sentimentDataset2d = [];
                sentimentDataset3d = [];
                updateSentimentDisplay({
                    composite_score: currentCompositeScore,
                    sentiment_label: 'NEUTRAL'
                });
                return null;
            }
        }

        // ===== GRANULAR DATA FETCH FUNCTIONS =====
        
        // Fetch second candles (1-second OHLCV data)
        async function fetchSecondCandles(startTime = null) {
            try {
                // Always fetch ALL available data for the symbol, then client-side filter to most recent
                let url = `${API_BASE_URL}/second-candles/?symbol=QLD`;
                console.log('ðŸ”„ Fetching all second candles:', url);
                
                // Note: We removed limit and ordering because the API seems to return old data
                // Instead, we'll fetch everything and sort/filter on the client side
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();

                // Handle both API response structures: result.data or result.data_points
                const dataArray = result.data_points || result.data || [];
                console.log(`âœ… Received ${dataArray.length} second candles from API`);
                console.log('ðŸ” Full API Response Keys:', Object.keys(result));

                // Debug: Log the API response structure
                if (dataArray.length > 0) {
                    console.log('ðŸ” API Response Structure Sample:', dataArray[0]);
                    console.log('ðŸ” Available fields:', Object.keys(dataArray[0]));
                }

                if (dataArray.length === 0) {
                    console.warn('âš ï¸ No second candles data available from API');
                    return [];
                }

                // Log the timestamp range of received data
                if (dataArray.length > 0) {
                    const firstTs = new Date(dataArray[0].timestamp);
                    const lastTs = new Date(dataArray[dataArray.length - 1].timestamp);
                    console.log(`ðŸ“… API data range: ${firstTs.toISOString()} to ${lastTs.toISOString()}`);
                    console.log(`â° Current time: ${new Date().toISOString()}`);
                }

                // Map to internal format
                let mappedData = dataArray.map(candle => ({
                    timestamp: new Date(candle.timestamp),
                    open: candle.open,
                    high: candle.high,
                    low: candle.low,
                    price: candle.close, // 'close' from API maps to 'price' internally
                    volume: candle.volume,
                    tick_count: candle.tick_count || 0,
                    sentiment: candle.composite_score ?? 0, // Composite score from API
                    news: candle.news_component ?? null, // News component from API
                    indicators: candle.technical_component ?? null // Technical component from API
                }));
                
                // ALWAYS sort by timestamp descending (newest first) on client side
                mappedData.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());

                // If market is closed, filter to show the last hour of trading (3pm-4pm ET)
                if (!isMarketOpen && mappedData.length > 0) {
                    // Get today's date in ET timezone
                    const now = new Date();
                    const etFormatter = new Intl.DateTimeFormat('en-US', {
                        timeZone: 'America/New_York',
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit'
                    });
                    const etParts = etFormatter.formatToParts(now);
                    const etYear = parseInt(etParts.find(p => p.type === 'year').value);
                    const etMonth = parseInt(etParts.find(p => p.type === 'month').value) - 1;
                    const etDay = parseInt(etParts.find(p => p.type === 'day').value);

                    // Helper to convert ET to UTC
                    const etToUTC = (year, month, day, hour, minute) => {
                        const isoStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}T${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}:00`;
                        let testUTC = new Date(isoStr + '-05:00');
                        return testUTC;
                    };

                    // Market close at 4pm ET, last hour is 3pm-4pm ET
                    const marketCloseTime = etToUTC(etYear, etMonth, etDay, 16, 0);
                    const lastHourStartTime = etToUTC(etYear, etMonth, etDay, 15, 0);

                    console.log(`ðŸ•’ Market closed - filtering for last trading hour: ${lastHourStartTime.toISOString()} to ${marketCloseTime.toISOString()}`);

                    // Filter data to show only the last hour of trading
                    mappedData = mappedData.filter(candle => {
                        return candle.timestamp >= lastHourStartTime && candle.timestamp <= marketCloseTime;
                    });

                    console.log(`ðŸ“Š Filtered to last trading hour: ${mappedData.length} candles`);
                } else {
                    // Market is open - keep only the most recent 4000 candles (about 66 minutes of 1-second data)
                    mappedData = mappedData.slice(0, 4000);
                    console.log(`ðŸ“Š After client-side sort and limit: ${mappedData.length} candles`);
                }
                if (mappedData.length > 0) {
                    console.log(`   Newest: ${mappedData[0].timestamp.toISOString()}`);
                    console.log(`   Oldest: ${mappedData[mappedData.length - 1].timestamp.toISOString()}`);
                    console.log(`   ðŸ“Š SENTIMENT DATA CHECK:`, {
                        sentiment: mappedData[0].sentiment,
                        news: mappedData[0].news,
                        indicators: mappedData[0].indicators,
                        raw_api_data: result.data[0]
                    });
                }
                
                // ALWAYS replace the dataset with the freshest data
                // This ensures the chart updates every second even if no NEW candles exist
                secondCandlesDataset = mappedData;
                console.log(`ðŸ“Š Dataset refreshed: ${secondCandlesDataset.length} candles (newest: ${mappedData[0].timestamp.toISOString()})`);
                
                // Update last timestamp for incremental updates
                if (secondCandlesDataset.length > 0) {
                    lastGranularTimestamp = secondCandlesDataset[secondCandlesDataset.length - 1].timestamp;
                }
                
                // Note: Granular charts calculate signals independently, so no cache rebuild needed
                // The global cache is only for minute-level data (regular charts)
                
                return mappedData;
            } catch (error) {
                console.error('âŒ Error fetching second candles:', error);
                return [];
            }
        }
        
        // Fetch tick candles (100-tick OHLCV data)
        async function fetchTickCandles(startTime = null) {
            try {
                // If startTime is provided, we're doing an incremental update - only fetch recent data
                let url = `${API_BASE_URL}/tick-candles/?symbol=QLD`;
                if (startTime) {
                    // For incremental updates, fetch the most recent candles
                    // Order by timestamp descending to get the newest data first
                    url += `&limit=120&ordering=-timestamp`;
                    console.log('ðŸ”„ Fetching incremental tick candles (last 120, newest first):', url);
                } else {
                    // Initial load: fetch enough for the longest view
                    // Order by timestamp descending to get the newest data
                    url += `&limit=1000&ordering=-timestamp`;
                    console.log('ðŸ”„ Fetching initial tick candles (last 1000, newest first):', url);
                }
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                console.log(`âœ… Received ${result.data.length} tick candles from API`);
                
                if (result.data.length === 0) {
                    console.warn('âš ï¸ No tick candles data available from API');
                    return [];
                }
                
                // Log the timestamp range of received data
                if (result.data.length > 0) {
                    const firstTs = new Date(result.data[0].timestamp);
                    const lastTs = new Date(result.data[result.data.length - 1].timestamp);
                    console.log(`ðŸ“… API data range: ${firstTs.toISOString()} to ${lastTs.toISOString()}`);
                    console.log(`â° Current time: ${new Date().toISOString()}`);
                }
                
                // Map to internal format
                const mappedData = result.data.map(candle => ({
                    timestamp: new Date(candle.timestamp),
                    open: candle.open,
                    high: candle.high,
                    low: candle.low,
                    price: candle.close, // 'close' from API maps to 'price' internally
                    volume: candle.volume,
                    tick_count: candle.tick_count || 100,
                    candle_number: candle.candle_number,
                    duration_seconds: candle.duration_seconds,
                    sentiment: candle.composite_score ?? 0, // Composite score from API
                    news: candle.news_component ?? null, // News component from API
                    indicators: candle.technical_component ?? null // Technical component from API
                }));
                
                // If this is an incremental update, merge with existing data
                if (startTime && tickCandlesDataset.length > 0) {
                    // Create a map of existing timestamps for faster lookup
                    const existingTimestamps = new Set(
                        tickCandlesDataset.map(d => d.timestamp.getTime())
                    );
                    
                    // Filter out duplicates based on timestamp
                    const uniqueNewData = mappedData.filter(d => !existingTimestamps.has(d.timestamp.getTime()));
                    
                    if (uniqueNewData.length > 0) {
                        // Merge and sort by timestamp
                        tickCandlesDataset = [...tickCandlesDataset, ...uniqueNewData]
                            .sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
                        
                        // Keep only last 1 hour
                        const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
                        tickCandlesDataset = tickCandlesDataset.filter(d => d.timestamp > oneHourAgo);
                        
                        console.log(`ðŸ“Š Appended ${uniqueNewData.length} new tick candles, total ${tickCandlesDataset.length}`);
                        
                        // Log the new data range
                        if (tickCandlesDataset.length > 0) {
                            const firstDs = tickCandlesDataset[0].timestamp;
                            const lastDs = tickCandlesDataset[tickCandlesDataset.length - 1].timestamp;
                            console.log(`ðŸ“Š Dataset now spans: ${firstDs.toISOString()} to ${lastDs.toISOString()}`);
                        }
                        
                        // Note: Granular charts calculate signals independently, so no cache rebuild needed
                    } else {
                        console.log('âœ“ No new unique tick candles to append (all timestamps already exist)');
                    }
                } else {
                    tickCandlesDataset = mappedData;
                    console.log(`ðŸ“Š Loaded ${tickCandlesDataset.length} tick candles`);
                }
                
                // Update last timestamp for incremental updates
                if (tickCandlesDataset.length > 0) {
                    lastGranularTimestamp = tickCandlesDataset[tickCandlesDataset.length - 1].timestamp;
                }
                
                // Note: Granular charts calculate signals independently, so no cache rebuild needed
                // The global cache is only for minute-level data (regular charts)
                
                return mappedData;
            } catch (error) {
                console.error('âŒ Error fetching tick candles:', error);
                return [];
            }
        }
        
        // Aggregate candles into larger timeframes (e.g., 1s â†’ 30s)
        function aggregateCandles(candles, intervalSeconds) {
            if (!candles || candles.length === 0) return [];
            
            console.log(`ðŸ“Š Aggregating ${candles.length} candles into ${intervalSeconds}s intervals`);
            
            const aggregated = [];
            const intervalMs = intervalSeconds * 1000;
            
            // Sort by timestamp
            const sorted = [...candles].sort((a, b) => a.timestamp - b.timestamp);
            
            let currentBucket = [];
            let bucketStartTime = null;
            
            for (const candle of sorted) {
                const candleTime = candle.timestamp.getTime();
                
                if (!bucketStartTime) {
                    bucketStartTime = Math.floor(candleTime / intervalMs) * intervalMs;
                }
                
                const bucketEnd = bucketStartTime + intervalMs;
                
                if (candleTime < bucketEnd) {
                    currentBucket.push(candle);
                } else {
                    // Finalize current bucket
                    if (currentBucket.length > 0) {
                        aggregated.push(createAggregatedCandle(currentBucket, bucketStartTime));
                    }
                    
                    // Start new bucket
                    bucketStartTime = Math.floor(candleTime / intervalMs) * intervalMs;
                    currentBucket = [candle];
                }
            }
            
            // Finalize last bucket
            if (currentBucket.length > 0) {
                aggregated.push(createAggregatedCandle(currentBucket, bucketStartTime));
            }
            
            console.log(`âœ“ Created ${aggregated.length} aggregated candles`);

            // Debug: Log sentiment data in first aggregated candle
            if (aggregated.length > 0) {
                console.log(`   First aggregated candle sentiment: composite=${aggregated[0].sentiment}, news=${aggregated[0].news}, indicators=${aggregated[0].indicators}`);
            }

            return aggregated;
        }
        
        function createAggregatedCandle(candles, bucketStartTime) {
            const open = candles[0].open;
            const close = candles[candles.length - 1].price;
            const high = Math.max(...candles.map(c => c.high));
            const low = Math.min(...candles.map(c => c.low));
            const volume = candles.reduce((sum, c) => sum + (c.volume || 0), 0);
            const tick_count = candles.reduce((sum, c) => sum + (c.tick_count || 0), 0);

            // Average the sentiment values across all candles in this bucket
            const sentimentValues = candles.filter(c => c.sentiment != null && !isNaN(c.sentiment));
            const avgSentiment = sentimentValues.length > 0
                ? sentimentValues.reduce((sum, c) => sum + c.sentiment, 0) / sentimentValues.length
                : 0;

            const newsValues = candles.filter(c => c.news != null && !isNaN(c.news));
            const avgNews = newsValues.length > 0
                ? newsValues.reduce((sum, c) => sum + c.news, 0) / newsValues.length
                : null;

            const indicatorValues = candles.filter(c => c.indicators != null && !isNaN(c.indicators));
            const avgIndicators = indicatorValues.length > 0
                ? indicatorValues.reduce((sum, c) => sum + c.indicators, 0) / indicatorValues.length
                : null;

            return {
                timestamp: new Date(bucketStartTime),
                open,
                high,
                low,
                price: close,
                volume,
                tick_count,
                sentiment: avgSentiment,
                news: avgNews,
                indicators: avgIndicators
            };
        }
        
        // Fetch historical sentiment data for chart from dashboard endpoint
        async function fetchHistoricalData(timeframeMinutes = 240) {
            try {
                console.log('Fetching historical data from dashboard API...');
                const url = `${API_BASE_URL}/dashboard/`;
                console.log('API URL:', url);

                const response = await fetch(url);
                console.log('Response status:', response.status);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('Dashboard API response received');

                // Populate 24-hour dataset
                if (!data.historical || data.historical.length === 0) {
                    console.warn('No historical data points in API response');
                    sentimentDataset = [];
                } else {
                    sentimentDataset = data.historical.map(point => ({
                        timestamp: new Date(point.timestamp),
                        sentiment: point.composite_score,
                        price: point.price
                    }));
                    console.log('Converted 24h dataset length:', sentimentDataset.length);
                }

                // Populate 2-day dataset
                if (data.historical_2d && data.historical_2d.length > 0) {
                    sentimentDataset2d = data.historical_2d.map(point => ({
                        timestamp: new Date(point.timestamp),
                        sentiment: point.composite_score,
                        price: point.price
                    }));
                    console.log('Converted 2d dataset length:', sentimentDataset2d.length);
                } else {
                    sentimentDataset2d = [];
                }

                // Populate 3-day dataset
                if (data.historical_3d && data.historical_3d.length > 0) {
                    sentimentDataset3d = data.historical_3d.map(point => ({
                        timestamp: new Date(point.timestamp),
                        sentiment: point.composite_score,
                        price: point.price
                    }));
                    console.log('Converted 3d dataset length:', sentimentDataset3d.length);
                } else {
                    sentimentDataset3d = [];
                }

                return data;
            } catch (error) {
                console.error('Error fetching historical data:', error);
                console.error('Error details:', error.message);
                // Fallback to empty datasets
                sentimentDataset = [];
                sentimentDataset2d = [];
                sentimentDataset3d = [];
                return null;
            }
        }
        
        // Update sentiment display with real data
        function updateSentimentDisplay(data) {
            console.log('updateSentimentDisplay called with data:', data);

            let sentiment = data.composite_score;

            // Check if signal mode, news mode, weighted mode, or new composite/price modes are active (radio buttons)
            const signalModeActive = document.getElementById('scale-signal')?.checked || false;
            const newsModeActive = document.getElementById('scale-news')?.checked || false;
            const weightedModeActive = document.getElementById('scale-weighted')?.checked || false;
            const newsCompositeModeActive = document.getElementById('scale-news-composite')?.checked || false;
            const newsPriceModeActive = document.getElementById('scale-news-price')?.checked || false;
            const candleDecayModeActive = document.getElementById('scale-candle-decay')?.checked || false;
            
            // Check which eye icon is active (for driver toggles)
            const newsEyeActive = document.getElementById('eye-news')?.classList.contains('active') || false;
            const indicatorsEyeActive = document.getElementById('eye-indicators')?.classList.contains('active') || false;
            const sentimentEyeActive = document.getElementById('eye-sentiment')?.classList.contains('active') || false;
            
            if (signalModeActive && window.currentChartData && window.currentChartData.length > 0) {
                // Get the most recent data point's signal value
                const lastPoint = window.currentChartData[window.currentChartData.length - 1];
                if (lastPoint && lastPoint.signalValue != null) {
                    sentiment = lastPoint.signalValue;
                }
            } else if (weightedModeActive && window.currentChartData && window.currentChartData.length > 0) {
                // Get the most recent data point's weighted value
                const lastPoint = window.currentChartData[window.currentChartData.length - 1];
                if (lastPoint && lastPoint.weightedValue != null) {
                    sentiment = lastPoint.weightedValue;
                }
            } else if (newsCompositeModeActive && window.currentChartData && window.currentChartData.length > 0) {
                // Get the most recent data point's news composite value
                const lastPoint = window.currentChartData[window.currentChartData.length - 1];
                if (lastPoint && lastPoint.newsCompositeValue != null) {
                    sentiment = lastPoint.newsCompositeValue;
                }
            } else if (newsPriceModeActive && window.currentChartData && window.currentChartData.length > 0) {
                // Get the most recent data point's news price value
                const lastPoint = window.currentChartData[window.currentChartData.length - 1];
                if (lastPoint && lastPoint.newsPriceValue != null) {
                    sentiment = lastPoint.newsPriceValue;
                }
            } else if (candleDecayModeActive && window.currentChartData && window.currentChartData.length > 0) {
                // Get the most recent data point's candle decay value
                const lastPoint = window.currentChartData[window.currentChartData.length - 1];
                if (lastPoint && lastPoint.candleDecayValue != null) {
                    sentiment = lastPoint.candleDecayValue;
                }
            } else if (newsModeActive && window.currentChartData && window.currentChartData.length > 0) {
                // Get the most recent data point's processed news value (or fallback to regular news)
                const lastPoint = window.currentChartData[window.currentChartData.length - 1];
                if (lastPoint) {
                    sentiment = lastPoint.processedNews != null ? lastPoint.processedNews : (lastPoint.news != null ? lastPoint.news : 0);
                }
            } else if (newsEyeActive && window.currentChartData && window.currentChartData.length > 0) {
                // News eye icon is active - show news value
                const lastPoint = window.currentChartData[window.currentChartData.length - 1];
                if (lastPoint) {
                    sentiment = lastPoint.processedNews != null ? lastPoint.processedNews : (lastPoint.news != null ? lastPoint.news : 0);
                }
            } else if (indicatorsEyeActive && window.currentChartData && window.currentChartData.length > 0) {
                // Indicators eye icon is active - show indicators value
                const lastPoint = window.currentChartData[window.currentChartData.length - 1];
                if (lastPoint && lastPoint.indicators != null) {
                    sentiment = lastPoint.indicators;
                }
            } else if (sentimentEyeActive && window.currentChartData && window.currentChartData.length > 0) {
                // Sentiment eye icon is active - show sentiment value
                const lastPoint = window.currentChartData[window.currentChartData.length - 1];
                if (lastPoint && lastPoint.sentiment != null) {
                    sentiment = lastPoint.sentiment;
                }
            }

            console.log('Composite score value:', sentiment);
            const sentimentDisplay = sentiment > 0 ? `+${sentiment.toFixed(1)}` : sentiment.toFixed(1);
            console.log('Formatted sentiment display:', sentimentDisplay);

            // Update oscillator current score panel (primary display for this page)
            const oscillatorScoreElement = document.getElementById('oscillator-current-score');
            console.log('Updating oscillator score panel:', sentimentDisplay, 'Element found:', !!oscillatorScoreElement);
            if (oscillatorScoreElement) {
                oscillatorScoreElement.textContent = sentimentDisplay;
                
                // Update color based on active mode (radio buttons take priority, then eye icons)
                if (newsCompositeModeActive) {
                    oscillatorScoreElement.style.color = '#ff8c42'; // Orange for news + composite
                } else if (newsPriceModeActive) {
                    oscillatorScoreElement.style.color = '#10b981'; // Green for news + price
                } else if (candleDecayModeActive) {
                    oscillatorScoreElement.style.color = '#a855f7'; // Purple for candle-based decay
                } else if (newsModeActive || newsEyeActive) {
                    oscillatorScoreElement.style.color = '#ec4899'; // Pink for news
                } else if (signalModeActive) {
                    oscillatorScoreElement.style.color = '#ffffff'; // White for signal
                } else if (weightedModeActive) {
                    oscillatorScoreElement.style.color = '#ff8c42'; // Orange for weighted
                } else if (indicatorsEyeActive) {
                    oscillatorScoreElement.style.color = '#3b82f6'; // Blue for indicators
                } else {
                    oscillatorScoreElement.style.color = '#ff8c42'; // Orange for default composite
                }
                
                console.log('âœ… Oscillator score updated to:', sentimentDisplay);
            } else {
                console.error('âŒ oscillator-current-score element not found!');
            }

            // Update main score elements if they exist (they may be in a different page/section)
            const scoreValueElement = document.querySelector('.score-value');
            const scoreStatus = document.querySelector('.score-status');

            if (scoreValueElement && scoreStatus) {
                // Update score value
                scoreValueElement.textContent = sentimentDisplay;

                // Update status and colors based on sentiment
                if (sentiment >= 30) {
                    scoreStatus.textContent = t('dashboard.status.bullish');
                    scoreStatus.setAttribute('data-i18n', 'dashboard.status.bullish');
                    scoreStatus.style.color = '#10b981';
                    scoreValueElement.style.background = 'linear-gradient(135deg, #10b981 0%, #34d399 100%)';
                } else if (sentiment >= -30) {
                    scoreStatus.textContent = t('dashboard.status.neutral');
                    scoreStatus.setAttribute('data-i18n', 'dashboard.status.neutral');
                    scoreStatus.style.color = '#888';
                    scoreValueElement.style.background = 'linear-gradient(135deg, #888 0%, #aaa 100%)';
                } else {
                    scoreStatus.textContent = t('dashboard.status.bearish');
                    scoreStatus.setAttribute('data-i18n', 'dashboard.status.bearish');
                    scoreStatus.style.color = '#ef4444';
                    scoreValueElement.style.background = 'linear-gradient(135deg, #ef4444 0%, #f87171 100%)';
                }

                // Apply text styling
                scoreValueElement.style.webkitBackgroundClip = 'text';
                scoreValueElement.style.webkitTextFillColor = 'transparent';
                scoreValueElement.style.backgroundClip = 'text';
                console.log('âœ… Main score elements updated');
            } else {
                console.log('â„¹ï¸ Main score elements not found (may be on different page) - oscillator panel updated successfully');
            }
        }

        // Track market status globally
        let isMarketOpen = true;

        // Update market status indicator
        function updateMarketStatus(marketStatus) {
            if (!marketStatus) return;

            const indicator = document.getElementById('market-status-indicator');
            const closeTimeSpan = document.getElementById('market-close-time');

            if (!indicator || !closeTimeSpan) return;

            // Update global market status
            isMarketOpen = marketStatus.is_open;

            if (marketStatus.is_open) {
                // Market is open - hide indicator
                indicator.style.display = 'none';
            } else {
                // Market is closed - show small indicator with timestamp from latest data point
                // Find the latest timestamp from all available datasets
                let latestTimestamp = null;
                
                // Check all datasets and find the most recent timestamp
                const allDatasets = [sentimentDataset, sentimentDataset2d, sentimentDataset3d];
                for (const dataset of allDatasets) {
                    if (dataset && dataset.length > 0) {
                        // Find the latest timestamp in this dataset
                        for (const point of dataset) {
                            if (point && point.timestamp) {
                                const pointTime = point.timestamp instanceof Date ? point.timestamp : new Date(point.timestamp);
                                if (!latestTimestamp || pointTime > latestTimestamp) {
                                    latestTimestamp = pointTime;
                                }
                            }
                        }
                    }
                }
                
                // Use the latest timestamp from data, or fallback to current time
                const closeTime = latestTimestamp ? new Date(latestTimestamp) : new Date();
                const formattedTime = closeTime.toLocaleString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit',
                    timeZoneName: 'short'
                });
                closeTimeSpan.textContent = formattedTime;
                indicator.style.display = 'block';
            }
        }

        // Update sentiment drivers with real data from API
        function updateSentimentDrivers(drivers, vxnIndex, compositeScore) {
            if (!drivers) return;

            // Get driver elements
            const driverItems = document.querySelectorAll('.driver-item');

            // Convert VXN index to a sentiment score (-100 to +100)
            // VXN typically ranges from ~10 to ~40
            // Lower VXN = less volatility = more bullish
            // Higher VXN = more volatility = more bearish
            let vixScore = 0;
            if (vxnIndex) {
                // Normalize VXN: 15 is baseline (neutral), below is bullish, above is bearish
                // Scale: VXN 10 = +100, VXN 15 = 0, VXN 40 = -100
                vixScore = Math.max(-100, Math.min(100, ((15 - vxnIndex) / 15) * 100));
            }

            // Get sentiment score (composite score) - use passed parameter first, then fallbacks
            let sentimentScore = 0;
            if (compositeScore !== undefined && compositeScore !== null) {
                sentimentScore = compositeScore;
            } else if (window.currentCompositeScore !== undefined && window.currentCompositeScore !== null) {
                sentimentScore = window.currentCompositeScore;
            } else if (window.currentChartData && window.currentChartData.length > 0) {
                const lastPoint = window.currentChartData[window.currentChartData.length - 1];
                sentimentScore = lastPoint.sentiment != null ? lastPoint.sentiment : (lastPoint.composite_score != null ? lastPoint.composite_score : 0);
            }

            // Update the drivers with real data from API
            const driverData = [
                {
                    name: 'Summary',
                    translationKey: null,
                    value: sentimentScore,
                    weight: 0
                },
                {
                    name: t('dashboard.driver.news'),
                    translationKey: 'dashboard.driver.news',
                    value: drivers.news_sentiment?.score || 0,
                    weight: drivers.news_sentiment?.weight || 40
                },
                {
                    name: t('dashboard.driver.indicators'),
                    translationKey: 'dashboard.driver.indicators',
                    value: drivers.technical_indicators?.score || 0,
                    weight: drivers.technical_indicators?.weight || 30
                },
                {
                    name: t('dashboard.driver.social'),
                    translationKey: 'dashboard.driver.social',
                    value: drivers.social_media?.score || 0,
                    weight: drivers.social_media?.weight || 30
                },
                {
                    name: t('dashboard.driver.recommendations'),
                    translationKey: 'dashboard.driver.recommendations',
                    value: drivers.analyst_recommendations?.score || 0,
                    weight: drivers.analyst_recommendations?.weight || 0
                },
                {
                    name: t('dashboard.driver.vix'),
                    translationKey: 'dashboard.driver.vix',
                    value: vixScore,
                    weight: 0,
                    rawValue: vxnIndex // Store raw VXN value for display
                }
            ];

            driverData.forEach((driver, index) => {
                if (driverItems[index]) {
                    const driverItem = driverItems[index];
                    const nameElement = driverItem.querySelector('.driver-name');
                    const valueElement = driverItem.querySelector('.driver-value');
                    const progressFill = driverItem.querySelector('.progress-fill');

                    // Update name
                    if (nameElement) {
                        nameElement.textContent = driver.name;
                        // Add translation key as data attribute for future updates
                        if (driver.translationKey) {
                            nameElement.setAttribute('data-i18n', driver.translationKey);
                        }
                    }

                    // Update value with +/- sign
                    if (valueElement) {
                        // Special handling for VIX - show raw VXN value instead of normalized score
                        let displayValue;
                        if (driver.rawValue !== undefined) {
                            displayValue = driver.rawValue.toFixed(2);
                        } else {
                            displayValue = driver.value > 0 ? `+${driver.value.toFixed(1)}` : driver.value.toFixed(1);
                        }
                        valueElement.textContent = displayValue;

                        // Update color based on positive/negative
                        valueElement.classList.remove('positive', 'negative', 'neutral');
                        if (driver.value > 0) {
                            valueElement.classList.add('positive');
                        } else if (driver.value < 0) {
                            valueElement.classList.add('negative');
                        } else {
                            valueElement.classList.add('neutral');
                        }
                    }

                    // Update progress bar
                    if (progressFill) {
                        // Calculate width based on absolute value (0-100 scale)
                        // -80 and +80 both fill 80% of the bar
                        const width = Math.abs(driver.value);
                        const clampedWidth = Math.max(0, Math.min(100, width));

                        progressFill.style.width = `${clampedWidth}%`;

                        // Update color based on positive/negative
                        progressFill.classList.remove('positive', 'negative', 'neutral');
                        if (driver.value > 0) {
                            progressFill.classList.add('positive');
                        } else if (driver.value < 0) {
                            progressFill.classList.add('negative');
                        } else {
                            progressFill.classList.add('neutral');
                        }
                    }
                }
            });

            console.log('Sentiment drivers updated:', driverData);
        }
        
        // Helper function to create smooth SVG path from data points
        function createSmoothPath(points) {
            if (!points || points.length === 0) {
                console.log('No data points to create path');
                return '';
            }

            console.log('Creating path with', points.length, 'points:', points);

            // FIXED SCALE: Always use -100 to +100 range
            // This ensures 0 is always at the center (Y=50)
            const minSentiment = -100;
            const maxSentiment = 100;
            const sentimentRange = 200;

            console.log('Using fixed sentiment range: -100 to +100');

            // Convert sentiment to Y coordinate (0 to 100)
            // +100 sentiment = Y=0 (top of chart)
            // 0 sentiment = Y=50 (center line)
            // -100 sentiment = Y=100 (bottom of chart)
            const sentimentToY = (sentiment) => {
                // Map sentiment from [-100, 100] to [100, 0] (inverted Y axis)
                const y = 50 - (sentiment / 2);
                return Math.max(0, Math.min(100, y)); // Clamp between 0-100
            };

            // Start path at first point
            const x0 = 0;
            const y0 = sentimentToY(points[0].sentiment);
            let path = `M ${x0},${y0}`;

            // Create smooth curve through all points
            for (let i = 1; i < points.length; i++) {
                const x = (i / (points.length - 1)) * 100;
                const y = sentimentToY(points[i].sentiment);

                if (i === 1) {
                    // First curve - use quadratic bezier
                    const cx = x / 2;
                    const prevY = sentimentToY(points[0].sentiment);
                    path += ` Q ${cx},${prevY} ${x},${y}`;
                } else {
                    // Smooth curves using cubic bezier
                    const prevX = ((i - 1) / (points.length - 1)) * 100;
                    const prevY = sentimentToY(points[i - 1].sentiment);
                    const cx1 = prevX + (x - prevX) / 3;
                    const cy1 = prevY;
                    const cx2 = prevX + (x - prevX) * 2 / 3;
                    const cy2 = y;
                    path += ` C ${cx1},${cy1} ${cx2},${cy2} ${x},${y}`;
                }
            }

            console.log('Generated SVG path:', path);
            return path;
        }
        
        // Helper function to format time labels in HH:MM:SS format based on selected timezone
        function formatTimeLabel(minutesAgo) {
            const now = new Date();
            // Calculate the time by subtracting minutes
            const pastTime = new Date(now.getTime() - (minutesAgo * 60000));
            
            // Apply timezone offset if a timezone is selected
            let targetTime = pastTime;
            if (currentTimezoneData) {
                const offsetHours = parseOffset(currentTimezoneData.offset);
                const utc = pastTime.getTime() + (pastTime.getTimezoneOffset() * 60000);
                targetTime = new Date(utc + (3600000 * offsetHours));
            }
            
            const hours = String(targetTime.getHours()).padStart(2, '0');
            const minutes = String(targetTime.getMinutes()).padStart(2, '0');
            const seconds = String(targetTime.getSeconds()).padStart(2, '0');
            
            return `${hours}:${minutes}:${seconds}`;
        }
        
        // Timeframe configurations - how many minutes of data to show
        const timeframeConfig = {
            '1m': {
                minutes: 1,   // Show last 1 minute of data
                labelCount: 5,
                label: '1min',
                dataset: 'sentimentDataset',
                supportsGranular: true,  // Can use granular data if toggle is enabled
                candleSize: 1,  // 1-second candles
                updateInterval: 1000  // Update every 1 second (1000ms)
            },
            '5m': {
                minutes: 5,   // Show last 5 minutes of data
                labelCount: 5,
                label: '5min',
                dataset: 'sentimentDataset',
                supportsGranular: true,
                candleSize: 5,  // 5-second candles
                updateInterval: 5000  // Update every 5 seconds (5000ms)
            },
            '15m': {
                minutes: 15,  // Show last 15 minutes
                labelCount: 5,
                label: '15min',
                dataset: 'sentimentDataset',
                supportsGranular: true,
                candleSize: 5,  // 5-second candles
                updateInterval: 5000  // Update every 5 seconds (5000ms)
            },
            '30m': {
                minutes: 30,  // Show last 30 minutes
                labelCount: 6,
                label: '30min',
                dataset: 'sentimentDataset',
                supportsGranular: true,
                candleSize: 30,  // 30-second candles
                updateInterval: 30000  // Update every 30 seconds (30000ms)
            },
            '1h': {
                minutes: 60,  // Show last 1 hour
                labelCount: 5,
                label: '1hr',
                dataset: 'sentimentDataset',
                supportsGranular: true,
                candleSize: 30,  // 30-second candles
                updateInterval: 30000  // Update every 30 seconds (30000ms)
            },
            '2h': {
                minutes: 120, // Show last 2 hours
                labelCount: 6,
                label: '2hrs',
                dataset: 'sentimentDataset'
            },
            '4h': {
                minutes: 240, // Show last 4 hours
                labelCount: 6,
                label: '4hrs',
                dataset: 'sentimentDataset'
            },
            '6h': {
                minutes: 360, // Show last 6 hours (trading session)
                labelCount: 6,
                label: 'Session',
                dataset: 'sentimentDataset'
            },
            '2d': {
                minutes: 2880, // Show last 48 hours (2 days)
                labelCount: 8,
                label: '2days',
                dataset: 'sentimentDataset2d'
            },
            '3d': {
                minutes: 4320, // Show last 72 hours (3 days)
                labelCount: 10,
                label: '3days',
                dataset: 'sentimentDataset3d'
            }
        };

        function getDataForTimeframe(timeframe, scrollPos = 100) {
            const config = timeframeConfig[timeframe];
            console.log(`\n=== Getting data for ${timeframe} (last ${config.minutes} minutes, scroll: ${scrollPos}%) ===`);

            // Select the appropriate dataset based on timeframe
            let activeDataset;
            let usingGranularData = false;
            let rawGranularDataset = null; // Store raw dataset before aggregation
            
            // Try to use granular data if:
            // 1. Timeframe supports granular data
            // 2. Granular dataset has data
            // 3. User has interacted with the toggle (granular data was fetched)
            if (config.supportsGranular) {
                const granularDataset = granularDataType === 'second' ? secondCandlesDataset : tickCandlesDataset;
                
                if (granularDataset.length > 0) {
                    console.log(`âœ… Using ${granularDataType} candles dataset (${granularDataset.length} points)`);
                    usingGranularData = true;

                    // Aggregate for longer timeframes to reduce point count
                    if (granularDataType === 'second') {
                        if (timeframe === '1h') {
                            // 1-hour timeframe: use 30-second candles
                            rawGranularDataset = granularDataset; // Store reference to raw data
                            activeDataset = aggregateCandles([...granularDataset], 30);
                            console.log(`ðŸ“Š Aggregated to 30s candles: ${activeDataset.length} points`);
                        } else if (timeframe === '30m') {
                            // 30-minute timeframe: use 30-second candles
                            rawGranularDataset = granularDataset; // Store reference to raw data
                            activeDataset = aggregateCandles([...granularDataset], 30);
                            console.log(`ðŸ“Š Aggregated to 30s candles: ${activeDataset.length} points`);
                        } else if (timeframe === '15m') {
                            // 15-minute timeframe: use 5-second candles
                            rawGranularDataset = granularDataset; // Store reference to raw data
                            activeDataset = aggregateCandles([...granularDataset], 5);
                            console.log(`ðŸ“Š Aggregated to 5s candles: ${activeDataset.length} points`);
                        } else if (timeframe === '5m') {
                            // 5-minute timeframe: use 5-second candles
                            rawGranularDataset = granularDataset; // Store reference to raw data
                            activeDataset = aggregateCandles([...granularDataset], 5);
                            console.log(`ðŸ“Š Aggregated to 5s candles: ${activeDataset.length} points`);
                        } else {
                            // For 1m or any other second-based timeframe: full 1-second resolution (no aggregation)
                            // IMPORTANT: secondCandlesDataset is sorted DESCENDING (newest first)
                            // But other timeframes use aggregateCandles() which sorts ASCENDING
                            // We need to reverse it to match the expected order for scrollback
                            rawGranularDataset = granularDataset;
                            activeDataset = [...granularDataset].reverse(); // Reverse to ascending (oldest first)
                            console.log(`ðŸ“Š Using 1s candles (no aggregation, reversed to ascending): ${activeDataset.length} points for ${timeframe}`);
                        }
                    } else {
                        // For tick data, no aggregation needed
                        rawGranularDataset = granularDataset;
                        activeDataset = granularDataset;
                    }
                } else {
                    // Fallback to regular dataset if granular data not available
                    console.log('âš ï¸ Granular data not available, using regular sentimentDataset as fallback');
                    activeDataset = sentimentDataset;
                }
            } else if (config.dataset === 'sentimentDataset2d') {
                activeDataset = sentimentDataset2d;
                console.log('Using 2-day dataset');
            } else if (config.dataset === 'sentimentDataset3d') {
                activeDataset = sentimentDataset3d;
                console.log('Using 3-day dataset');
            } else {
                activeDataset = sentimentDataset;
                console.log('Using 24-hour dataset');
            }

            console.log('Total dataset length:', activeDataset.length);

            if (!activeDataset || activeDataset.length === 0) {
                console.log('âŒ No sentiment data available for this timeframe');
                return { labels: [], path: '', dataPoints: [], count: 0 };
            }

            // Calculate cutoff time
            // When market is closed, use the last data point's time as "now"
            // When market is open, use current time
            const now = isMarketOpen
                ? new Date()
                : (activeDataset.length > 0 ? new Date(activeDataset[activeDataset.length - 1].timestamp) : new Date());

            let cutoffTime;
            let endTime; // For Session timeframe or scroll window end time

            // Helper function to convert ET time to UTC
            const etToUTC = (year, month, day, hour, minute) => {
                const isoStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}T${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}:00`;
                let testUTC = new Date(isoStr + '-05:00');
                let etParts = new Intl.DateTimeFormat('en-US', {
                    timeZone: 'America/New_York',
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                }).formatToParts(testUTC);

                let matches = parseInt(etParts.find(p => p.type === 'year').value) === year &&
                             parseInt(etParts.find(p => p.type === 'month').value) === (month + 1) &&
                             parseInt(etParts.find(p => p.type === 'day').value) === day &&
                             parseInt(etParts.find(p => p.type === 'hour').value) === hour &&
                             parseInt(etParts.find(p => p.type === 'minute').value) === minute;

                if (!matches) {
                    testUTC = new Date(isoStr + '-04:00');
                }

                return testUTC;
            };

            // Get current date in Eastern Time
            const etFormatter = new Intl.DateTimeFormat('en-US', {
                timeZone: 'America/New_York',
                year: 'numeric',
                month: '2-digit',
                day: '2-digit'
            });

            const parts = etFormatter.formatToParts(now);
            const etYear = parseInt(parts.find(p => p.type === 'year').value);
            const etMonth = parseInt(parts.find(p => p.type === 'month').value) - 1;
            const etDay = parseInt(parts.find(p => p.type === 'day').value);

            // Special handling for Session (6h), 2-day, and 3-day timeframes
            if (timeframe === '6h') {
                // Session: Show current trading day only
                cutoffTime = etToUTC(etYear, etMonth, etDay, 9, 30);
                endTime = etToUTC(etYear, etMonth, etDay, 16, 0);

                console.log('Session timeframe: Current trading day');
                console.log('Market open (9:30 AM ET):', cutoffTime.toISOString());
                console.log('Market close (4:00 PM ET):', endTime.toISOString());
            } else if (timeframe === '2d') {
                // 2-day: Show last 2 complete trading days (yesterday + today)
                const yesterday = new Date(etYear, etMonth, etDay);
                yesterday.setDate(yesterday.getDate() - 1);
                const yParts = etFormatter.formatToParts(yesterday);
                const yYear = parseInt(yParts.find(p => p.type === 'year').value);
                const yMonth = parseInt(yParts.find(p => p.type === 'month').value) - 1;
                const yDay = parseInt(yParts.find(p => p.type === 'day').value);

                cutoffTime = etToUTC(yYear, yMonth, yDay, 9, 30);
                endTime = isMarketOpen ? now : etToUTC(etYear, etMonth, etDay, 16, 0);

                console.log('2-day timeframe: From', cutoffTime.toISOString(), 'to', endTime.toISOString());
            } else if (timeframe === '3d') {
                // 3-day: Show last 3 complete trading days
                const twoDaysAgo = new Date(etYear, etMonth, etDay);
                twoDaysAgo.setDate(twoDaysAgo.getDate() - 2);
                const tParts = etFormatter.formatToParts(twoDaysAgo);
                const tYear = parseInt(tParts.find(p => p.type === 'year').value);
                const tMonth = parseInt(tParts.find(p => p.type === 'month').value) - 1;
                const tDay = parseInt(tParts.find(p => p.type === 'day').value);

                cutoffTime = etToUTC(tYear, tMonth, tDay, 9, 30);
                endTime = isMarketOpen ? now : etToUTC(etYear, etMonth, etDay, 16, 0);

                console.log('3-day timeframe: From', cutoffTime.toISOString(), 'to', endTime.toISOString());
            } else {
                // Regular timeframes: scrollable window within today's data
                const marketOpenTime = etToUTC(etYear, etMonth, etDay, 9, 30);

                // Calculate the window end time based on scroll position
                // scrollPos = 100 means endTime = now (most recent)
                // scrollPos = 0 means endTime = marketOpenTime + window size
                const windowSizeMs = config.minutes * 60 * 1000;
                
                // If using granular seconds, ensure we respect proper window calculation for all granular timeframes
                if (usingGranularData && granularDataType === 'second' && (timeframe === '1m' || timeframe === '5m' || timeframe === '15m' || timeframe === '30m' || timeframe === '1h')) {
                    // CRITICAL: Use activeDataset (aggregated) timestamps for BOTH calculation AND filtering
                    // This prevents timestamp mismatch between window calculation and data filtering
                    const latestDataTime = activeDataset.length > 0
                        ? activeDataset[activeDataset.length - 1].timestamp
                        : new Date();

                    const oldestDataTime = activeDataset.length > 0
                        ? activeDataset[0].timestamp
                        : new Date();

                    console.log(`ðŸ” Active dataset range: ${oldestDataTime.toISOString()} to ${latestDataTime.toISOString()}`);
                    console.log(`ðŸ” Active dataset size: ${activeDataset.length} candles`);

                    if (scrollPos >= 100) {
                        // When viewing live data and market is open, use current time
                        // This ensures the window slides forward in real-time
                        if (isMarketOpen) {
                            endTime = now; // Use current time for live updates
                            cutoffTime = new Date(endTime.getTime() - windowSizeMs);
                            console.log(`ðŸ“ Live mode: window from ${cutoffTime.toISOString()} to ${endTime.toISOString()}`);
                        } else {
                            // Market closed: window ends at latest data
                            endTime = latestDataTime;
                            cutoffTime = new Date(endTime.getTime() - windowSizeMs);
                            console.log(`ðŸ“ Replay mode: window from ${cutoffTime.toISOString()} to ${endTime.toISOString()}`);
                        }
                    } else {
                        // Scrolling back - use sliding window approach like standard timeframes
                        console.log(`ðŸ“œ Scrollback mode: data range from ${oldestDataTime.toISOString()} to ${latestDataTime.toISOString()}`);

                        // Calculate the scrollable range (same logic as standard timeframes)
                        const availableDataRangeMs = latestDataTime.getTime() - oldestDataTime.getTime();
                        const maxScrollRangeMs = availableDataRangeMs - windowSizeMs;

                        if (maxScrollRangeMs > 0) {
                            // Sliding window: both cutoffTime and endTime move based on scroll position
                            const scrollFraction = scrollPos / 100;
                            endTime = new Date(oldestDataTime.getTime() + windowSizeMs + (scrollFraction * maxScrollRangeMs));
                            cutoffTime = new Date(endTime.getTime() - windowSizeMs);
                            console.log(`ðŸ“ Scrollback ${scrollPos}%: window from ${cutoffTime.toISOString()} to ${endTime.toISOString()}`);
                        } else {
                            // Not enough data for a full window, show everything we have
                            cutoffTime = oldestDataTime;
                            endTime = latestDataTime;
                            console.log(`ðŸ“ Showing all available data: ${cutoffTime.toISOString()} to ${endTime.toISOString()}`);
                        }
                    }
                } else {
                    // Standard logic for other timeframes
                    const maxScrollRangeMs = now.getTime() - marketOpenTime.getTime() - windowSizeMs;

                    if (maxScrollRangeMs > 0) {
                        // Calculate end time based on scroll position (inverse: 100 = now, 0 = earliest)
                        const scrollFraction = scrollPos / 100;
                        endTime = new Date(marketOpenTime.getTime() + windowSizeMs + (scrollFraction * maxScrollRangeMs));
                        cutoffTime = new Date(endTime.getTime() - windowSizeMs);
                    } else {
                        // Not enough data for scrolling, just show what we have
                        cutoffTime = marketOpenTime;
                        endTime = now;
                    }
                }
            }

            console.log('Cutoff time:', cutoffTime.toISOString());
            if (endTime) console.log('End time:', endTime.toISOString());
            console.log('Reference time (now):', now.toISOString());
            console.log('Market status:', isMarketOpen ? 'OPEN' : 'CLOSED');

            // For stable NASDAQ scaling, first get ALL data for the entire timeframe (before scroll window)
            // This prevents the price line from jumping as you scroll
            let fullTimeframeData;
            if (timeframe === '6h' || timeframe === '2d' || timeframe === '3d') {
                // For fixed timeframes, use the full range
                const fullCutoffTime = timeframe === '6h' ? etToUTC(etYear, etMonth, etDay, 9, 30)
                    : timeframe === '2d' ? (() => {
                        const yesterday = new Date(etYear, etMonth, etDay);
                        yesterday.setDate(yesterday.getDate() - 1);
                        const yParts = etFormatter.formatToParts(yesterday);
                        return etToUTC(parseInt(yParts.find(p => p.type === 'year').value),
                                      parseInt(yParts.find(p => p.type === 'month').value) - 1,
                                      parseInt(yParts.find(p => p.type === 'day').value), 9, 30);
                    })()
                    : (() => {
                        const twoDaysAgo = new Date(etYear, etMonth, etDay);
                        twoDaysAgo.setDate(twoDaysAgo.getDate() - 2);
                        const tParts = etFormatter.formatToParts(twoDaysAgo);
                        return etToUTC(parseInt(tParts.find(p => p.type === 'year').value),
                                      parseInt(tParts.find(p => p.type === 'month').value) - 1,
                                      parseInt(tParts.find(p => p.type === 'day').value), 9, 30);
                    })();
                const fullEndTime = isMarketOpen ? now : etToUTC(etYear, etMonth, etDay, 16, 0);
                fullTimeframeData = activeDataset.filter(d => d.timestamp >= fullCutoffTime && d.timestamp <= fullEndTime);
            } else {
                // For scrollable timeframes, get all data from market open today
                const marketOpenTime = etToUTC(etYear, etMonth, etDay, 9, 30);
                fullTimeframeData = activeDataset.filter(d => d.timestamp >= marketOpenTime && d.timestamp <= now);
            }

            // Calculate price range from FULL timeframe data (not scroll window)
            const pricesInFullTimeframe = fullTimeframeData.filter(d => d.price != null && !isNaN(d.price)).map(d => d.price);
            let priceRange = null;
            if (pricesInFullTimeframe.length > 0) {
                const sortedPrices = [...pricesInFullTimeframe].sort((a, b) => a - b);
                const medianPrice = sortedPrices.length % 2 === 0
                    ? (sortedPrices[sortedPrices.length / 2 - 1] + sortedPrices[sortedPrices.length / 2]) / 2
                    : sortedPrices[Math.floor(sortedPrices.length / 2)];
                priceRange = {
                    median: medianPrice,
                    min: Math.min(...pricesInFullTimeframe),
                    max: Math.max(...pricesInFullTimeframe)
                };
                console.log(`ðŸ“Š Full timeframe price range - Median: $${medianPrice.toFixed(2)}, Range: $${priceRange.min.toFixed(2)} - $${priceRange.max.toFixed(2)}`);
            }

            // Filter data points within the timeframe using actual timestamps
            let filteredData;
            if (endTime) {
                // Use the calculated time window
                filteredData = activeDataset.filter(d => d.timestamp >= cutoffTime && d.timestamp <= endTime);
            } else {
                filteredData = activeDataset.filter(d => d.timestamp >= cutoffTime);
            }
            console.log('âœ“ Filtered data points:', filteredData.length);

            // Check if we have enough data
            if (filteredData.length < 3) {
                console.log('âš ï¸  Not enough data points in window:', filteredData.length);
                
                // FALLBACK: If we're in live mode but have no data in the current window,
                // it means the backend hasn't saved new data recently.
                // Show the most recent data aligned to the right edge of the window.
                if (usingGranularData && scrollPos >= 100 && activeDataset.length >= 3) {
                    console.log('ðŸ“Š Fallback: Aligning most recent data to right edge of window');
                    
                    // Calculate window duration
                    const windowDurationMs = endTime.getTime() - cutoffTime.getTime();
                    const windowDurationSeconds = windowDurationMs / 1000;
                    
                    // Find the most recent data point
                    const latestDataPoint = activeDataset[activeDataset.length - 1];
                    const latestTimestamp = latestDataPoint.timestamp.getTime();
                    
                    // Calculate how much data we need (window duration)
                    // Get data points that fit within the window duration, ending at the latest data point
                    const windowStartTime = latestTimestamp - windowDurationMs;
                    
                    // Filter data to fit within the window duration, ending at latest data point
                    filteredData = activeDataset.filter(d => {
                        const dTime = d.timestamp.getTime();
                        return dTime >= windowStartTime && dTime <= latestTimestamp;
                    });
                    
                    // If we don't have enough data to fill the window, take the most recent data we have
                    if (filteredData.length < 3) {
                        // Calculate expected candles based on timeframe duration and candle size
                        // For aggregated data, we need fewer candles (e.g., 30s candles for 1h = 120 candles)
                        const candleSizeSeconds = config.candleSize || 1; // Default to 1-second if not specified
                        const expectedCandles = Math.min((config.minutes * 60) / candleSizeSeconds, 300);
                        filteredData = activeDataset.slice(-Math.ceil(expectedCandles));
                    }
                    
                    // The gap between latestTimestamp and endTime will create a visible gap on the right
                    // This gap grows each second as endTime advances, showing the window is moving
                    const gapSeconds = (endTime.getTime() - latestTimestamp) / 1000;
                    console.log(`ðŸ“Š Using ${filteredData.length} candles ending at ${new Date(latestTimestamp).toISOString()}`);
                    console.log(`ðŸ“Š Gap to window end: ${gapSeconds.toFixed(1)} seconds (window moves forward)`);
                } else {
                    return {
                        labels: [],
                        path: '',
                        dataPoints: [],
                        count: filteredData.length,
                        error: 'Not enough data - need at least 3 data points'
                    };
                }
            }

            // Sort by timestamp (oldest first for left-to-right chart)
            filteredData.sort((a, b) => a.timestamp - b.timestamp);

            const firstPoint = filteredData[0];
            const lastPoint = filteredData[filteredData.length - 1];
            console.log(`ðŸ“Š Displaying ${filteredData.length} candles:`);
            console.log(`   First: ${firstPoint.timestamp.toISOString()} (price: $${firstPoint.price})`);
            console.log(`   Last:  ${lastPoint.timestamp.toISOString()} (price: $${lastPoint.price})`);
            
            // Calculate time span
            const timeSpanSeconds = (lastPoint.timestamp - firstPoint.timestamp) / 1000;
            console.log(`   Span:  ${timeSpanSeconds} seconds (${(timeSpanSeconds / 60).toFixed(1)} minutes)`);

            // Detect market gaps (periods longer than 1 hour between data points)
            const gaps = [];
            for (let i = 1; i < filteredData.length; i++) {
                const timeDiff = (filteredData[i].timestamp - filteredData[i - 1].timestamp) / (1000 * 60); // minutes
                if (timeDiff > 60) { // Gap longer than 1 hour indicates market close
                    gaps.push({
                        index: i,
                        duration: timeDiff,
                        start: filteredData[i - 1].timestamp,
                        end: filteredData[i].timestamp
                    });
                    console.log(`ðŸ“Š Detected market gap: ${Math.round(timeDiff / 60)}h between ${filteredData[i - 1].timestamp.toLocaleString()} and ${filteredData[i].timestamp.toLocaleString()}`);
                }
            }

            // Use ALL data points for the chart path (smooth line)
            // Add 2% margin on each side to prevent edge clipping
            const allPoints = filteredData.map((d, index) => ({
                x: 2 + (index / (filteredData.length - 1)) * 96,
                sentiment: d.sentiment,
                price: d.price,
                open: d.open,
                high: d.high,
                low: d.low,
                volume: d.volume,
                news: d.news,
                indicators: d.indicators,
                timestamp: d.timestamp,
                timeLabel: d.timestamp.toLocaleTimeString('en-US', {
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                })
            }));

            // Select evenly spaced points for X-axis labels
            const labelIndices = [];
            const step = (filteredData.length - 1) / (config.labelCount - 1);
            for (let i = 0; i < config.labelCount; i++) {
                const index = Math.round(i * step);
                labelIndices.push(Math.min(index, filteredData.length - 1));
            }

            // Helper function to format timestamp with timezone support
            const formatTimestampLabel = (timestamp) => {
                let displayTime = timestamp;

                // Apply timezone offset if selected
                if (currentTimezoneData) {
                    const offsetHours = parseOffset(currentTimezoneData.offset);
                    const utc = timestamp.getTime() + (timestamp.getTimezoneOffset() * 60000);
                    displayTime = new Date(utc + (3600000 * offsetHours));
                }

                return displayTime.toLocaleTimeString('en-US', {
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                });
            };

            // Generate labels from selected indices
            const labels = [];
            labelIndices.forEach(index => {
                const point = filteredData[index];
                labels.push(formatTimestampLabel(point.timestamp));
            });

            console.log('âœ“ Generated', allPoints.length, 'data points for path,', labels.length, 'labels for X-axis');

            // Generate smooth path using ALL data points
            const path = createSmoothPath(allPoints);

            // Calculate min/max price from FULL day's data for consistent scaling
            // This prevents Y-axis from changing as you scroll
            const fullDayPrices = fullTimeframeData.filter(d => d.price != null && !isNaN(d.price)).map(d => d.price);
            const minPrice = fullDayPrices.length > 0 ? Math.min(...fullDayPrices) : 0;
            const maxPrice = fullDayPrices.length > 0 ? Math.max(...fullDayPrices) : 0;

            console.log(`ðŸ“Š Full day price range: $${minPrice.toFixed(2)} to $${maxPrice.toFixed(2)}`);

            // priceRange was already calculated above from fullTimeframeData

            return {
                labels,
                path,
                dataPoints: allPoints,
                gaps: gaps,
                count: allPoints.length,
                timeRange: `${config.label} (${allPoints.length} points)`,
                minPrice,
                maxPrice,
                priceRange,
                usingGranularData: usingGranularData, // Flag to indicate if using granular data
                fullTimeframeData: fullTimeframeData.map((d, index) => ({
                    x: 2 + (index / (fullTimeframeData.length - 1)) * 96,
                    sentiment: d.sentiment,
                    price: d.price,
                    news: d.news,
                    indicators: d.indicators,
                    timestamp: d.timestamp
                }))
            };
        }
        
        // Process news movements to create a separate tracking line
        // This line tracks BOTH upward movements (> 0.01) and downward movements (<= -5.0)
        // When news moves by X points, the line moves by X points (adds/subtracts from current position)
        // The line holds at the new position for 15 minutes (NO DECAY during hold), then decays exponentially to zero over 30 minutes
        // If a new movement occurs during the hold/decay period, reset the timer and add/subtract the movement
        // initialValue: Optional starting value (for granular data to inherit from minute-level)
        function processNewsScoresWithHoldDecay(dataPoints, initialValue = null) {
            try {
                if (!dataPoints || dataPoints.length === 0) {
                    console.warn('âš ï¸ processNewsScoresWithHoldDecay: No data points provided');
                    return dataPoints;
                }
                
                console.log('ðŸ”„ Processing news movements for separate tracking line...');
                console.log(`   Total data points: ${dataPoints.length}`);
                
                // Check how many points have news data
                const pointsWithNews = dataPoints.filter(p => p.news != null && !isNaN(p.news));
                console.log(`   Points with news data: ${pointsWithNews.length}`);
                
                if (pointsWithNews.length === 0) {
                    console.warn('âš ï¸ No points with news data found - cannot process');
                    // Set processedNews to 0 for all points
                    dataPoints.forEach(point => {
                        point.processedNews = 0;
                    });
                    return dataPoints;
                }
                
                // Sort points by timestamp (oldest to newest) to process chronologically
                const timestampToDataPoint = new Map();
                dataPoints.forEach(dp => {
                    if (dp.timestamp) {
                        timestampToDataPoint.set(dp.timestamp.getTime(), dp);
                    }
                });
                const sortedPoints = [...dataPoints].sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
                
                // Helper function to clamp values to [-100, 100]
                const clampValue = (value) => Math.min(100, Math.max(-100, value));
                
                // Track the separate line state
                // If initialValue is provided (for granular data), start with that value
                let currentLineValue = initialValue != null ? clampValue(initialValue) : 0; // Current value of the separate tracking line (clamped to [-100, 100])
                let movementTimestamp = null; // When the last movement occurred
                let lastNewsValue = null; // Last news value to detect changes
                
                // If we have an initial value, initialize all points before first movement to that value
                if (initialValue != null) {
                    console.log(`   ðŸ“Œ Starting with inherited value: ${initialValue.toFixed(2)}`);
                }
                
                const HOLD_DURATION_MS = 15 * 60 * 1000; // 15 minutes hold
                const DECAY_DURATION_MS = 30 * 60 * 1000; // 30 minutes decay to zero
                const TOTAL_DURATION_MS = HOLD_DURATION_MS + DECAY_DURATION_MS; // 45 minutes total
                
                // Calculate exponential decay factor: value should approach zero after 30 minutes
                // Formula: value(t) = initialValue * e^(-k * t)
                // At t=30min, we want value â‰ˆ 0.001 * initialValue (0.1% remaining)
                // So: e^(-k * 30) â‰ˆ 0.001
                // -k * 30 = ln(0.001) â‰ˆ -6.908
                // k â‰ˆ 0.2303 per minute
                const DECAY_RATE = 0.2303; // Per minute decay rate
                
                let movementsDetected = 0;
                
                // Process each point chronologically
                for (let i = 0; i < sortedPoints.length; i++) {
                    const point = sortedPoints[i];
                    const pointTime = point.timestamp.getTime();
                    const currentNewsValue = point.news;
                    
                    // Initialize processedNews for all points
                    if (point.processedNews === undefined) {
                        point.processedNews = 0;
                    }
                    
                    // Skip points without news data - keep line value unchanged
                    if (currentNewsValue == null || isNaN(currentNewsValue)) {
                        // If we have an active movement, continue decay/hold logic
                        if (movementTimestamp !== null) {
                            const timeSinceMovement = pointTime - movementTimestamp;
                            
                            if (timeSinceMovement < HOLD_DURATION_MS) {
                                // Still holding - clamp to [-100, 100]
                                point.processedNews = clampValue(currentLineValue);
                            } else if (timeSinceMovement < TOTAL_DURATION_MS) {
                                // In decay period - start from clamped value
                                const clampedLineValue = clampValue(currentLineValue);
                                const minutesSinceDecayStart = (timeSinceMovement - HOLD_DURATION_MS) / (60 * 1000);
                                // Exponential decay: value(t) = initialValue * e^(-decayRate * t)
                                // Works for both positive and negative values
                                const decayedValue = clampedLineValue * Math.exp(-DECAY_RATE * minutesSinceDecayStart);
                                point.processedNews = clampValue(Math.abs(decayedValue) < 0.01 ? 0 : decayedValue);
                        } else {
                                // Decay complete - line is at zero
                                point.processedNews = 0;
                                currentLineValue = 0;
                                movementTimestamp = null;
                            }
                        } else {
                            // No active movement - use initial value if provided, otherwise stay at zero
                            point.processedNews = initialValue != null ? clampValue(initialValue) : 0;
                        }
                            continue;
                        }
                        
                    // Detect news movement by comparing with last news value
                    // Track BOTH upward movements (> 0.01) and downward movements (<= -5.0)
                    let newsMovement = 0;
                    let isUpwardMovement = false;
                    let isDownwardMovement = false;
                    if (lastNewsValue !== null && !isNaN(lastNewsValue)) {
                        newsMovement = currentNewsValue - lastNewsValue;
                        isUpwardMovement = newsMovement > 0.01; // Track upward movements
                        isDownwardMovement = newsMovement <= -5.0; // Track downward movements >= 5 points
                    }
                    
                    // Check if we have an active movement
                    if (movementTimestamp !== null) {
                        const timeSinceMovement = pointTime - movementTimestamp;
                        
                        // Calculate current displayed value (for potential new movement)
                        // IMPORTANT: currentLineValue should already be clamped, but ensure decay starts from clamped value
                        let currentDisplayValue;
                        if (timeSinceMovement < HOLD_DURATION_MS) {
                            // HOLD PERIOD - no decay, maintain value (clamped)
                            currentDisplayValue = clampValue(currentLineValue);
                        } else if (timeSinceMovement < TOTAL_DURATION_MS) {
                            // DECAY PERIOD - exponential decay after hold
                            // Start decay from clamped value (if was at +100, decay from +100; if -50, decay from -50)
                            const clampedLineValue = clampValue(currentLineValue);
                            const minutesSinceDecayStart = (timeSinceMovement - HOLD_DURATION_MS) / (60 * 1000);
                            // Exponential decay: value(t) = initialValue * e^(-decayRate * t)
                            // Works for both positive and negative values
                            currentDisplayValue = clampedLineValue * Math.exp(-DECAY_RATE * minutesSinceDecayStart);
                            if (Math.abs(currentDisplayValue) < 0.01) currentDisplayValue = 0;
                            // Clamp during decay too
                            currentDisplayValue = clampValue(currentDisplayValue);
                                    } else {
                            // Decay complete - line is at zero
                            currentDisplayValue = 0;
                        }
                        
                        // If there's a new movement (upward or downward), reset and apply it
                        if (isUpwardMovement || isDownwardMovement) {
                            // New movement detected - add/subtract movement to/from current displayed value and reset timer
                            movementsDetected++;
                            // Add the movement (negative numbers will subtract)
                            currentLineValue = clampValue(currentDisplayValue + newsMovement);
                            movementTimestamp = pointTime; // Reset timer
                            
                            const direction = isUpwardMovement ? 'UP' : 'DOWN';
                            console.log(`   ðŸ“ˆ Movement #${movementsDetected} (${direction}) detected at ${new Date(pointTime).toISOString()}: news change=${newsMovement > 0 ? '+' : ''}${newsMovement.toFixed(2)}, line value=${currentLineValue.toFixed(2)}, resetting 15min hold`);
                            
                            point.processedNews = currentLineValue;
                            lastNewsValue = currentNewsValue;
                            continue;
                        }
                        
                        // No new movement - continue hold/decay logic
                        // Clamp the displayed value to [-100, 100]
                        point.processedNews = clampValue(currentDisplayValue);
                        
                        // Reset state if decay complete
                        if (timeSinceMovement >= TOTAL_DURATION_MS) {
                            currentLineValue = 0;
                            movementTimestamp = null;
                        }
                    } else {
                        // No active movement - check for new movement (upward or downward)
                        if (isUpwardMovement || isDownwardMovement) {
                            // Initial movement detected
                            movementsDetected++;
                            // If we have an initial value, add/subtract movement from it; otherwise set to movement amount
                            if (initialValue != null) {
                                currentLineValue = clampValue(initialValue + newsMovement);
                            } else {
                                currentLineValue = clampValue(newsMovement);
                            }
                            movementTimestamp = pointTime;
                            
                            const direction = isUpwardMovement ? 'UP' : 'DOWN';
                            console.log(`   ðŸ“ˆ Initial movement #${movementsDetected} (${direction}) detected at ${new Date(pointTime).toISOString()}: news change=${newsMovement > 0 ? '+' : ''}${newsMovement.toFixed(2)}, line value=${currentLineValue.toFixed(2)}, starting 15min hold`);
                            
                            point.processedNews = currentLineValue;
                        } else {
                            // No movement - use initial value if provided, otherwise stay at zero
                            point.processedNews = initialValue != null ? clampValue(initialValue) : 0;
                        }
                    }
                    
                    lastNewsValue = currentNewsValue;
                }
                
                console.log(`   âœ… Processing complete. Detected ${movementsDetected} movements.`);
                
                // Update all dataPoints with processedNews values
                sortedPoints.forEach(processedPoint => {
                    if (processedPoint.timestamp) {
                        const ts = processedPoint.timestamp.getTime();
                        const originalPoint = timestampToDataPoint.get(ts);
                        if (originalPoint) {
                            originalPoint.processedNews = processedPoint.processedNews;
                        }
                    }
                });
                
                return dataPoints;
            } catch (error) {
                console.error('âŒ Error in processNewsScoresWithHoldDecay:', error);
                console.error('Stack trace:', error.stack);
                // Set processedNews to 0 for all points on error
                dataPoints.forEach(point => {
                    if (point.processedNews === undefined) {
                        point.processedNews = 0;
                    }
                });
                return dataPoints;
            }
        }

        // Process candle-based decay mode (9th view)
        // News up signals add to value (hold indefinitely until 3 consecutive red candles trigger decay)
        // Technical drops (2Ã—) subtract 25 points
        // 3 consecutive green candles (when negative) trigger decay back to zero
        function processCandleBasedDecay(dataPoints, initialValue = null) {
            try {
                if (!dataPoints || dataPoints.length === 0) {
                    console.warn('âš ï¸ processCandleBasedDecay: No data points provided');
                    return dataPoints;
                }

                console.log('ðŸ”„ Processing candle-based decay mode...');
                console.log(`   Total data points: ${dataPoints.length}`);

                // Sort points by timestamp (oldest to newest)
                const timestampToDataPoint = new Map();
                dataPoints.forEach(dp => {
                    if (dp.timestamp) {
                        timestampToDataPoint.set(dp.timestamp.getTime(), dp);
                    }
                });
                const sortedPoints = [...dataPoints].sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());

                // Helper function to clamp values to [-100, 100]
                const clampValue = (value) => Math.min(100, Math.max(-100, value));

                // Constants
                const RAMP_CANDLES = 3; // Number of candles for ramping

                // Simple 3-candle ramping: 50% - 25% - 25%
                const calculateRampValue = (candleIndex, totalChange) => {
                    if (candleIndex >= RAMP_CANDLES) return totalChange;

                    if (candleIndex === 0) {
                        return totalChange * 0.5; // First candle: 50%
                    } else if (candleIndex === 1) {
                        return totalChange * 0.75; // Second candle: 75% total (first 50% + second 25%)
                    } else {
                        return totalChange; // Third candle: 100% (first 50% + second 25% + third 25%)
                    }
                };

                // State tracking
                let currentValue = initialValue != null ? clampValue(initialValue) : 0;
                let lastNewsValue = null;
                let lastIndicatorsValue = null;
                let consecutiveRedCandles = 0;
                let consecutiveGreenCandles = 0;
                let technicalDropCount = 0; // Track consecutive technical drops for -25 penalty
                let decayStartTimestamp = null; // When decay was triggered
                let decayStartValue = null; // Value when decay started
                let activeRamp = null; // { startIndex, targetChange, baseValue }

                const DECAY_DURATION_MS = 30 * 60 * 1000; // 30 minutes decay (no hold period)
                const DECAY_RATE = 0.2303; // Per minute decay rate (same as view 5)
                const TECHNICAL_DROP_THRESHOLD = 7; // Technical indicators drop by â‰¥7

                let newsMovementsDetected = 0;
                let technicalPenaltiesApplied = 0;

                // Process each point chronologically
                for (let i = 0; i < sortedPoints.length; i++) {
                    const point = sortedPoints[i];
                    const pointTime = point.timestamp.getTime();

                    // Initialize candleDecayValue for all points
                    if (point.candleDecayValue === undefined) {
                        point.candleDecayValue = 0;
                    }

                    // First, update currentValue based on active decay (if any)
                    // This ensures signals add/subtract from the CURRENT decayed value
                    if (decayStartTimestamp !== null) {
                        const timeSinceDecay = pointTime - decayStartTimestamp;
                        if (timeSinceDecay < DECAY_DURATION_MS) {
                            // Calculate exponential decay
                            const minutesSinceDecay = timeSinceDecay / (60 * 1000);
                            const decayedValue = decayStartValue * Math.exp(-DECAY_RATE * minutesSinceDecay);
                            const beforeDecay = currentValue;
                            currentValue = Math.abs(decayedValue) < 0.01 ? 0 : decayedValue;

                            // Log decay for first few points or every 10 points
                            if (i < 5 || i % 10 === 0) {
                                console.log(`   â±ï¸ DECAY: mins=${minutesSinceDecay.toFixed(2)}, startVal=${decayStartValue.toFixed(2)}, decayed=${currentValue.toFixed(2)}`);
                            }
                        } else {
                            // Decay complete
                            console.log(`   âœ… Decay COMPLETE at ${new Date(pointTime).toISOString()}`);
                            currentValue = 0;
                            decayStartTimestamp = null;
                            decayStartValue = null;
                        }
                    }

                    // Apply active ramp if in progress (BEFORE new signals)
                    if (activeRamp && decayStartTimestamp === null) {
                        const candlesIntoRamp = i - activeRamp.startIndex;
                        if (candlesIntoRamp < RAMP_CANDLES) {
                            const rampedChange = calculateRampValue(candlesIntoRamp, activeRamp.targetChange);
                            currentValue = clampValue(activeRamp.baseValue + rampedChange);
                        } else {
                            // Ramp complete
                            activeRamp = null;
                        }
                    }

                    // Detect NEWS UP signal (news score increases by > 0.01)
                    // News signals ALWAYS apply, even during decay
                    let newsUpDetected = false;
                    let newsMovement = 0;
                    if (point.news != null && !isNaN(point.news)) {
                        if (lastNewsValue !== null && !isNaN(lastNewsValue)) {
                            newsMovement = point.news - lastNewsValue;
                            if (newsMovement > 0.01) {
                                newsUpDetected = true;
                                newsMovementsDetected++;

                                // Start a new ramp for this news movement
                                activeRamp = {
                                    startIndex: i,
                                    targetChange: newsMovement,
                                    baseValue: currentValue
                                };

                                // Apply first candle of ramp immediately (50%)
                                const firstRampValue = calculateRampValue(0, newsMovement);
                                currentValue = clampValue(currentValue + firstRampValue);

                                // Stop any active decay - return to indefinite hold
                                decayStartTimestamp = null;
                                decayStartValue = null;

                                // DON'T reset candle counters - candle counting is independent
                                // Candles track price action to detect when signal is ending

                                console.log(`   ðŸ“ˆ News UP #${newsMovementsDetected} at ${new Date(pointTime).toISOString()}: +${newsMovement.toFixed(2)} ramping over ${RAMP_CANDLES} candles, 1st=${firstRampValue.toFixed(2)} â†’ value=${currentValue.toFixed(2)}`);
                            }
                        }
                        lastNewsValue = point.news;
                    }

                    // Detect TECHNICAL DROP signal (indicators drop by â‰¥10)
                    // Technical signals ALWAYS apply, even during decay
                    let technicalDropDetected = false;
                    if (point.indicators != null && !isNaN(point.indicators)) {
                        if (lastIndicatorsValue !== null && !isNaN(lastIndicatorsValue)) {
                            const technicalChange = point.indicators - lastIndicatorsValue;
                            if (technicalChange <= -TECHNICAL_DROP_THRESHOLD) {
                                technicalDropDetected = true;
                                technicalDropCount++;

                                console.log(`   ðŸ“‰ Technical DROP detected at ${new Date(pointTime).toISOString()}: ${technicalChange.toFixed(2)} (count: ${technicalDropCount})`);

                                // Check if we have 2 drops
                                if (technicalDropCount >= 2) {
                                    technicalPenaltiesApplied++;
                                    technicalDropCount = 0; // Reset counter

                                    // Start a new ramp for this technical penalty
                                    activeRamp = {
                                        startIndex: i,
                                        targetChange: -70,
                                        baseValue: currentValue
                                    };

                                    // Apply first candle of ramp immediately (50%)
                                    const firstRampValue = calculateRampValue(0, -70);
                                    currentValue = clampValue(currentValue + firstRampValue);

                                    // Stop any active decay - return to indefinite hold
                                    decayStartTimestamp = null;
                                    decayStartValue = null;

                                    // DON'T reset candle counters - candle counting is independent
                                    // Candles track price action to detect when signal is ending

                                    console.log(`   âš ï¸ Technical penalty #${technicalPenaltiesApplied} applied: -70 ramping over ${RAMP_CANDLES} candles, 1st=${firstRampValue.toFixed(2)} â†’ value=${currentValue.toFixed(2)}`);
                                }
                            } else {
                                // No drop, reset counter
                                technicalDropCount = 0;
                            }
                        }
                        lastIndicatorsValue = point.indicators;
                    }

                    // Track consecutive candles when we're holding a value (not at zero baseline)
                    if (currentValue !== 0) {
                        // Use 'price' as close (that's how the data is structured)
                        const closePrice = point.close != null ? point.close : point.price;
                        const openPrice = point.open;
                        const isRedCandle = closePrice < openPrice;
                        const isGreenCandle = closePrice > openPrice;

                        // DEBUG: Log candle info for first 10 points
                        if (i < 10) {
                            console.log(`   [DEBUG] Point ${i}: open=${point.open}, close=${point.close}, isRed=${isRedCandle}, isGreen=${isGreenCandle}, redCount=${consecutiveRedCandles}, greenCount=${consecutiveGreenCandles}, value=${currentValue.toFixed(2)}`);
                        }

                        if (isRedCandle) {
                            consecutiveRedCandles++;
                            consecutiveGreenCandles = 0; // Reset green counter

                            console.log(`   ðŸ”´ Red candle #${consecutiveRedCandles} at ${new Date(pointTime).toISOString()}, value=${currentValue.toFixed(2)}`);

                            // Check if 3 consecutive red candles
                            if (consecutiveRedCandles >= 3) {
                                console.log(`   ðŸ•¯ï¸ 3 consecutive RED candles detected at ${new Date(pointTime).toISOString()} â†’ starting decay from ${currentValue.toFixed(2)}`);

                                // Start decay to zero (skip hold period)
                                decayStartTimestamp = pointTime;
                                decayStartValue = currentValue;
                                consecutiveRedCandles = 0; // Reset counter
                            }
                        } else if (isGreenCandle) {
                            consecutiveGreenCandles++;
                            consecutiveRedCandles = 0; // Reset red counter

                            console.log(`   ðŸŸ¢ Green candle #${consecutiveGreenCandles} at ${new Date(pointTime).toISOString()}, value=${currentValue.toFixed(2)}`);

                            // Check if 3 consecutive green candles AND we're negative
                            if (consecutiveGreenCandles >= 3 && currentValue < 0) {
                                console.log(`   ðŸ•¯ï¸ 3 consecutive GREEN candles detected (negative state) at ${new Date(pointTime).toISOString()} â†’ starting decay from ${currentValue.toFixed(2)} to zero`);

                                // Start decay to zero (skip hold period)
                                decayStartTimestamp = pointTime;
                                decayStartValue = currentValue;
                                consecutiveGreenCandles = 0; // Reset counter
                            }
                        } else {
                            // Doji candle - log it
                            if (i < 20) console.log(`   âšª Doji candle at ${new Date(pointTime).toISOString()}, redCount=${consecutiveRedCandles}, greenCount=${consecutiveGreenCandles}`);
                        }
                    } else {
                        // Log when value is zero
                        if (i < 10) console.log(`   [DEBUG] Point ${i}: value is ZERO, skipping candle tracking`);
                    }

                    // Store the current value (currentValue has already been updated with decay at the start of this iteration)
                    point.candleDecayValue = clampValue(currentValue);
                }

                console.log(`   âœ… Processing complete. News movements: ${newsMovementsDetected}, Technical penalties: ${technicalPenaltiesApplied}`);

                // Update all dataPoints with candleDecayValue values
                sortedPoints.forEach(processedPoint => {
                    if (processedPoint.timestamp) {
                        const ts = processedPoint.timestamp.getTime();
                        const originalPoint = timestampToDataPoint.get(ts);
                        if (originalPoint) {
                            originalPoint.candleDecayValue = processedPoint.candleDecayValue;
                        }
                    }
                });

                return dataPoints;
            } catch (error) {
                console.error('âŒ Error in processCandleBasedDecay:', error);
                console.error('Stack trace:', error.stack);
                // Set candleDecayValue to 0 for all points on error
                dataPoints.forEach(point => {
                    if (point.candleDecayValue === undefined) {
                        point.candleDecayValue = 0;
                    }
                });
                return dataPoints;
            }
        }

        async function updateChart(timeframe) {
            try {
                console.log('=== UPDATE CHART START ===');
                console.log('Timeframe:', timeframe);

                // Get data for the selected timeframe with current scroll position
                const data = getDataForTimeframe(timeframe, scrollPosition);

                console.log('Chart update - timeframe:', timeframe, 'data points:', data.count || 0);

                // Handle "not enough data" case
                if (data.error) {
                    console.warn(data.error);
                    chartPath.setAttribute('d', '');
                    const dotsContainer = document.getElementById('chart-dots');
                    if (dotsContainer) dotsContainer.innerHTML = '';
                    xAxisLabels.innerHTML = `<span style="color: #ef4444; font-weight: 600;">âš ï¸ Not Enough Data</span>
                                            <span style="color: #888; margin-left: 10px; font-size: 12px;">(${data.count} point${data.count !== 1 ? 's' : ''} - need at least 3)</span>`;
                    return;
                }

                if (!data.path || data.path === '' || !data.dataPoints || data.dataPoints.length === 0) {
                    console.warn('No data to display');
                    chartPath.setAttribute('d', '');
                    xAxisLabels.innerHTML = '<span style="color: #666;">No data available - waiting for analysis to run...</span>';
                    return;
                }

                // Update X-axis labels (without data count - moved to header)
                if (data.labels && data.labels.length > 0) {
                    const labelsHtml = data.labels.map(label =>
                        `<span>${label}</span>`
                    ).join('');

                    xAxisLabels.innerHTML = labelsHtml;
                } else {
                    xAxisLabels.innerHTML = '<span>Loading...</span>';
                }

                // Hide the original curved path (we're using the new smooth line with dots instead)
                // console.log('Setting chart path:', data.path);
                chartPath.setAttribute('d', '');  // Clear the old path

                // Verify path was cleared
                // const verifyPath = chartPath.getAttribute('d');
                // console.log('Path verification:', verifyPath);

                // Draw chart based on chart type
                if (chartType === 'candlestick') {
                    drawCandlesticks(data.dataPoints, data.minPrice, data.maxPrice, data.priceRange);
                    // Draw volume chart for candlestick view
                    drawVolumeChart(data.dataPoints);
                } else {
                    drawDataPointDots(data.dataPoints, data.minPrice, data.maxPrice, data.priceRange);
                }

                // Draw market gap lines
                drawMarketGapLines(data.gaps || [], data.dataPoints);

                // CHART-DEPENDENT SIGNAL CALCULATION
                // Each chart calculates signals from its own data source:
                // - Granular charts: Calculate signals on-the-fly from granular data
                // - Regular charts: Use global cache built from minute-level data
                const signalModeActive = document.getElementById('scale-signal')?.checked || false;
                console.log('ðŸ” Signal mode active:', signalModeActive);
                console.log('ðŸ“Š Global cache size:', globalSignalCache.size);
                console.log('ðŸ“Š Using granular data:', data.usingGranularData);
                
                // Ensure cache is built if it's empty (safety check)
                if (globalSignalCache.size === 0) {
                    console.warn('âš ï¸ Signal cache is empty, rebuilding...');
                    buildGlobalSignalCache();
                }
                
                let attachedCount = 0;
                
                if (data.usingGranularData && granularDataType === 'second') {
                    // GRANULAR CHARTS (second-by-second data): Calculate signals from RAW 1-second data FIRST
                    // Then map signals to aggregated candles (5s, 30s) for consistency across all granular charts
                    console.log('ðŸ”„ Calculating signals from RAW second-by-second data for consistency...');
                    console.log(`   Chart data points: ${data.dataPoints.length}`);
                    
                    // Get raw second-by-second dataset (before aggregation)
                    const rawSecondData = secondCandlesDataset.length > 0 
                        ? [...secondCandlesDataset].sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime()) // Sort ascending
                        : [];
                    
                    if (rawSecondData.length === 0) {
                        console.warn('âš ï¸ No raw second-by-second data available, cannot calculate signals');
                        // Fallback: attach zeros
                        data.dataPoints.forEach(p => {
                            p.signalValue = 0;
                            attachedCount++;
                        });
                    } else {
                        console.log(`   Raw second-by-second data: ${rawSecondData.length} points`);
                        console.log(`   Raw data range: ${rawSecondData[0].timestamp.toISOString()} to ${rawSecondData[rawSecondData.length - 1].timestamp.toISOString()}`);
                        
                        // Find the last signal state from minute-level data (before granular timeframe)
                        // This provides continuity - granular signals inherit the last confirmed state
                        let inheritedSignalState = null;
                        let inheritedSignalValue = 0;
                        
                        if (rawSecondData.length > 0) {
                            const firstRawTimestamp = rawSecondData[0].timestamp;
                            const firstRawTime = firstRawTimestamp.getTime();
                            const lastRawTimestamp = rawSecondData[rawSecondData.length - 1].timestamp;
                            
                            // Strategy 1: Look for exact timestamp matches before raw granular timeframe
                            const minuteLevelTimestamps = Array.from(globalSignalCache.keys())
                                .filter(ts => ts <= firstRawTime)
                                .sort((a, b) => b - a);
                            
                            // Find the most recent non-zero signal
                            for (const ts of minuteLevelTimestamps) {
                                const signalValue = globalSignalCache.get(ts);
                                if (signalValue !== 0) {
                                    const signalTimestamp = new Date(ts);
                                    const expiresAt = new Date(ts + 15 * 60 * 1000);
                                    
                                    if (firstRawTimestamp < expiresAt) {
                                        inheritedSignalState = {
                                            type: signalValue > 0 ? 'news_up' : 'technical_down',
                                            value: signalValue,
                                            expiresAt: expiresAt,
                                            oppositeCount: 0
                                        };
                                        inheritedSignalValue = signalValue;
                                        console.log(`ðŸ“Œ Inherited signal state: ${inheritedSignalState.type} (${inheritedSignalState.value}) from ${signalTimestamp.toISOString()}`);
                                        break;
                                    }
                                }
                            }
                            
                            // Strategy 2: Fallback to any recent signal
                            if (!inheritedSignalState && globalSignalCache.size > 0) {
                                const allTimestamps = Array.from(globalSignalCache.keys()).sort((a, b) => b - a);
                                for (const ts of allTimestamps.slice(0, 10)) {
                                    const signalValue = globalSignalCache.get(ts);
                                    if (signalValue !== 0) {
                                        inheritedSignalState = {
                                            type: signalValue > 0 ? 'news_up' : 'technical_down',
                                            value: signalValue,
                                            expiresAt: new Date(Date.now() + 5 * 60 * 1000),
                                            oppositeCount: 0
                                        };
                                        inheritedSignalValue = signalValue;
                                        console.log(`ðŸ“Œ Using fallback signal: ${inheritedSignalState.type} (${inheritedSignalState.value})`);
                                        break;
                                    }
                                }
                            }
                        }
                        
                        // STEP 1: Calculate signals from RAW 1-second data
                        console.log(`   Calculating signals from ${rawSecondData.length} raw 1-second data points...`);
                        console.log(`     - Technical DOWN: â‰¥0.2 point â†’ -100 (15s)`);
                        console.log(`     - Technical UP: â‰¥0.3 point â†’ +100 (15s)`);
                        console.log(`     - News UP: â‰¥0.5 point â†’ +100 (1min)`);
                        
                        const rawSignalValues = calculateGranularSignalOscillator(rawSecondData, inheritedSignalState);
                        
                        // STEP 2: Create signal map: timestamp -> signalValue from raw data
                        const rawSignalMap = new Map();
                        rawSecondData.forEach((point, i) => {
                            const ts = point.timestamp.getTime();
                            let signalValue = rawSignalValues[i] || 0;
                            
                            // Propagate inherited signal if calculated is 0
                            if (signalValue === 0 && inheritedSignalValue !== 0 && inheritedSignalState) {
                                if (point.timestamp < inheritedSignalState.expiresAt) {
                                    signalValue = inheritedSignalValue;
                                }
                            }
                            
                            rawSignalMap.set(ts, signalValue);
                        });
                        
                        console.log(`   Created signal map with ${rawSignalMap.size} entries`);
                        const rawNonZero = Array.from(rawSignalMap.values()).filter(v => v !== 0).length;
                        console.log(`   Raw signals: ${rawNonZero} non-zero values`);
                        
                        // STEP 3: Map signals to chart data points (which may be aggregated)
                        // For aggregated candles, find the closest raw signal or use the bucket start time
                        data.dataPoints.forEach(p => {
                            const pointTime = p.timestamp.getTime();
                            let signalValue = rawSignalMap.get(pointTime);
                            
                            // If exact match not found (aggregated candle), find closest raw signal
                            if (signalValue === undefined) {
                                // Find closest raw timestamp within reasonable range (e.g., Â±5 seconds for 5s candles, Â±15s for 30s candles)
                                let closestTime = null;
                                let minDiff = Infinity;
                                const toleranceMs = 5000; // 5 second tolerance
                                
                                for (const rawTs of rawSignalMap.keys()) {
                                    const diff = Math.abs(rawTs - pointTime);
                                    if (diff < minDiff && diff <= toleranceMs) {
                                        minDiff = diff;
                                        closestTime = rawTs;
                                    }
                                }
                                
                                if (closestTime !== null) {
                                    signalValue = rawSignalMap.get(closestTime);
                                } else {
                                    signalValue = 0;
                                }
                            }
                            
                            p.signalValue = signalValue || 0;
                            attachedCount++;
                        });
                        
                        console.log(`âœ… Mapped signals from raw data to ${attachedCount} chart data points`);
                        const finalNonZero = data.dataPoints.filter(p => p.signalValue !== 0).length;
                        console.log(`   Final non-zero signals: ${finalNonZero}/${attachedCount}`);
                        
                        if (attachedCount > 0) {
                            const samplePoints = data.dataPoints.slice(0, 5);
                            console.log('Sample mapped signals:', samplePoints.map(p => ({
                                timestamp: p.timestamp.toISOString(),
                                signalValue: p.signalValue
                            })));
                        }
                    }
                } else if (data.usingGranularData && granularDataType === 'tick') {
                    // TICK DATA: Calculate signals directly from tick data (no raw/second mapping needed)
                    console.log('ðŸ”„ Calculating signals from tick data...');
                    
                    // Similar logic but for tick data - calculate directly
                    let inheritedSignalState = null;
                    let inheritedSignalValue = 0;
                    
                    // ... (similar inheritance logic as before)
                    
                    const signalValues = calculateGranularSignalOscillator(data.dataPoints, inheritedSignalState);
                    
                    data.dataPoints.forEach((p, i) => {
                        p.signalValue = signalValues[i] || 0;
                        attachedCount++;
                    });
                    
                    console.log(`âœ… Calculated and attached ${attachedCount} signal values from tick data`);
                } else {
                    // REGULAR CHARTS: Use global cache built from minute-level data
                    // These show confirmed signals from minute-level data
                    console.log('ðŸ“‹ Using global cache (minute-level signals) for this chart...');
                    
                    let exactMatches = 0;
                    let closestMatches = 0;
                    let noMatches = 0;
                    
                    data.dataPoints.forEach(p => {
                        if (p.timestamp) {
                            const timestampKey = p.timestamp.getTime();
                            let signalValue = globalSignalCache.get(timestampKey);
                            
                            if (signalValue !== undefined) {
                                // Exact match from minute-level cache
                                p.signalValue = signalValue;
                                exactMatches++;
                            } else {
                                // Try to find closest match (for edge cases)
                                signalValue = findClosestSignalValue(p.timestamp, 5000); // 5 second tolerance
                                p.signalValue = signalValue;
                                if (signalValue !== 0) {
                                    closestMatches++;
                                } else {
                                    noMatches++;
                                }
                            }
                            attachedCount++;
                        }
                    });
                    
                    console.log(`âœ… Attached signal values from cache: ${attachedCount} data points`);
                    console.log(`   Exact matches: ${exactMatches}, Closest matches: ${closestMatches}, No matches: ${noMatches}`);
                    
                    if (attachedCount > 0) {
                        const samplePoints = data.dataPoints.filter(p => p.signalValue !== undefined).slice(0, 3);
                        console.log('Sample cached signals:', samplePoints.map(p => ({
                            timestamp: p.timestamp.toISOString(),
                            signalValue: p.signalValue,
                            sentiment: p.sentiment
                        })));
                    }
                }

                // Calculate weighted average (signal + sentiment) if weighted mode is active
                const weightedModeActive = document.getElementById('scale-weighted')?.checked || false;
                if (weightedModeActive && data.dataPoints && data.dataPoints.length > 0) {
                    console.log('âš–ï¸ Weighted mode active - calculating weighted average of signal and sentiment');
                    
                    // Sort points by timestamp for processing
                    const sortedPoints = [...data.dataPoints].sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
                    
                    // Smooth signal transitions over 3 candles (reduced from 5 for less smoothing)
                    const SMOOTH_CANDLES = 3;
                    let smoothedSignals = [];
                    let transitionStartIndex = -1;
                    let transitionStartValue = 0;
                    let transitionTargetValue = 0;
                    
                    for (let i = 0; i < sortedPoints.length; i++) {
                        const point = sortedPoints[i];
                        const currentSignal = point.signalValue != null ? point.signalValue : 0;
                        
                        if (i === 0) {
                            // First point - no smoothing needed
                            smoothedSignals.push(currentSignal);
                            transitionStartValue = currentSignal;
                            transitionTargetValue = currentSignal;
                        } else {
                            const prevSignal = sortedPoints[i - 1].signalValue != null ? sortedPoints[i - 1].signalValue : 0;
                            const prevSmoothedSignal = smoothedSignals[i - 1];
                            
                            // Check if signal changed
                            if (currentSignal !== prevSignal) {
                                // Signal changed - start new transition over 5 candles
                                transitionStartIndex = i;
                                transitionStartValue = prevSmoothedSignal;
                                transitionTargetValue = currentSignal;
                                const candlesIntoTransition = 1;
                                const progress = candlesIntoTransition / SMOOTH_CANDLES;
                                const smoothedSignal = transitionStartValue + (transitionTargetValue - transitionStartValue) * progress;
                                smoothedSignals.push(smoothedSignal);
                            } else {
                                // Check if we're in the middle of a transition
                                const candlesSinceTransitionStart = i - transitionStartIndex;
                                
                                if (transitionStartIndex >= 0 && candlesSinceTransitionStart < SMOOTH_CANDLES) {
                                    // Still transitioning - continue smoothing
                                    const progress = candlesSinceTransitionStart / SMOOTH_CANDLES;
                                    const smoothedSignal = transitionStartValue + (transitionTargetValue - transitionStartValue) * progress;
                                    smoothedSignals.push(smoothedSignal);
                                } else {
                                    // Transition complete or no transition - use target value
                                    smoothedSignals.push(currentSignal);
                                    transitionStartValue = currentSignal;
                                    transitionTargetValue = currentSignal;
                                }
                            }
                        }
                    }
                    
                    // Now calculate weighted value: sentiment + 70% of signal
                    sortedPoints.forEach((point, index) => {
                        const smoothedSignal = smoothedSignals[index];
                        const sentimentValue = point.sentiment != null ? point.sentiment : 0;
                        
                        // Add sentiment score with 80% of signal score (both already in -100 to +100 range)
                        // Clamp to [-100, 100]
                        point.weightedValue = Math.min(100, Math.max(-100, sentimentValue + (smoothedSignal * 0.8)));
                    });
                }

                // News mode: Process news scores with hold/decay logic
                // Apply to both regular and granular data
                const newsModeActive = document.getElementById('scale-news')?.checked || false;
                if (newsModeActive && data.dataPoints && data.dataPoints.length > 0) {
                    const dataType = data.usingGranularData ? (granularDataType === 'second' ? 'granular (second)' : 'granular (tick)') : 'regular';
                    console.log(`ðŸ“° News mode active - processing news scores with hold/decay for ${dataType} data (${data.dataPoints.length} points)`);
                    
                    // For granular data, inherit the latest minute-level processedNews value
                    let initialProcessedNews = null;
                    if (data.usingGranularData && sentimentDataset && sentimentDataset.length > 0) {
                        // Process minute-level data first to get current processedNews value
                        // Get the latest minute-level points (last 100 points should be enough)
                        const latestMinutePoints = [...sentimentDataset]
                            .filter(p => p.news != null && !isNaN(p.news))
                            .sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime())
                            .slice(-100); // Get last 100 points
                        
                        if (latestMinutePoints.length > 0) {
                            // Process these points to get the latest processedNews value
                            processNewsScoresWithHoldDecay(latestMinutePoints);
                            
                            // Find the latest processedNews value
                            const latestPoint = latestMinutePoints[latestMinutePoints.length - 1];
                            if (latestPoint.processedNews != null && !isNaN(latestPoint.processedNews)) {
                                initialProcessedNews = latestPoint.processedNews;
                                console.log(`   ðŸ“Œ Inheriting latest minute-level processedNews: ${initialProcessedNews.toFixed(2)} from ${latestPoint.timestamp.toISOString()}`);
                            }
                        }
                    }
                    
                    processNewsScoresWithHoldDecay(data.dataPoints, initialProcessedNews);
                }

                // Candle-Based Decay mode: Process news up signals with candle-triggered decay
                // Only works with minute-by-minute data (not granular)
                // CRITICAL: Process FULL sentimentDataset once, then copy to visible points
                const candleDecayModeActive = document.getElementById('scale-candle-decay')?.checked || false;
                if (candleDecayModeActive && !data.usingGranularData) {
                    // Process the full dataset ONCE
                    if (sentimentDataset && sentimentDataset.length > 0) {
                        const firstPoint = sentimentDataset[0];
                        if (!firstPoint._candleDecayProcessed) {
                            console.log(`ðŸ•¯ï¸ Candle-Based Decay: Processing FULL dataset (${sentimentDataset.length} points)`);
                            processCandleBasedDecay(sentimentDataset);
                            // Mark all points as processed
                            sentimentDataset.forEach(p => p._candleDecayProcessed = true);
                        } else {
                            console.log(`âœ… Candle-Based Decay: Already processed, skipping`);
                        }

                        // Copy candleDecayValue from sentimentDataset to visible dataPoints
                        if (data.dataPoints && data.dataPoints.length > 0) {
                            const sentimentMap = new Map();
                            sentimentDataset.forEach(p => {
                                if (p.timestamp) {
                                    sentimentMap.set(p.timestamp.getTime(), p.candleDecayValue);
                                }
                            });
                            let copiedCount = 0;
                            data.dataPoints.forEach(p => {
                                if (p.timestamp) {
                                    const value = sentimentMap.get(p.timestamp.getTime());
                                    if (value !== undefined) {
                                        p.candleDecayValue = value;
                                        copiedCount++;
                                    }
                                }
                            });
                            console.log(`âœ… Copied candleDecayValue to ${copiedCount}/${data.dataPoints.length} visible points`);
                        }
                    }
                }

                // News + Composite mode: Calculate composite + (processedNews * 0.7)
                const newsCompositeModeActive = document.getElementById('scale-news-composite')?.checked || false;
                if (newsCompositeModeActive && data.dataPoints && data.dataPoints.length > 0) {
                    console.log('ðŸ“° News + Composite mode active - calculating composite + (news tracking Ã— 0.7)');
                    // Ensure processedNews is calculated first
                    if (!document.getElementById('scale-news')?.checked) {
                        // Process news scores if not already done
                        let initialProcessedNews = null;
                        if (data.usingGranularData && sentimentDataset && sentimentDataset.length > 0) {
                            const latestMinutePoints = [...sentimentDataset]
                                .filter(p => p.news != null && !isNaN(p.news))
                                .sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime())
                                .slice(-100);
                            if (latestMinutePoints.length > 0) {
                                processNewsScoresWithHoldDecay(latestMinutePoints);
                                const latestPoint = latestMinutePoints[latestMinutePoints.length - 1];
                                if (latestPoint.processedNews != null && !isNaN(latestPoint.processedNews)) {
                                    initialProcessedNews = latestPoint.processedNews;
                                }
                            }
                        }
                        processNewsScoresWithHoldDecay(data.dataPoints, initialProcessedNews);
                    }
                    
                    // Calculate newsCompositeValue = sentiment + (processedNews * 0.7)
                    data.dataPoints.forEach(point => {
                        const sentimentValue = point.sentiment != null ? point.sentiment : 0;
                        const processedNewsValue = point.processedNews != null ? point.processedNews : 0;
                        point.newsCompositeValue = sentimentValue + (processedNewsValue * 0.7);
                    });
                }

                // News + Price mode: Calculate price + (processedNews * 0.7)
                const newsPriceModeActive = document.getElementById('scale-news-price')?.checked || false;
                if (newsPriceModeActive && data.dataPoints && data.dataPoints.length > 0) {
                    console.log('ðŸ“° News + Price mode active - calculating price + (news tracking Ã— 0.7)');
                    // Ensure processedNews is calculated first
                    if (!document.getElementById('scale-news')?.checked && !newsCompositeModeActive) {
                        // Process news scores if not already done
                        let initialProcessedNews = null;
                        if (data.usingGranularData && sentimentDataset && sentimentDataset.length > 0) {
                            const latestMinutePoints = [...sentimentDataset]
                                .filter(p => p.news != null && !isNaN(p.news))
                                .sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime())
                                .slice(-100);
                            if (latestMinutePoints.length > 0) {
                                processNewsScoresWithHoldDecay(latestMinutePoints);
                                const latestPoint = latestMinutePoints[latestMinutePoints.length - 1];
                                if (latestPoint.processedNews != null && !isNaN(latestPoint.processedNews)) {
                                    initialProcessedNews = latestPoint.processedNews;
                                }
                            }
                        }
                        processNewsScoresWithHoldDecay(data.dataPoints, initialProcessedNews);
                    }
                    
                    // Calculate newsPriceValue = previous candle's price + (processedNews * 0.7)
                    // Use previous candle's price to allow live replication
                    data.dataPoints.forEach((point, index) => {
                        // Get previous candle's price (or current if it's the first point)
                        let previousPrice = 0;
                        if (index > 0 && data.dataPoints[index - 1].price != null) {
                            previousPrice = data.dataPoints[index - 1].price;
                        } else if (point.price != null) {
                            // Fallback to current price if no previous candle available
                            previousPrice = point.price;
                        }
                        const processedNewsValue = point.processedNews != null ? point.processedNews : 0;
                        point.newsPriceValue = previousPrice + (processedNewsValue * 0.7);
                    });
                }

                // Store current data points for hover functionality
                window.currentChartData = data.dataPoints;
                window.currentFullTimeframeData = data.fullTimeframeData;
                window.currentTimeLabels = data.labels || [];

                // Draw sentiment line in oscillator chart
                drawSentimentOscillator(data.dataPoints, data.fullTimeframeData, window.currentTimeLabels);

                // Update oscillator score display with the last value from current view
                // This ensures the score box shows the last plotted value in the chart
                if (data.dataPoints && data.dataPoints.length > 0) {
                    const lastPoint = data.dataPoints[data.dataPoints.length - 1];
                    let displayValue;
                    
                    // Check for all modes
                    const signalModeActive = document.getElementById('scale-signal')?.checked || false;
                    const newsModeActive = document.getElementById('scale-news')?.checked || false;
                    const weightedModeActive = document.getElementById('scale-weighted')?.checked || false;
                    const newsCompositeModeActive = document.getElementById('scale-news-composite')?.checked || false;
                    const newsPriceModeActive = document.getElementById('scale-news-price')?.checked || false;
                    
                    if (signalModeActive && lastPoint.signalValue != null) {
                        // In signal mode, use signal value
                        displayValue = lastPoint.signalValue;
                    } else if (weightedModeActive && lastPoint.weightedValue != null) {
                        // In weighted mode, use weighted average value
                        displayValue = lastPoint.weightedValue;
                    } else if (newsCompositeModeActive && lastPoint.newsCompositeValue != null) {
                        // In news + composite mode, use newsCompositeValue
                        displayValue = lastPoint.newsCompositeValue;
                    } else if (newsPriceModeActive && lastPoint.newsPriceValue != null) {
                        // In news + price mode, use newsPriceValue
                        displayValue = lastPoint.newsPriceValue;
                    } else if (newsModeActive) {
                        // In news mode, use processedNews if available, otherwise fallback to news
                        displayValue = lastPoint.processedNews != null ? lastPoint.processedNews : (lastPoint.news != null ? lastPoint.news : 0);
                    } else {
                        // In regular mode, use sentiment value
                        displayValue = lastPoint.sentiment ?? data.composite_score ?? 0;
                    }
                    
                    updateSentimentDisplay({
                        composite_score: displayValue
                    });
                }

                console.log('=== UPDATE CHART COMPLETE ===');
            } catch (error) {
                console.error('Error updating chart:', error);
                console.error('Stack trace:', error.stack);
            }
        }
        
        // Draw data point dots and connecting lines for better visibility
        function drawDataPointDots(dataPoints, minPrice, maxPrice, priceRange) {
            const dotsContainer = document.getElementById('chart-dots');
            if (!dotsContainer) return;

            // Clear existing dots
            dotsContainer.innerHTML = '';

            if (!dataPoints || dataPoints.length === 0) return;

            // Filter out points without price data
            const pricePoints = dataPoints.filter(p => p.price != null && !isNaN(p.price));

            if (pricePoints.length === 0) {
                console.warn('No Nasdaq price data available');
                return;
            }

            // Use priceRange if provided, otherwise calculate from current window
            let actualPriceRange = priceRange;
            if (!actualPriceRange) {
                const prices = pricePoints.map(p => p.price);
                actualPriceRange = {
                    min: Math.min(...prices),
                    max: Math.max(...prices)
                };
            }

            // DYNAMIC SCALE: Map price to Y coordinate (no padding for accurate scaling)
            const priceToY = (price) => {
                const range = actualPriceRange.max - actualPriceRange.min;
                if (range === 0) return 50;

                // Map to 0-100 (inverted Y axis) - no padding
                const y = ((actualPriceRange.max - price) / range) * 100;
                return Math.max(0, Math.min(100, y));
            };

            // Store for tooltip
            window.nasdaqPriceScale = actualPriceRange;

            // Create smooth path connecting all price points
            if (pricePoints.length > 1) {
                let pathD = `M ${pricePoints[0].x},${priceToY(pricePoints[0].price)}`;

                for (let i = 1; i < pricePoints.length; i++) {
                    const x = pricePoints[i].x;
                    const y = priceToY(pricePoints[i].price);

                    if (i === 1 && pricePoints.length === 2) {
                        // For just 2 points, draw a straight line
                        pathD += ` L ${x},${y}`;
                    } else {
                        // Use quadratic bezier for smooth curves
                        const prevX = pricePoints[i - 1].x;
                        const prevY = priceToY(pricePoints[i - 1].price);
                        const cpX = (prevX + x) / 2;
                        const cpY = (prevY + y) / 2;
                        pathD += ` Q ${cpX},${cpY} ${x},${y}`;
                    }
                }

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathD);
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', '#ffffff');
                path.setAttribute('stroke-width', '0.25');
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('stroke-linejoin', 'round');
                path.setAttribute('opacity', '0.9');
                dotsContainer.appendChild(path);
            }

            console.log(`Drew Nasdaq price line with ${pricePoints.length} data points`);
        }

        // Draw candlesticks for OHLC data (Heikin-Ashi style)
        function drawCandlesticks(dataPoints, minPrice, maxPrice, priceRange) {
            const dotsContainer = document.getElementById('chart-dots');
            if (!dotsContainer) return;

            // Clear existing content
            dotsContainer.innerHTML = '';

            if (!dataPoints || dataPoints.length === 0) return;

            // Filter out points without OHLC data
            const candlePoints = dataPoints.filter(p => 
                p.open != null && !isNaN(p.open) &&
                p.high != null && !isNaN(p.high) &&
                p.low != null && !isNaN(p.low) &&
                p.price != null && !isNaN(p.price) // price is close
            );

            if (candlePoints.length === 0) {
                console.warn('No OHLC data available for candlesticks');
                return;
            }

            // Calculate Heikin-Ashi values
            const heikinAshiCandles = [];
            let prevHAOpen = candlePoints[0].open;
            let prevHAClose = candlePoints[0].price;

            candlePoints.forEach((point, index) => {
                const close = point.price;
                const open = point.open;
                const high = point.high;
                const low = point.low;

                // Heikin-Ashi calculations
                const haClose = (open + high + low + close) / 4;
                const haOpen = index === 0 ? open : (prevHAOpen + prevHAClose) / 2;
                const haHigh = Math.max(high, haOpen, haClose);
                const haLow = Math.min(low, haOpen, haClose);

                heikinAshiCandles.push({
                    ...point,
                    haOpen,
                    haHigh,
                    haLow,
                    haClose,
                    isBullish: haClose >= haOpen
                });

                prevHAOpen = haOpen;
                prevHAClose = haClose;
            });

            // Use heikinAshiCandles instead of regular candles
            const displayCandles = heikinAshiCandles;

            // Use VISIBLE candles' price range for better proportions (not full day range)
            // This prevents vertical compression - use HA values for range
            const allPrices = [];
            displayCandles.forEach(p => {
                allPrices.push(p.haOpen, p.haHigh, p.haLow, p.haClose);
            });
            const visibleMin = Math.min(...allPrices);
            const visibleMax = Math.max(...allPrices);
            
            // Add 5% padding top and bottom to prevent candles from being cut off
            const visibleRange = visibleMax - visibleMin;
            const padding = visibleRange * 0.05;
            const actualPriceRange = {
                min: visibleMin - padding,
                max: visibleMax + padding
            };

            // Map price to Y coordinate with proper scaling
            const priceToY = (price) => {
                const range = actualPriceRange.max - actualPriceRange.min;
                if (range === 0) return 50;
                const y = ((actualPriceRange.max - price) / range) * 100;
                return Math.max(0, Math.min(100, y));
            };

            // Store for tooltip
            window.nasdaqPriceScale = actualPriceRange;

            // Industry-standard candlestick proportions (TradingView style)
            // Candles should fill 65% of space, with 35% gap between them
            // Use 96 instead of 100 because candles span from x=2 to x=98
            const spacePerCandle = 96 / displayCandles.length;
            // Cap at 4 to prevent overflow on small datasets, but allow to be thin on large datasets
            const candleWidth = Math.max(spacePerCandle * 0.65, 0.5); 
            
            // Wick should be about 1/8th the width of candle body for clean look, but visible
            // Ensure wick is always visible (at least 0.5px width equivalent)
            const wickWidth = Math.max(0.05, candleWidth * 0.125);

            // Draw each Heikin-Ashi candlestick
            displayCandles.forEach(point => {
                const x = point.x;
                
                // Use Heikin-Ashi values
                const open = point.haOpen;
                const high = point.haHigh;
                const low = point.haLow;
                const close = point.haClose;
                const isBullish = point.isBullish;

                const openY = priceToY(open);
                const highY = priceToY(high);
                const lowY = priceToY(low);
                const closeY = priceToY(close);
                
                // Color scheme: white for bullish, blue for bearish
                const candleColor = isBullish ? '#ffffff' : '#3b82f6';

                // Draw wick (high to low)
                const wick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                wick.setAttribute('x1', x);
                wick.setAttribute('y1', highY);
                wick.setAttribute('x2', x);
                wick.setAttribute('y2', lowY);
                wick.setAttribute('stroke', candleColor);
                wick.setAttribute('stroke-width', wickWidth);
                wick.setAttribute('opacity', '0.9');
                dotsContainer.appendChild(wick);

                // Draw body (open to close)
                const bodyTop = Math.min(openY, closeY);
                const bodyHeight = Math.abs(openY - closeY);
                
                // Minimum body height for doji candles - should be visible as a line
                // Scale with candle width for consistency
                const minBodyHeight = wickWidth * 1.5;
                const displayBodyHeight = Math.max(bodyHeight, minBodyHeight);

                const body = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                body.setAttribute('x', x - candleWidth / 2);
                body.setAttribute('y', bodyTop);
                body.setAttribute('width', candleWidth);
                body.setAttribute('height', displayBodyHeight);
                body.setAttribute('fill', candleColor);
                body.setAttribute('opacity', '0.95');
                dotsContainer.appendChild(body);
            });

            console.log(`Drew ${displayCandles.length} Heikin-Ashi candlesticks`);
        }

        // Draw volume bars
        function drawVolumeChart(dataPoints) {
            const volumeBarsContainer = document.getElementById('volume-bars');
            if (!volumeBarsContainer) return;

            // Clear existing volume bars
            volumeBarsContainer.innerHTML = '';

            if (!dataPoints || dataPoints.length === 0) return;

            // Filter points with volume data
            const volumePoints = dataPoints.filter(p => p.volume != null && !isNaN(p.volume));

            if (volumePoints.length === 0) {
                console.warn('No volume data available');
                return;
            }

            // Find max volume for scaling
            const maxVolume = Math.max(...volumePoints.map(p => p.volume));
            if (maxVolume === 0) return;

            // Calculate bar width (same as candles)
            // Use 96 instead of 100 because bars span from x=2 to x=98
            const spacePerBar = 96 / volumePoints.length;
            // Cap at 4 to prevent overflow, but ensure visibility on large datasets
            const barWidth = Math.max(spacePerBar * 0.65, 0.5); 

            // Draw each volume bar
            volumePoints.forEach(point => {
                const x = point.x;
                const volume = point.volume;
                
                // Calculate bar height (volume as % of max)
                const heightPercent = (volume / maxVolume) * 100;
                // Minimum height for visibility
                const barHeight = Math.max(heightPercent, 0.5);
                const barY = 100 - barHeight; // Start from bottom

                // Determine color: green for bullish (close > open), red for bearish
                let barColor;
                if (point.haClose !== undefined && point.haOpen !== undefined) {
                    // Use Heikin-Ashi values if available
                    barColor = point.haClose >= point.haOpen ? '#10b981' : '#ef4444';
                } else if (point.price !== undefined && point.open !== undefined) {
                    // Fall back to regular OHLC
                    barColor = point.price >= point.open ? '#10b981' : '#ef4444';
                } else {
                    barColor = '#888'; // Neutral if can't determine
                }

                // Draw bar
                const bar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                bar.setAttribute('x', x - barWidth / 2);
                bar.setAttribute('y', barY);
                bar.setAttribute('width', barWidth);
                bar.setAttribute('height', barHeight);
                bar.setAttribute('fill', barColor);
                // Increased opacity for better visibility, matching the requested style
                bar.setAttribute('opacity', '0.9'); 
                volumeBarsContainer.appendChild(bar);
            });

            console.log(`Drew ${volumePoints.length} volume bars`);
        }

        // Draw vertical dotted lines for market gaps
        function drawMarketGapLines(gaps, dataPoints) {
            // Remove existing gap lines
            const existingLines = document.querySelectorAll('.market-gap-line');
            existingLines.forEach(line => line.remove());

            if (!gaps || gaps.length === 0 || !dataPoints || dataPoints.length === 0) {
                return;
            }

            const chartContainer = document.getElementById('chart-container');
            if (!chartContainer) return;

            // Draw a vertical line at each gap
            gaps.forEach(gap => {
                // Find the x position for this gap (at the start of the gap index)
                const xPercent = (gap.index / (dataPoints.length - 1)) * 100;

                // Create the gap line element
                const gapLine = document.createElement('div');
                gapLine.className = 'market-gap-line';
                gapLine.style.left = `calc(50px + (100% - 70px) * ${xPercent / 100})`;

                chartContainer.appendChild(gapLine);

                console.log(`ðŸ“Š Drew market gap line at ${xPercent.toFixed(1)}% (${Math.round(gap.duration / 60)}h gap)`);
            });
        }

        // Update Y-axis labels for price range
        function updateYAxisLabels(dataPoints, minPrice, maxPrice, priceRange) {
            const yAxis = document.querySelector('.y-axis');
            if (!yAxis) return;

            // Use priceRange if provided
            let actualPriceRange = priceRange;
            if (!actualPriceRange) {
                const prices = dataPoints.filter(p => p.price != null).map(p => p.price);
                if (prices.length === 0) return;
                actualPriceRange = {
                    min: Math.min(...prices),
                    max: Math.max(...prices)
                };
            }

            // DYNAMIC SCALE: Show actual price range with padding
            const range = actualPriceRange.max - actualPriceRange.min;
            const padding = range * 0.1;
            const paddedMin = actualPriceRange.min - padding;
            const paddedMax = actualPriceRange.max + padding;

            // Calculate 5 evenly spaced labels
            const step = (paddedMax - paddedMin) / 4;
            const labels = [];
            for (let i = 4; i >= 0; i--) {
                const value = paddedMin + (step * i);
                labels.push(`<span class="y-axis-label">$${value.toFixed(0)}</span>`);
            }

            yAxis.innerHTML = labels.join('');
        }

        // Helper function to find the closest timestamp match in cache (within tolerance)
        // This handles cases where aggregated timestamps don't exactly match cache keys
        function findClosestSignalValue(timestamp, maxToleranceMs = 5000) {
            const targetTime = timestamp.getTime();
            
            // First try exact match
            if (globalSignalCache.has(targetTime)) {
                return globalSignalCache.get(targetTime);
            }
            
            // Find closest timestamp within tolerance
            let closestTime = null;
            let minDiff = Infinity;
            
            for (const cachedTime of globalSignalCache.keys()) {
                const diff = Math.abs(cachedTime - targetTime);
                if (diff < minDiff && diff <= maxToleranceMs) {
                    minDiff = diff;
                    closestTime = cachedTime;
                }
            }
            
            if (closestTime !== null) {
                return globalSignalCache.get(closestTime);
            }
            
            // No match found, return 0
            return 0;
        }

        // Build global signal cache from minute-level datasets only
        // This cache is used by regular charts (Session, 2h, 4h, etc.) to show confirmed signals
        // Granular charts calculate signals on-the-fly from their own data
        function buildGlobalSignalCache() {
            console.log('ðŸ”„ Building global signal cache (minute-level data only)...');
            globalSignalCache.clear();

            // Only include minute-level datasets (not granular)
            // Granular charts will calculate signals independently
            const allData = [
                ...sentimentDataset,
                ...sentimentDataset2d,
                ...sentimentDataset3d
            ].filter(p => p && p.timestamp); // Filter out invalid entries

            if (allData.length === 0) {
                console.warn('âš ï¸ No data available for signal cache');
                return;
            }

            // Sort by timestamp
            allData.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());

            // Remove duplicates by timestamp (keep the most recent version if duplicates exist)
            const uniqueData = [];
            const seenTimestamps = new Map(); // Map to track latest version of each timestamp
            
            for (const point of allData) {
                const ts = point.timestamp.getTime();
                // Keep the most recent data point for each timestamp
                if (!seenTimestamps.has(ts) || point.timestamp > seenTimestamps.get(ts).timestamp) {
                    if (seenTimestamps.has(ts)) {
                        // Replace with newer version
                        const oldIndex = uniqueData.findIndex(p => p.timestamp.getTime() === ts);
                        if (oldIndex !== -1) {
                            uniqueData[oldIndex] = point;
                        }
                    } else {
                        uniqueData.push(point);
                    }
                    seenTimestamps.set(ts, point);
                }
            }

            // Ensure uniqueData is still sorted after replacements
            uniqueData.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());

            console.log(`ðŸ“Š Processing ${uniqueData.length} unique minute-level data points for signal detection`);
            console.log(`   Regular datasets: ${sentimentDataset.length + sentimentDataset2d.length + sentimentDataset3d.length} points`);
            console.log(`   Note: Granular charts calculate signals independently from their own data`);

            // Calculate signals from the complete dataset
            const signalValues = calculateSignalOscillator(uniqueData);

            // Build timestamp -> signal value map
            uniqueData.forEach((point, i) => {
                const ts = point.timestamp.getTime();
                const signalValue = signalValues[i] || 0;
                globalSignalCache.set(ts, signalValue);
            });

            console.log(`âœ… Signal cache built with ${globalSignalCache.size} entries`);
            
            // Log sample entries for debugging
            if (globalSignalCache.size > 0) {
                const sampleEntries = Array.from(globalSignalCache.entries()).slice(0, 3);
                console.log(`   Sample cache entries:`, sampleEntries.map(([ts, val]) => ({
                    timestamp: new Date(ts).toISOString(),
                    signalValue: val
                })));
            }
        }

        // Calculate signal-based oscillator values from historical data
        // Returns array with +100 (News UP active), -100 (Technical DOWN active), or 0 (no signal)
        // Requires 2 opposite signals to flip from +100 to -100 or vice versa
        // Optionally inherits initial signal state from a previous calculation
        function calculateSignalOscillator(dataPoints, initialSignalState = null) {
            if (!dataPoints || dataPoints.length === 0) return [];

            const signalValues = [];
            // Start with inherited signal state if provided, otherwise start fresh
            let activeSignal = initialSignalState ? { ...initialSignalState } : null;

            for (let i = 0; i < dataPoints.length; i++) {
                const current = dataPoints[i];
                const previous = i > 0 ? dataPoints[i - 1] : null;

                // Check if current active signal has expired
                if (activeSignal && current.timestamp >= activeSignal.expiresAt) {
                    activeSignal = null; // Signal expired
                }

                let newsUpDetected = false;
                let newsChange = 0; // Store the actual change value
                let technicalDownDetected = false;

                // Detect News UP signal (news score increases by â‰¥5)
                if (previous && current.news != null && previous.news != null) {
                    newsChange = current.news - previous.news;
                    if (newsChange >= 5) {
                        newsUpDetected = true;
                    }
                }

                // Detect Technical DOWN signal (technical score decreases by â‰¥10)
                if (previous && current.indicators != null && previous.indicators != null) {
                    const technicalChange = current.indicators - previous.indicators;
                    if (technicalChange <= -10) {
                        technicalDownDetected = true;
                    }
                }

                // Handle signal logic with 2-signal requirement to flip
                if (activeSignal) {
                    // We have an active signal - check if opposite signal can flip it
                    if (activeSignal.type === 'news_up' && technicalDownDetected) {
                        // At +100, need 2 technical down signals to flip to -100
                        activeSignal.oppositeCount = (activeSignal.oppositeCount || 0) + 1;
                        if (activeSignal.oppositeCount >= 2) {
                            // Flip to technical down
                            activeSignal = {
                                type: 'technical_down',
                                value: -100,
                                expiresAt: new Date(current.timestamp.getTime() + 15 * 60 * 1000), // 15 minutes
                                oppositeCount: 0
                            };
                        }
                    } else if (activeSignal.type === 'technical_down' && newsUpDetected) {
                        // At -100, need 2 news up signals to flip to +100
                        // OR if single signal is â‰¥ 2Ã— threshold (â‰¥10), flip immediately
                        const NEWS_UP_THRESHOLD = 5;
                        const DOUBLE_THRESHOLD = NEWS_UP_THRESHOLD * 2; // 10
                        
                        if (newsChange >= DOUBLE_THRESHOLD) {
                            // Large signal (â‰¥10) - flip immediately to +100
                            activeSignal = {
                                type: 'news_up',
                                value: 100,
                                expiresAt: new Date(current.timestamp.getTime() + 15 * 60 * 1000), // 15 minutes
                                oppositeCount: 0
                            };
                        } else {
                            // Normal signal (5-9.99) - require 2 signals
                        activeSignal.oppositeCount = (activeSignal.oppositeCount || 0) + 1;
                        if (activeSignal.oppositeCount >= 2) {
                            // Flip to news up
                            activeSignal = {
                                type: 'news_up',
                                value: 100,
                                expiresAt: new Date(current.timestamp.getTime() + 15 * 60 * 1000), // 15 minutes
                                oppositeCount: 0
                            };
                            }
                        }
                    } else if ((activeSignal.type === 'news_up' && newsUpDetected) || 
                               (activeSignal.type === 'technical_down' && technicalDownDetected)) {
                        // Same type signal - reset opposite count and extend expiration
                        activeSignal.oppositeCount = 0;
                        if (activeSignal.type === 'news_up') {
                            activeSignal.expiresAt = new Date(current.timestamp.getTime() + 15 * 60 * 1000);
                        } else {
                            activeSignal.expiresAt = new Date(current.timestamp.getTime() + 15 * 60 * 1000);
                        }
                    }
                } else {
                    // No active signal - new signal can start
                    if (newsUpDetected && technicalDownDetected) {
                        // If both trigger at same timestamp, News UP wins
                        activeSignal = {
                            type: 'news_up',
                            value: 100,
                            expiresAt: new Date(current.timestamp.getTime() + 15 * 60 * 1000), // 15 minutes
                            oppositeCount: 0
                        };
                    } else if (newsUpDetected) {
                        activeSignal = {
                            type: 'news_up',
                            value: 100,
                            expiresAt: new Date(current.timestamp.getTime() + 15 * 60 * 1000), // 15 minutes
                            oppositeCount: 0
                        };
                    } else if (technicalDownDetected) {
                        activeSignal = {
                            type: 'technical_down',
                            value: -100,
                            expiresAt: new Date(current.timestamp.getTime() + 15 * 60 * 1000), // 15 minutes
                            oppositeCount: 0
                        };
                    }
                }

                // Store the current signal value for this data point
                signalValues.push(activeSignal ? activeSignal.value : 0);
            }

            return signalValues;
        }

        // Calculate signal-based oscillator values for GRANULAR data (second-by-second)
        // Uses different thresholds and shorter durations than minute-level signals
        // Thresholds (MUCH LOWER for maximum movement):
        //   - Technical DOWN: â‰¥0.2 point decrease â†’ -100 for 1 minute (interrupted by opposite signals)
        //   - Technical UP: â‰¥0.3 point increase â†’ +100 for 1 minute (interrupted by opposite signals)
        //   - News UP: â‰¥0.5 point increase â†’ +100 for 1 minute (interrupted by opposite signals)
        // Flip rules: Same as minute-level (2 opposite signals to flip)
        // Optionally inherits initial signal state from minute-level data
        function calculateGranularSignalOscillator(dataPoints, initialSignalState = null) {
            if (!dataPoints || dataPoints.length === 0) return [];

            const signalValues = [];
            // Start with inherited signal state if provided, otherwise start fresh
            let activeSignal = initialSignalState ? { ...initialSignalState } : null;

            for (let i = 0; i < dataPoints.length; i++) {
                const current = dataPoints[i];
                const previous = i > 0 ? dataPoints[i - 1] : null;

                // Check if current active signal has expired
                if (activeSignal && current.timestamp >= activeSignal.expiresAt) {
                    activeSignal = null; // Signal expired
                }

                let newsUpDetected = false;
                let technicalDownDetected = false;
                let technicalUpDetected = false;

                // Detect News UP signal (news score increases by â‰¥0.5) - MUCH LOWER for maximum movement
                if (previous && current.news != null && previous.news != null) {
                    const newsChange = current.news - previous.news;
                    if (newsChange >= 0.5) {
                        newsUpDetected = true;
                    }
                }

                // Detect Technical DOWN signal (technical score decreases by â‰¥0.2) - MUCH LOWER for maximum movement
                if (previous && current.indicators != null && previous.indicators != null) {
                    const technicalChange = current.indicators - previous.indicators;
                    if (technicalChange <= -0.2) {
                        technicalDownDetected = true;
                    }
                }

                // Detect Technical UP signal (technical score increases by â‰¥0.3) - MUCH LOWER for maximum movement
                if (previous && current.indicators != null && previous.indicators != null) {
                    const technicalChange = current.indicators - previous.indicators;
                    if (technicalChange >= 0.3) {
                        technicalUpDetected = true;
                    }
                }

                // Handle signal logic: signals last 1 minute, but opposite signals interrupt immediately
                if (activeSignal) {
                    // We have an active signal - check if opposite signal interrupts it
                    if (activeSignal.type === 'news_up' && technicalDownDetected) {
                        // At +100 (news up), opposite signal (technical down) interrupts immediately
                        activeSignal = {
                            type: 'technical_down',
                            value: -100,
                            expiresAt: new Date(current.timestamp.getTime() + 60 * 1000), // 1 minute
                            oppositeCount: 0
                        };
                    } else if (activeSignal.type === 'technical_down' && (newsUpDetected || technicalUpDetected)) {
                        // At -100 (technical down), opposite signal (positive) interrupts immediately
                        // Prefer news up if both detected, otherwise technical up
                        const flipType = newsUpDetected ? 'news_up' : 'technical_up';
                        activeSignal = {
                            type: flipType,
                            value: 100,
                            expiresAt: new Date(current.timestamp.getTime() + 60 * 1000), // 1 minute
                            oppositeCount: 0
                        };
                    } else if (activeSignal.type === 'technical_up' && technicalDownDetected) {
                        // At +100 (technical up), opposite signal (technical down) interrupts immediately
                        activeSignal = {
                            type: 'technical_down',
                            value: -100,
                            expiresAt: new Date(current.timestamp.getTime() + 60 * 1000), // 1 minute
                            oppositeCount: 0
                        };
                    } else if ((activeSignal.type === 'news_up' && newsUpDetected) || 
                               (activeSignal.type === 'technical_down' && technicalDownDetected) ||
                               (activeSignal.type === 'technical_up' && technicalUpDetected)) {
                        // Same type signal - extend expiration to 1 minute
                        activeSignal.oppositeCount = 0;
                        activeSignal.expiresAt = new Date(current.timestamp.getTime() + 60 * 1000); // 1 minute
                    }
                } else {
                    // No active signal - new signal can start
                    if (newsUpDetected && technicalDownDetected) {
                        // If both trigger at same timestamp, News UP wins
                        activeSignal = {
                            type: 'news_up',
                            value: 100,
                            expiresAt: new Date(current.timestamp.getTime() + 60 * 1000), // 1 minute
                            oppositeCount: 0
                        };
                    } else if (newsUpDetected) {
                        activeSignal = {
                            type: 'news_up',
                            value: 100,
                            expiresAt: new Date(current.timestamp.getTime() + 60 * 1000), // 1 minute
                            oppositeCount: 0
                        };
                    } else if (technicalUpDetected) {
                        activeSignal = {
                            type: 'technical_up',
                            value: 100,
                            expiresAt: new Date(current.timestamp.getTime() + 60 * 1000), // 1 minute
                            oppositeCount: 0
                        };
                    } else if (technicalDownDetected) {
                        activeSignal = {
                            type: 'technical_down',
                            value: -100,
                            expiresAt: new Date(current.timestamp.getTime() + 60 * 1000), // 1 minute
                            oppositeCount: 0
                        };
                    }
                }

                // Store the current signal value for this data point
                signalValues.push(activeSignal ? activeSignal.value : 0);
            }

            return signalValues;
        }

        // Draw sentiment line in oscillator chart with optional driver overlays
        function drawSentimentOscillator(dataPoints, fullTimeframeData, timeLabels) {
            const oscillatorDiv = document.getElementById('chart-oscillator');
            if (!oscillatorDiv) {
                console.error('âŒ chart-oscillator container not found');
                return;
            }

            // Clear existing content
            oscillatorDiv.innerHTML = '';

            if (!dataPoints || dataPoints.length === 0) {
                console.warn('âš ï¸ No dataPoints provided for oscillator');
                return;
            }

            // Create SVG container for oscillator
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 100 100');
            svg.setAttribute('preserveAspectRatio', 'none');
            svg.style.width = '100%';
            // Set height to fill the available space in the container
            // Using 160% to match the container height properly (as user found this works)
            svg.style.height = '160%';

            // Determine scale mode
            const scaleMode = document.querySelector('input[name="oscillator-scale"]:checked')?.value || 'visible';

            // Calculate min/max range based on scale mode - use actual data min/max for all modes
            let minValue, maxValue;

            if (scaleMode === 'fixed' || scaleMode === 'signal') {
                // Fixed/Signal mode: Always use -100 to +100 range (fixed scale)
                minValue = -100;
                maxValue = 100;
            } else if (scaleMode === 'news-composite') {
                // News + Composite mode: Scale based on newsCompositeValue
                const compositeValues = (scaleMode === 'visible' ? dataPoints : (fullTimeframeData || dataPoints))
                    .filter(p => p.newsCompositeValue != null && !isNaN(p.newsCompositeValue))
                    .map(p => p.newsCompositeValue);
                
                if (compositeValues.length > 0) {
                    minValue = Math.min(...compositeValues);
                    maxValue = Math.max(...compositeValues);
                    // Add 10% padding
                    const range = maxValue - minValue;
                    const padding = range * 0.1 || 10;
                    minValue -= padding;
                    maxValue += padding;
                } else {
                    minValue = -100;
                    maxValue = 100;
                }
            } else if (scaleMode === 'news-price') {
                // News + Price mode: Scale based on newsPriceValue
                const priceValues = (scaleMode === 'visible' ? dataPoints : (fullTimeframeData || dataPoints))
                    .filter(p => p.newsPriceValue != null && !isNaN(p.newsPriceValue))
                    .map(p => p.newsPriceValue);
                
                if (priceValues.length > 0) {
                    minValue = Math.min(...priceValues);
                    maxValue = Math.max(...priceValues);
                    // Add 10% padding
                    const range = maxValue - minValue;
                    const padding = range * 0.1 || 10;
                    minValue -= padding;
                    maxValue += padding;
                } else {
                    minValue = -100;
                    maxValue = 100;
                }
            } else if (scaleMode === 'news') {
                // News mode: Scale based on raw news values from backend only
                // Use actual values without clamping
                const allNewsValues = [];
                const datasetToUse = scaleMode === 'visible' ? dataPoints : (fullTimeframeData || dataPoints);
                
                datasetToUse.forEach(p => {
                    // Include only raw news values from backend (not processedNews)
                    if (p.news != null && !isNaN(p.news)) {
                        allNewsValues.push(p.news);
                    }
                });
                
                if (allNewsValues.length > 0) {
                    minValue = Math.min(...allNewsValues);
                    maxValue = Math.max(...allNewsValues);
                    // Add 10% padding to ensure both lines are fully visible
                    const range = maxValue - minValue;
                    const padding = range * 0.1 || 10;
                    minValue -= padding;
                    maxValue += padding;
                } else {
                    minValue = -100;
                    maxValue = 100;
                }
            } else if (scaleMode === 'weighted') {
                // Weighted mode: Scale based on weighted values only
                const weightedValues = (scaleMode === 'visible' ? dataPoints : (fullTimeframeData || dataPoints))
                    .filter(p => p.weightedValue != null && !isNaN(p.weightedValue))
                    .map(p => p.weightedValue);

                if (weightedValues.length > 0) {
                    minValue = Math.min(...weightedValues);
                    maxValue = Math.max(...weightedValues);
                    // Add 10% padding
                    const range = maxValue - minValue;
                    const padding = range * 0.1 || 10;
                    minValue -= padding;
                    maxValue += padding;
                } else {
                    minValue = -100;
                    maxValue = 100;
                }
            } else if (scaleMode === 'candle-decay') {
                // Candle-Based Decay mode: Check expand state
                const expandBtn = document.getElementById('oscillator-expand-btn');
                const isExpanded = expandBtn?.dataset.candleDecayExpanded === 'true';

                if (isExpanded) {
                    // Expanded: Use min-max of candleDecayValue from visible dataPoints
                    // (candleDecayValue is copied from sentimentDataset to dataPoints)
                    const candleValues = dataPoints
                        .filter(p => p.candleDecayValue != null && !isNaN(p.candleDecayValue))
                        .map(p => p.candleDecayValue);

                    if (candleValues.length > 0) {
                        minValue = Math.min(...candleValues);
                        maxValue = Math.max(...candleValues);
                        // Add 10% padding
                        const range = maxValue - minValue;
                        const padding = range * 0.1 || 10;
                        minValue -= padding;
                        maxValue += padding;
                    } else {
                        minValue = -100;
                        maxValue = 100;
                    }
                } else {
                    // Collapsed: Fixed scale -100 to +100
                    minValue = -100;
                    maxValue = 100;
                }
            } else {
                // Collect all values from enabled drivers
                const driverKeys = ['sentiment', 'news', 'indicators'];
                const allValues = [];

                // Determine which dataset to use
                const datasetToUse = scaleMode === 'visible' ? dataPoints : (fullTimeframeData || dataPoints);

                // Get eye buttons for checking active state
                const sentimentEyeBtn = document.getElementById('eye-sentiment');
                const summaryEyeBtn = document.getElementById('eye-summary');
                const newsEyeBtn = document.getElementById('eye-news');
                const indicatorsEyeBtn = document.getElementById('eye-indicators');

                driverKeys.forEach(key => {
                    let shouldInclude = false;
                    
                    if (key === 'sentiment') {
                        // For sentiment, check both eye-sentiment AND eye-summary (they control the same line)
                        const sentimentActive = sentimentEyeBtn && sentimentEyeBtn.classList.contains('active');
                        const summaryActive = summaryEyeBtn && summaryEyeBtn.classList.contains('active');
                        shouldInclude = sentimentActive || summaryActive;
                    } else if (key === 'news') {
                        shouldInclude = !newsEyeBtn || newsEyeBtn.classList.contains('active');
                    } else if (key === 'indicators') {
                        shouldInclude = !indicatorsEyeBtn || indicatorsEyeBtn.classList.contains('active');
                    }

                    if (shouldInclude) {
                        datasetToUse.forEach(point => {
                            if (point[key] != null && !isNaN(point[key])) {
                                allValues.push(point[key]);
                            }
                        });
                    }
                });

                if (allValues.length > 0) {
                    minValue = Math.min(...allValues);
                    maxValue = Math.max(...allValues);
                    // Add 10% padding
                    const range = maxValue - minValue;
                    const padding = range * 0.1 || 10;
                    minValue -= padding;
                    maxValue += padding;
                } else {
                    // Fallback to fixed scale
                    minValue = -100;
                    maxValue = 100;
                }
            }

            // Clamp min/max values to -100/+100 range (cannot display values outside this range)
            // minValue should be at least -100, maxValue should be at most 100
            minValue = Math.max(-100, minValue);
            maxValue = Math.min(100, maxValue);

            // Update Y-axis labels
            const yAxisDiv = document.getElementById('oscillator-y-axis');
            if (yAxisDiv) {
                // Display: max at top, min at bottom (no zero label)
                const formatValue = (val) => {
                    if (val === 0) return '0';
                    const rounded = Math.round(val);
                    return rounded > 0 ? `+${rounded}` : `${rounded}`;
                };

                yAxisDiv.innerHTML = `
                    <span>${formatValue(maxValue)}</span>
                    <span>${formatValue(minValue)}</span>
                `;
            }

            // Update X-axis labels (time labels)
            const xAxisDiv = document.getElementById('oscillator-x-axis');
            if (xAxisDiv && timeLabels && timeLabels.length > 0) {
                const labelsHtml = timeLabels.map(label =>
                    `<span>${label}</span>`
                ).join('');
                xAxisDiv.innerHTML = labelsHtml;
            } else if (xAxisDiv) {
                xAxisDiv.innerHTML = '';
            }

            // Create value to Y mapping function with padding to keep lines visible
            // Midpoint of range is at Y=50 (visual center)
            const valueToY = (value) => {
                const range = maxValue - minValue;
                if (range === 0) return 50;

                const midpoint = (minValue + maxValue) / 2;
                // Add 5% padding on top and bottom so extreme values are visible
                // Map to Y range [5, 95] instead of [0, 100]
                const y = 50 - ((value - midpoint) / range) * 90;
                return Math.max(5, Math.min(95, y));
            };

            // Check if signal mode, news mode, weighted mode, or new composite/price modes are active
            const signalModeActive = document.getElementById('scale-signal')?.checked || false;
            const newsModeActive = document.getElementById('scale-news')?.checked || false;
            const weightedModeActive = document.getElementById('scale-weighted')?.checked || false;
            const newsCompositeModeActive = document.getElementById('scale-news-composite')?.checked || false;
            const newsPriceModeActive = document.getElementById('scale-news-price')?.checked || false;

            // Define which drivers to plot and their colors
            // Only include drivers that have historical data from the API
            const driverConfig = [
                { key: 'sentiment', color: '#ff8c42', label: 'Composite', eyeBtn: document.getElementById('eye-sentiment') }, // Orange - toggleable
                { key: 'news', color: '#ec4899', label: 'News', eyeBtn: document.getElementById('eye-news') }, // Pink
                { key: 'indicators', color: '#3b82f6', label: 'Indicators', eyeBtn: document.getElementById('eye-indicators') } // Blue
            ];
            
            // Get summary eye button for mutual exclusivity check
            const summaryEyeBtn = document.getElementById('eye-summary');

            // In news mode, draw only the tracking line
            if (newsModeActive) {
                console.log(`ðŸ“Š News mode: minValue=${minValue.toFixed(2)}, maxValue=${maxValue.toFixed(2)}`);
                
                // Sort points by x coordinate to ensure proper drawing order
                const sortedDataPoints = [...dataPoints].sort((a, b) => (a.x || 0) - (b.x || 0));
                
                // Draw the tracking line (using processedNews)
                const trackingPoints = sortedDataPoints.filter(p => {
                    const newsValue = p.processedNews != null ? p.processedNews : 0;
                    return newsValue != null && !isNaN(newsValue) && p.x != null;
                });
                console.log(`ðŸ“Š Tracking points: ${trackingPoints.length}, sample values:`, 
                    trackingPoints.slice(0, 3).map(p => ({ x: p.x, processedNews: p.processedNews, y: valueToY(p.processedNews || 0) })));
                
                if (trackingPoints.length > 0) {
                    const getTrackingValue = (point) => point.processedNews != null ? point.processedNews : 0;
                    const firstTrackingY = valueToY(getTrackingValue(trackingPoints[0]));
                    let pathD = `M ${trackingPoints[0].x},${firstTrackingY}`;
                    console.log(`ðŸ“Š First tracking point: x=${trackingPoints[0].x}, value=${getTrackingValue(trackingPoints[0])}, y=${firstTrackingY}`);
                    
                    for (let i = 1; i < trackingPoints.length; i++) {
                        const x = trackingPoints[i].x;
                        const y = valueToY(getTrackingValue(trackingPoints[i]));
                        const prevX = trackingPoints[i - 1].x;
                        const prevY = valueToY(getTrackingValue(trackingPoints[i - 1]));
                        
                        if (i === 1 && trackingPoints.length === 2) {
                            pathD += ` L ${x},${y}`;
                        } else {
                            const dx = x - prevX;
                            const dy = y - prevY;
                            const cp1X = prevX + dx * 0.5;
                            const cp1Y = prevY + dy * 0.15;
                            const cp2X = x - dx * 0.5;
                            const cp2Y = y - dy * 0.15;
                            pathD += ` C ${cp1X},${cp1Y} ${cp2X},${cp2Y} ${x},${y}`;
                        }
                    }
                    
                    const trackingPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    trackingPath.setAttribute('d', pathD);
                    trackingPath.setAttribute('fill', 'none');
                    trackingPath.setAttribute('stroke', '#ec4899'); // Pink to match news color
                    trackingPath.setAttribute('stroke-width', '1');
                    trackingPath.setAttribute('vector-effect', 'non-scaling-stroke');
                    trackingPath.setAttribute('stroke-linecap', 'round');
                    trackingPath.setAttribute('stroke-linejoin', 'round');
                    trackingPath.setAttribute('opacity', '0.9'); // Full opacity
                    trackingPath.classList.add('oscillator-line-news-tracking');
                    svg.appendChild(trackingPath);
                    console.log(`âœ… Drew news tracking line with ${trackingPoints.length} points, path length: ${pathD.length}, first 100 chars: ${pathD.substring(0, 100)}`);
                }
                
                // Draw center zero line AFTER all data lines so it's visible on top
                const zeroY = valueToY(0);
                if (zeroY >= 0 && zeroY <= 100) {
                    const centerLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    centerLine.setAttribute('x1', '2');
                    centerLine.setAttribute('y1', zeroY.toString());
                    centerLine.setAttribute('x2', '98');
                    centerLine.setAttribute('y2', zeroY.toString());
                    centerLine.setAttribute('stroke', '#888888');
                    centerLine.setAttribute('stroke-width', '1');
                    centerLine.setAttribute('vector-effect', 'non-scaling-stroke');
                    centerLine.setAttribute('stroke-dasharray', '2,2');
                    centerLine.setAttribute('opacity', '0.8');
                    centerLine.setAttribute('stroke-linecap', 'round');
                    svg.appendChild(centerLine);
                    console.log(`âœ… Drew zero line at Y=${zeroY.toFixed(2)}`);
                }
                
                // IMPORTANT: Append SVG to DOM before returning!
                oscillatorDiv.appendChild(svg);
                console.log(`âœ… SVG appended to DOM with ${svg.children.length} children`);
                
                // Skip the normal driver loop for news mode since we handled it above
                return;
            }

            // Candle-Based Decay mode: Draw candleDecayValue line
            const candleDecayModeActive = scaleMode === 'candle-decay';
            if (candleDecayModeActive) {
                console.log(`ðŸ•¯ï¸ Candle-Based Decay mode: minValue=${minValue.toFixed(2)}, maxValue=${maxValue.toFixed(2)}`);

                const sortedDataPoints = [...dataPoints].sort((a, b) => (a.x || 0) - (b.x || 0));
                const candlePoints = sortedDataPoints.filter(p => {
                    const value = p.candleDecayValue != null ? p.candleDecayValue : null;
                    return value != null && !isNaN(value) && p.x != null;
                });

                if (candlePoints.length > 0) {
                    const getCandleValue = (point) => point.candleDecayValue != null ? point.candleDecayValue : 0;
                    let pathD = `M ${candlePoints[0].x},${valueToY(getCandleValue(candlePoints[0]))}`;

                    for (let i = 1; i < candlePoints.length; i++) {
                        const x = candlePoints[i].x;
                        const y = valueToY(getCandleValue(candlePoints[i]));
                        const prevX = candlePoints[i - 1].x;
                        const prevY = valueToY(getCandleValue(candlePoints[i - 1]));

                        if (i === 1 && candlePoints.length === 2) {
                            pathD += ` L ${x},${y}`;
                        } else {
                            const dx = x - prevX;
                            const dy = y - prevY;
                            const cp1X = prevX + dx * 0.5;
                            const cp1Y = prevY + dy * 0.15;
                            const cp2X = x - dx * 0.5;
                            const cp2Y = y - dy * 0.15;
                            pathD += ` C ${cp1X},${cp1Y} ${cp2X},${cp2Y} ${x},${y}`;
                        }
                    }

                    const candlePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    candlePath.setAttribute('d', pathD);
                    candlePath.setAttribute('fill', 'none');
                    candlePath.setAttribute('stroke', '#a855f7'); // Purple
                    candlePath.setAttribute('stroke-width', '1');
                    candlePath.setAttribute('vector-effect', 'non-scaling-stroke');
                    candlePath.setAttribute('stroke-linecap', 'round');
                    candlePath.setAttribute('stroke-linejoin', 'round');
                    candlePath.setAttribute('opacity', '0.9');
                    candlePath.classList.add('oscillator-line-candle-decay');
                    svg.appendChild(candlePath);
                    console.log(`âœ… Drew candle-based decay line with ${candlePoints.length} points`);
                }

                // Draw zero line
                const zeroY = valueToY(0);
                if (zeroY >= 0 && zeroY <= 100) {
                    const centerLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    centerLine.setAttribute('x1', '2');
                    centerLine.setAttribute('y1', zeroY.toString());
                    centerLine.setAttribute('x2', '98');
                    centerLine.setAttribute('y2', zeroY.toString());
                    centerLine.setAttribute('stroke', '#888888');
                    centerLine.setAttribute('stroke-width', '1');
                    centerLine.setAttribute('vector-effect', 'non-scaling-stroke');
                    centerLine.setAttribute('stroke-dasharray', '2,2');
                    centerLine.setAttribute('opacity', '0.8');
                    centerLine.setAttribute('stroke-linecap', 'round');
                    svg.appendChild(centerLine);
                }

                oscillatorDiv.appendChild(svg);
                return;
            }

            // News + Composite mode: Draw composite + (processedNews * 0.7) line
            if (newsCompositeModeActive) {
                console.log(`ðŸ“Š News + Composite mode: minValue=${minValue.toFixed(2)}, maxValue=${maxValue.toFixed(2)}`);
                
                const sortedDataPoints = [...dataPoints].sort((a, b) => (a.x || 0) - (b.x || 0));
                const compositePoints = sortedDataPoints.filter(p => {
                    const value = p.newsCompositeValue != null ? p.newsCompositeValue : null;
                    return value != null && !isNaN(value) && p.x != null;
                });
                
                if (compositePoints.length > 0) {
                    const getCompositeValue = (point) => point.newsCompositeValue != null ? point.newsCompositeValue : 0;
                    let pathD = `M ${compositePoints[0].x},${valueToY(getCompositeValue(compositePoints[0]))}`;
                    
                    for (let i = 1; i < compositePoints.length; i++) {
                        const x = compositePoints[i].x;
                        const y = valueToY(getCompositeValue(compositePoints[i]));
                        const prevX = compositePoints[i - 1].x;
                        const prevY = valueToY(getCompositeValue(compositePoints[i - 1]));
                        
                        if (i === 1 && compositePoints.length === 2) {
                            pathD += ` L ${x},${y}`;
                        } else {
                            const dx = x - prevX;
                            const dy = y - prevY;
                            const cp1X = prevX + dx * 0.5;
                            const cp1Y = prevY + dy * 0.15;
                            const cp2X = x - dx * 0.5;
                            const cp2Y = y - dy * 0.15;
                            pathD += ` C ${cp1X},${cp1Y} ${cp2X},${cp2Y} ${x},${y}`;
                        }
                    }
                    
                    const compositePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    compositePath.setAttribute('d', pathD);
                    compositePath.setAttribute('fill', 'none');
                    compositePath.setAttribute('stroke', '#ff8c42'); // Orange
                    compositePath.setAttribute('stroke-width', '1');
                    compositePath.setAttribute('vector-effect', 'non-scaling-stroke');
                    compositePath.setAttribute('stroke-linecap', 'round');
                    compositePath.setAttribute('stroke-linejoin', 'round');
                    compositePath.setAttribute('opacity', '0.9');
                    compositePath.classList.add('oscillator-line-news-composite');
                    svg.appendChild(compositePath);
                    console.log(`âœ… Drew news + composite line with ${compositePoints.length} points`);
                }
                
                // Draw zero line
                const zeroY = valueToY(0);
                if (zeroY >= 0 && zeroY <= 100) {
                    const centerLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    centerLine.setAttribute('x1', '2');
                    centerLine.setAttribute('y1', zeroY.toString());
                    centerLine.setAttribute('x2', '98');
                    centerLine.setAttribute('y2', zeroY.toString());
                    centerLine.setAttribute('stroke', '#888888');
                    centerLine.setAttribute('stroke-width', '1');
                    centerLine.setAttribute('vector-effect', 'non-scaling-stroke');
                    centerLine.setAttribute('stroke-dasharray', '2,2');
                    centerLine.setAttribute('opacity', '0.8');
                    centerLine.setAttribute('stroke-linecap', 'round');
                    svg.appendChild(centerLine);
                }
                
                oscillatorDiv.appendChild(svg);
                return;
            }

            // News + Price mode: Draw price + (processedNews * 0.7) line
            if (newsPriceModeActive) {
                console.log(`ðŸ“Š News + Price mode: minValue=${minValue.toFixed(2)}, maxValue=${maxValue.toFixed(2)}`);
                
                const sortedDataPoints = [...dataPoints].sort((a, b) => (a.x || 0) - (b.x || 0));
                const pricePoints = sortedDataPoints.filter(p => {
                    const value = p.newsPriceValue != null ? p.newsPriceValue : null;
                    return value != null && !isNaN(value) && p.x != null;
                });
                
                if (pricePoints.length > 0) {
                    const getPriceValue = (point) => point.newsPriceValue != null ? point.newsPriceValue : 0;
                    let pathD = `M ${pricePoints[0].x},${valueToY(getPriceValue(pricePoints[0]))}`;
                    
                    for (let i = 1; i < pricePoints.length; i++) {
                        const x = pricePoints[i].x;
                        const y = valueToY(getPriceValue(pricePoints[i]));
                        const prevX = pricePoints[i - 1].x;
                        const prevY = valueToY(getPriceValue(pricePoints[i - 1]));
                        
                        if (i === 1 && pricePoints.length === 2) {
                            pathD += ` L ${x},${y}`;
                        } else {
                            const dx = x - prevX;
                            const dy = y - prevY;
                            const cp1X = prevX + dx * 0.5;
                            const cp1Y = prevY + dy * 0.15;
                            const cp2X = x - dx * 0.5;
                            const cp2Y = y - dy * 0.15;
                            pathD += ` C ${cp1X},${cp1Y} ${cp2X},${cp2Y} ${x},${y}`;
                        }
                    }
                    
                    const pricePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    pricePath.setAttribute('d', pathD);
                    pricePath.setAttribute('fill', 'none');
                    pricePath.setAttribute('stroke', '#10b981'); // Green
                    pricePath.setAttribute('stroke-width', '1');
                    pricePath.setAttribute('vector-effect', 'non-scaling-stroke');
                    pricePath.setAttribute('stroke-linecap', 'round');
                    pricePath.setAttribute('stroke-linejoin', 'round');
                    pricePath.setAttribute('opacity', '0.9');
                    pricePath.classList.add('oscillator-line-news-price');
                    svg.appendChild(pricePath);
                    console.log(`âœ… Drew news + price line with ${pricePoints.length} points`);
                }
                
                // Draw zero line
                const zeroY = valueToY(0);
                if (zeroY >= 0 && zeroY <= 100) {
                    const centerLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    centerLine.setAttribute('x1', '2');
                    centerLine.setAttribute('y1', zeroY.toString());
                    centerLine.setAttribute('x2', '98');
                    centerLine.setAttribute('y2', zeroY.toString());
                    centerLine.setAttribute('stroke', '#888888');
                    centerLine.setAttribute('stroke-width', '1');
                    centerLine.setAttribute('vector-effect', 'non-scaling-stroke');
                    centerLine.setAttribute('stroke-dasharray', '2,2');
                    centerLine.setAttribute('opacity', '0.8');
                    centerLine.setAttribute('stroke-linecap', 'round');
                    svg.appendChild(centerLine);
                }
                
                oscillatorDiv.appendChild(svg);
                return;
            }

            // Draw each enabled driver
            driverConfig.forEach(driver => {
                // In signal mode, only show sentiment line (with signal values)
                if (signalModeActive && driver.key !== 'sentiment') {
                    return; // Skip other drivers in signal mode
                }
                
                // In weighted mode, only show sentiment line (with weighted values)
                if (weightedModeActive && driver.key !== 'sentiment') {
                    return; // Skip other drivers in weighted mode
                }
                
                // Check if this driver should be displayed (check eye button active state)
                // In signal mode, always show sentiment line regardless of eye button state
                // In weighted mode, always show sentiment line regardless of eye button state
                let shouldDisplay;
                if ((signalModeActive && driver.key === 'sentiment') || 
                    (weightedModeActive && driver.key === 'sentiment')) {
                    shouldDisplay = true;
                } else if (driver.key === 'sentiment') {
                    // For sentiment line, check both eye-sentiment AND eye-summary (they control the same line)
                    const sentimentActive = driver.eyeBtn && driver.eyeBtn.classList.contains('active');
                    const summaryActive = summaryEyeBtn && summaryEyeBtn.classList.contains('active');
                    shouldDisplay = sentimentActive || summaryActive;
                } else {
                    // For other drivers, check their own eye button
                    shouldDisplay = !driver.eyeBtn || driver.eyeBtn.classList.contains('active');
                }
                if (!shouldDisplay) return;

                // For sentiment line in signal mode, use pre-attached signal values from global cache
                let points;
                if (driver.key === 'sentiment' && signalModeActive) {
                    // Signal values already attached to data points from global cache
                    // This ensures consistency across all timeframes
                    points = dataPoints.filter(p => p.signalValue !== undefined);
                    console.log(`ðŸ“Š Signal mode: Found ${points.length} points with signal values`);
                    if (points.length > 0) {
                        console.log('Sample signal point:', points[0]);
                    }
                } else if (driver.key === 'sentiment' && weightedModeActive) {
                    // In weighted mode, use weighted average values
                    points = dataPoints.filter(p => p.weightedValue != null && !isNaN(p.weightedValue));
                    console.log(`âš–ï¸ Weighted mode: Found ${points.length} points with weighted values`);
                } else {
                    // Filter points that have this driver data
                    points = dataPoints.filter(p => p[driver.key] != null && !isNaN(p[driver.key]));
                }

                if (points.length === 0) {
                    console.warn(`âŒ No ${driver.label} data available`);
                    if (driver.key === 'sentiment' && signalModeActive) {
                        console.warn('Signal mode is active but no signal values found');
                        console.warn('Global cache size:', globalSignalCache.size);
                        console.warn('Sample dataPoint:', dataPoints[0]);
                        console.warn('dataPoints has signalValue?', 'signalValue' in dataPoints[0], dataPoints[0].signalValue);
                        console.warn('dataPoints has timestamp?', 'timestamp' in dataPoints[0]);
                        if (dataPoints[0].timestamp) {
                            const ts = dataPoints[0].timestamp.getTime();
                            console.warn('Timestamp:', dataPoints[0].timestamp);
                            console.warn('Looking up in cache:', ts);
                            console.warn('Cache has this timestamp?', globalSignalCache.has(ts));
                            console.warn('Value from cache:', globalSignalCache.get(ts));
                        }
                    }
                    return;
                }

                // Create smooth path with ease-in-out curves
                if (points.length > 1) {
                    // Helper to get value (use signalValue in signal mode, weightedValue in weighted mode)
                    const getValue = (point) => {
                        if (driver.key === 'sentiment' && signalModeActive) {
                            return point.signalValue;
                        } else if (driver.key === 'sentiment' && weightedModeActive) {
                            return point.weightedValue;
                        } else {
                            return point[driver.key];
                        }
                    };

                    let pathD = `M ${points[0].x},${valueToY(getValue(points[0]))}`;

                    for (let i = 1; i < points.length; i++) {
                        const x = points[i].x;
                        const y = valueToY(getValue(points[i]));
                        const prevX = points[i - 1].x;
                        const prevY = valueToY(getValue(points[i - 1]));

                        if (i === 1 && points.length === 2) {
                            // Just two points - simple line
                            pathD += ` L ${x},${y}`;
                        } else {
                            // Use cubic Bezier with ease-in-out control points
                            // Control points create S-curve for both horizontal AND vertical transitions
                            const dx = x - prevX;
                            const dy = y - prevY;
                            const horizontalTension = 0.5; // How far control points extend horizontally
                            const verticalTension = 0.15; // How gradually vertical transitions happen

                            // First control point: ease-out from previous point
                            // Moves mostly in X direction first (slow vertical start)
                            const cp1X = prevX + dx * horizontalTension;
                            const cp1Y = prevY + dy * verticalTension; // Gradual Y movement at start

                            // Second control point: ease-in to current point
                            // Completes Y transition near the end (slow vertical finish)
                            const cp2X = x - dx * horizontalTension;
                            const cp2Y = y - dy * verticalTension; // Complete Y movement near end

                            pathD += ` C ${cp1X},${cp1Y} ${cp2X},${cp2Y} ${x},${y}`;
                        }
                    }

                    // In signal mode, add filled areas above/below zero
                    if (driver.key === 'sentiment' && signalModeActive) {
                        const zeroY = valueToY(0);

                        // Build separate paths for positive and negative areas
                        for (let i = 0; i < points.length; i++) {
                            const currentValue = getValue(points[i]);
                            const currentY = valueToY(currentValue);

                            if (currentValue > 0 && i < points.length - 1) {
                                const nextValue = getValue(points[i + 1]);
                                if (nextValue > 0) {
                                    // Both points positive - create green fill segment
                                    const nextY = valueToY(nextValue);
                                    const nextX = points[i + 1].x;
                                    const curX = points[i].x;

                                    const dx = nextX - curX;
                                    const dy = nextY - currentY;
                                    const cp1X = curX + dx * 0.5;
                                    const cp1Y = currentY + dy * 0.15;
                                    const cp2X = nextX - dx * 0.5;
                                    const cp2Y = nextY - dy * 0.15;

                                    const greenSegment = `M ${curX},${zeroY} L ${curX},${currentY} C ${cp1X},${cp1Y} ${cp2X},${cp2Y} ${nextX},${nextY} L ${nextX},${zeroY} Z`;
                                    const greenFill = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                                    greenFill.setAttribute('d', greenSegment);
                                    greenFill.setAttribute('fill', 'rgba(34, 197, 94, 0.25)');
                                    greenFill.setAttribute('stroke', 'none');
                                    svg.appendChild(greenFill);
                                }
                            } else if (currentValue < 0 && i < points.length - 1) {
                                const nextValue = getValue(points[i + 1]);
                                if (nextValue < 0) {
                                    // Both points negative - create red fill segment
                                    const nextY = valueToY(nextValue);
                                    const nextX = points[i + 1].x;
                                    const curX = points[i].x;

                                    const dx = nextX - curX;
                                    const dy = nextY - currentY;
                                    const cp1X = curX + dx * 0.5;
                                    const cp1Y = currentY + dy * 0.15;
                                    const cp2X = nextX - dx * 0.5;
                                    const cp2Y = nextY - dy * 0.15;

                                    const redSegment = `M ${curX},${zeroY} L ${curX},${currentY} C ${cp1X},${cp1Y} ${cp2X},${cp2Y} ${nextX},${nextY} L ${nextX},${zeroY} Z`;
                                    const redFill = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                                    redFill.setAttribute('d', redSegment);
                                    redFill.setAttribute('fill', 'rgba(239, 68, 68, 0.25)');
                                    redFill.setAttribute('stroke', 'none');
                                    svg.appendChild(redFill);
                                }
                            }
                        }
                    }

                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('d', pathD);
                    path.setAttribute('fill', 'none');
                    // In signal mode, use white for the line; otherwise use driver color
                    const lineColor = (driver.key === 'sentiment' && signalModeActive) ? '#ffffff' : driver.color;
                    path.setAttribute('stroke', lineColor);
                    // All oscillator lines use 1 pixel width for consistent rendering
                    path.setAttribute('stroke-width', '1');
                    path.setAttribute('vector-effect', 'non-scaling-stroke');
                    path.setAttribute('stroke-linecap', 'round');
                    path.setAttribute('stroke-linejoin', 'round');
                    path.setAttribute('opacity', '0.9');
                    path.classList.add(`oscillator-line-${driver.key}`);
                    svg.appendChild(path);

                    console.log(`âœ… Drew ${driver.label} line with ${points.length} points`);
                }
            });

            // Draw center zero line AFTER all data lines so it's visible on top
            // This ensures the zero line is always visible when the data line is at zero
            const zeroY = valueToY(0);
            if (zeroY >= 0 && zeroY <= 100) {
                const centerLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                centerLine.setAttribute('x1', '2');
                centerLine.setAttribute('y1', zeroY.toString());
                centerLine.setAttribute('x2', '98');
                centerLine.setAttribute('y2', zeroY.toString());
                // Make zero line more visible: solid color, higher opacity
                centerLine.setAttribute('stroke', '#888888'); // Solid gray color
                centerLine.setAttribute('stroke-width', '1');
                centerLine.setAttribute('vector-effect', 'non-scaling-stroke');
                centerLine.setAttribute('stroke-dasharray', '2,2'); // Dashed line pattern
                centerLine.setAttribute('opacity', '0.8'); // Higher opacity for visibility
                centerLine.setAttribute('stroke-linecap', 'round');
                // Ensure it's drawn on top by appending last
                svg.appendChild(centerLine);
                console.log(`âœ… Drew zero line at Y=${zeroY.toFixed(2)}`);
            }

            oscillatorDiv.appendChild(svg);
        }

        // Nasdaq price overlay toggle state - DEFAULT TO TRUE so line shows immediately
        window.nasdaqPriceEnabled = true;

        // Checkbox toggle handler
        const priceToggleCheckbox = document.getElementById('price-toggle');
        if (priceToggleCheckbox) {
            priceToggleCheckbox.checked = true;
            priceToggleCheckbox.addEventListener('change', async () => {
                window.nasdaqPriceEnabled = !!priceToggleCheckbox.checked;
                console.log(`â˜‘ï¸ Show Nasdaq: ${window.nasdaqPriceEnabled}`);
                await updateChart(currentTimeframe);
            });
        }

        // Chart type toggle button
        const chartTypeToggle = document.getElementById('chart-type-toggle');
        const lineIcon = document.getElementById('line-icon');
        const candleIcon = document.getElementById('candle-icon');
        
        if (chartTypeToggle) {
            chartTypeToggle.addEventListener('click', async () => {
                // Toggle chart type
                if (chartType === 'candlestick') {
                    chartType = 'line';
                    lineIcon.style.display = 'none';
                    candleIcon.style.display = 'block';
                } else {
                    chartType = 'candlestick';
                    lineIcon.style.display = 'block';
                    candleIcon.style.display = 'none';
                }
                
                console.log('Chart type changed to:', chartType);
                await updateChart(currentTimeframe);
            });
        }

        // Granular data toggle (Second/Tick)
        const granularToggle = document.getElementById('granular-toggle');
        const granularBtns = document.querySelectorAll('.granular-btn');
        
        granularBtns.forEach(btn => {
            btn.addEventListener('click', async () => {
                const newType = btn.dataset.type;
                if (newType === granularDataType) return; // Already selected
                
                const previousType = granularDataType;
                granularDataType = newType;
                console.log(`ðŸ“Š Switched from ${previousType} to ${granularDataType} candles`);
                
                // Update button states
                granularBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // Fetch granular data if not already loaded
                const config = timeframeConfig[currentTimeframe];
                if (config && config.supportsGranular) {
                    console.log(`ðŸ”„ Fetching ${granularDataType} candles data...`);
                    
                    // Always fetch when switching to ensure we have fresh data
                    if (granularDataType === 'second') {
                        if (secondCandlesDataset.length === 0) {
                            await fetchSecondCandles();
                        }
                    } else if (granularDataType === 'tick') {
                        if (tickCandlesDataset.length === 0) {
                            await fetchTickCandles();
                        }
                    }
                    
                    // Restart auto-refresh for the new granular data type
                    stopGranularRefresh();
                    startGranularRefresh();
                    
                    // Update chart with new data type
                    await updateChart(currentTimeframe);
                }
            });
        });
        
        // Function to update granular toggle visibility
        function updateGranularToggleVisibility() {
            const config = timeframeConfig[currentTimeframe];
            if (granularToggle && config) {
                if (config.supportsGranular) {
                    granularToggle.style.display = 'flex';
                } else {
                    granularToggle.style.display = 'none';
                }
            }
        }

        timeframeBtns.forEach(btn => {
            btn.addEventListener('click', async () => {
                timeframeBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                const timeframe = btn.dataset.timeframe;
                currentTimeframe = timeframe;

                // Reset scroll position to rightmost (most recent data)
                scrollPosition = 100;
                const scrollbar = document.getElementById('chart-scrollbar');
                if (scrollbar) scrollbar.value = '100';
                
                // Update granular toggle visibility
                updateGranularToggleVisibility();
                
                // Automatically fetch granular data for granular-capable timeframes
                const config = timeframeConfig[timeframe];
                if (config && config.supportsGranular) {
                    console.log(`ðŸ“Š Granular timeframe selected, fetching ${granularDataType} candles...`);
                    
                    // Fetch the appropriate granular data based on toggle selection
                    // ALWAYS fetch fresh data when switching tabs to ensure the chart updates immediately
                    // instead of relying on cached data which might be stale or empty
                    if (granularDataType === 'second') {
                         // Reset dataset to force refresh or just call fetch directly
                         await fetchSecondCandles();
                    } else if (granularDataType === 'tick') {
                         await fetchTickCandles();
                    }
                    
                    // Start granular auto-refresh (1 second)
                    startGranularRefresh();
                } else {
                    // Stop granular refresh if switching away from granular-capable timeframes
                    stopGranularRefresh();
                }

                await updateChart(timeframe);
                currentTimeframe = timeframe; // Update current timeframe for hover
            });
        });

        // Scrollbar event listener
        const chartScrollbar = document.getElementById('chart-scrollbar');
        if (chartScrollbar) {
            chartScrollbar.addEventListener('input', async (e) => {
                scrollPosition = parseInt(e.target.value);
                console.log('Scroll position changed to:', scrollPosition);
                await updateChart(currentTimeframe);
            });
        }
        
        // Initialize the dashboard
        async function initializeDashboard() {
            try {
                console.log('Initializing NASDAQ Sentiment Dashboard...');
                console.log('Current time:', new Date().toISOString());

                // Fetch dashboard data (composite score + drivers)
                const dashboardData = await fetchDashboardData();
                if (dashboardData) {
                    console.log('Dashboard data loaded - Composite score:', dashboardData.composite_score);
                    console.log('Drivers:', dashboardData.drivers);
                }

                // Initialize chart with default timeframe (6h = Session)
                currentTimeframe = '6h';
                
                // Set initial granular toggle visibility
                updateGranularToggleVisibility();
                
                await updateChart(currentTimeframe);

                // Function to toggle eye icon state and update visibility
                function toggleEyeIcon(eyeBtn, isActive) {
                    const openEye = eyeBtn.querySelector('.eye-open');
                    const closedEye = eyeBtn.querySelector('.eye-closed');
                    
                    if (isActive) {
                        eyeBtn.classList.add('active');
                        if (openEye) openEye.style.display = 'block';
                        if (closedEye) closedEye.style.display = 'none';
                    } else {
                        eyeBtn.classList.remove('active');
                        if (openEye) openEye.style.display = 'none';
                        if (closedEye) closedEye.style.display = 'block';
                    }
                }

                // Function to handle eye icon clicks with mutual exclusivity
                function handleEyeClick(clickedBtn, lineType) {
                    // Get all eye buttons
                    const sentimentEyeBtn = document.getElementById('eye-sentiment');
                    const newsEyeBtn = document.getElementById('eye-news');
                    const indicatorsEyeBtn = document.getElementById('eye-indicators');
                    const summaryEyeBtn = document.getElementById('eye-summary');

                    const isCurrentlyActive = clickedBtn.classList.contains('active');

                    // If clicking an active button, close it (toggle off)
                    if (isCurrentlyActive) {
                        // Close the clicked button
                        toggleEyeIcon(clickedBtn, false);
                        
                        // If closing summary or sentiment, close both (they're linked)
                        if (lineType === 'summary' || lineType === 'sentiment') {
                            if (sentimentEyeBtn) toggleEyeIcon(sentimentEyeBtn, false);
                            if (summaryEyeBtn) toggleEyeIcon(summaryEyeBtn, false);
                        }
                    } else {
                        // Close ALL other buttons first (mutual exclusivity)
                        // This ensures only one line is visible at a time
                        if (newsEyeBtn) toggleEyeIcon(newsEyeBtn, false);
                        if (indicatorsEyeBtn) toggleEyeIcon(indicatorsEyeBtn, false);
                        if (sentimentEyeBtn) toggleEyeIcon(sentimentEyeBtn, false);
                        if (summaryEyeBtn) toggleEyeIcon(summaryEyeBtn, false);
                        
                        // Open the clicked button
                        toggleEyeIcon(clickedBtn, true);
                        
                        // If opening summary or sentiment, open both (they're linked)
                        if (lineType === 'summary' || lineType === 'sentiment') {
                            if (sentimentEyeBtn) toggleEyeIcon(sentimentEyeBtn, true);
                            if (summaryEyeBtn) toggleEyeIcon(summaryEyeBtn, true);
                        }
                    }

                    // Redraw oscillator with current data
                    if (window.currentChartData) {
                        drawSentimentOscillator(window.currentChartData, window.currentFullTimeframeData, window.currentTimeLabels || []);
                        
                        // Update the right-side display to show the active driver's value
                        if (window.currentChartData.length > 0) {
                            const lastPoint = window.currentChartData[window.currentChartData.length - 1];
                            let displayValue = null;
                            
                            // Determine which driver is active
                            if (lineType === 'news' && clickedBtn.classList.contains('active')) {
                                displayValue = lastPoint.processedNews != null ? lastPoint.processedNews : (lastPoint.news != null ? lastPoint.news : 0);
                            } else if (lineType === 'indicators' && clickedBtn.classList.contains('active')) {
                                displayValue = lastPoint.indicators != null ? lastPoint.indicators : 0;
                            } else if (lineType === 'sentiment' && clickedBtn.classList.contains('active')) {
                                displayValue = lastPoint.sentiment != null ? lastPoint.sentiment : 0;
                            }
                            
                            if (displayValue != null) {
                                updateSentimentDisplay({
                                    composite_score: displayValue
                                });
                            }
                        }
                    }
                }

                // Initialize summary eye and sentiment eye as active by default
                const summaryEyeBtn = document.getElementById('eye-summary');
                const sentimentEyeBtn = document.getElementById('eye-sentiment');
                
                // Ensure summary is active (it should already be active from HTML, but ensure it)
                if (summaryEyeBtn && !summaryEyeBtn.classList.contains('active')) {
                    toggleEyeIcon(summaryEyeBtn, true);
                }
                
                // Ensure sentiment eye is also active if it exists (they're synced)
                if (sentimentEyeBtn && !sentimentEyeBtn.classList.contains('active')) {
                    toggleEyeIcon(sentimentEyeBtn, true);
                }
                
                // Close all other eye buttons to ensure only summary is active
                const newsEyeBtn = document.getElementById('eye-news');
                const indicatorsEyeBtn = document.getElementById('eye-indicators');
                if (newsEyeBtn && newsEyeBtn.classList.contains('active')) {
                    toggleEyeIcon(newsEyeBtn, false);
                }
                if (indicatorsEyeBtn && indicatorsEyeBtn.classList.contains('active')) {
                    toggleEyeIcon(indicatorsEyeBtn, false);
                }
                
                // Initialize candle-decay expanded state (collapsed/fixed by default)
                const expandBtn = document.getElementById('oscillator-expand-btn');
                if (expandBtn && !expandBtn.dataset.candleDecayExpanded) {
                    expandBtn.dataset.candleDecayExpanded = 'false';
                }

                // Initialize expand/collapse icon
                updateExpandIcon();

                // Add event listeners to all eye icon buttons
                const allEyeButtons = [
                    { btn: document.getElementById('eye-sentiment'), line: 'sentiment' },
                    { btn: document.getElementById('eye-news'), line: 'news' },
                    { btn: document.getElementById('eye-indicators'), line: 'indicators' },
                    { btn: document.getElementById('eye-summary'), line: 'summary' }
                ];

                allEyeButtons.forEach(({ btn, line }) => {
                    if (btn) {
                        btn.addEventListener('click', () => {
                            handleEyeClick(btn, line);
                        });
                    }
                });

                // Function to update expand/collapse icon based on scale mode
                function updateExpandIcon() {
                    const expandBtn = document.getElementById('oscillator-expand-btn');
                    const expandIcon = expandBtn?.querySelector('.expand-icon');
                    const collapseIcon = expandBtn?.querySelector('.collapse-icon');
                    const visibleRadio = document.getElementById('scale-visible');
                    const fixedRadio = document.getElementById('scale-fixed');
                    const candleDecayRadio = document.getElementById('scale-candle-decay');
                    const isVisibleMode = visibleRadio?.checked || false;
                    const isFixedMode = fixedRadio?.checked || false;
                    const isCandleDecayMode = candleDecayRadio?.checked || false;

                    if (expandBtn && expandIcon && collapseIcon) {
                        if (isCandleDecayMode) {
                            // Candle-decay mode: check expanded state
                            const isExpanded = expandBtn.dataset.candleDecayExpanded === 'true';
                            if (isExpanded) {
                                // Show collapse icon - expanded/min-max view
                                expandIcon.style.display = 'none';
                                collapseIcon.style.display = 'block';
                            } else {
                                // Show expand icon - collapsed/fixed view
                                expandIcon.style.display = 'block';
                                collapseIcon.style.display = 'none';
                            }
                        } else if (isVisibleMode) {
                            // Show collapse icon (corners going inside) - expanded/min-max view
                            expandIcon.style.display = 'none';
                            collapseIcon.style.display = 'block';
                        } else if (isFixedMode) {
                            // Show expand icon (corners going outside) - collapsed/fixed view
                            expandIcon.style.display = 'block';
                            collapseIcon.style.display = 'none';
                        } else {
                            // Default to expand icon if neither is checked
                            expandIcon.style.display = 'block';
                            collapseIcon.style.display = 'none';
                        }
                    }
                }

                // Add click handler for expand/collapse button
                // Toggles between fixed (-100 to +100) and visible (min-max) modes
                if (expandBtn) {
                    expandBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const visibleRadio = document.getElementById('scale-visible');
                        const fixedRadio = document.getElementById('scale-fixed');
                        const candleDecayRadio = document.getElementById('scale-candle-decay');

                        // Check if in candle-decay mode
                        if (candleDecayRadio?.checked) {
                            // Toggle candle-decay expanded state
                            const isExpanded = expandBtn.dataset.candleDecayExpanded === 'true';
                            expandBtn.dataset.candleDecayExpanded = isExpanded ? 'false' : 'true';

                            // Update icon
                            updateExpandIcon();

                            // Redraw chart with new scale
                            if (window.currentChartData) {
                                drawSentimentOscillator(window.currentChartData, window.currentFullTimeframeData, window.currentTimeLabels || []);
                            }
                        } else if (visibleRadio && fixedRadio) {
                            // Toggle between fixed and visible modes for other modes
                            if (visibleRadio.checked) {
                                // Currently in visible mode, switch to fixed mode
                                fixedRadio.checked = true;
                                visibleRadio.checked = false;
                            } else {
                                // Currently in fixed mode (or other mode), switch to visible mode
                                visibleRadio.checked = true;
                                fixedRadio.checked = false;
                            }

                            // Dispatch change event to trigger chart update
                            const activeRadio = visibleRadio.checked ? visibleRadio : fixedRadio;
                            activeRadio.dispatchEvent(new Event('change'));
                        }
                    });
                }

                // Candle-Decay Quick Button (9th View) - Setup
                const candleDecayQuickBtn = document.getElementById('candle-decay-quick-btn');
                const candleDecayRadio = document.getElementById('scale-candle-decay');
                
                function updateCandleDecayQuickButton() {
                    if (candleDecayQuickBtn && candleDecayRadio) {
                        if (candleDecayRadio.checked) {
                            candleDecayQuickBtn.classList.add('active');
                        } else {
                            candleDecayQuickBtn.classList.remove('active');
                        }
                    }
                }

                // Add event listeners to scale mode radio buttons (all 9 buttons are now mutually exclusive)
                const scaleRadios = document.querySelectorAll('input[name="oscillator-scale"]');
                scaleRadios.forEach(radio => {
                    radio.addEventListener('change', async () => {
                        console.log(`Scale mode changed to: ${radio.value}`);
                        
                        // Update expand/collapse icon
                        updateExpandIcon();
                        
                        // Update candle-decay quick button state
                        updateCandleDecayQuickButton();

                        // Calculate weighted average if weighted mode is activated
                        const weightedModeActive = radio.value === 'weighted';
                        if (weightedModeActive && window.currentChartData && window.currentChartData.length > 0) {
                            console.log('âš–ï¸ Weighted mode activated - calculating weighted average');
                            
                            // Sort points by timestamp for processing
                            const sortedPoints = [...window.currentChartData].sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
                            
                            // Smooth signal transitions over 3 candles (reduced from 5 for less smoothing)
                            const SMOOTH_CANDLES = 3;
                            let smoothedSignals = [];
                            let transitionStartIndex = -1;
                            let transitionStartValue = 0;
                            let transitionTargetValue = 0;
                            
                            for (let i = 0; i < sortedPoints.length; i++) {
                                const point = sortedPoints[i];
                                const currentSignal = point.signalValue != null ? point.signalValue : 0;
                                
                                if (i === 0) {
                                    smoothedSignals.push(currentSignal);
                                    transitionStartValue = currentSignal;
                                    transitionTargetValue = currentSignal;
                                } else {
                                    const prevSignal = sortedPoints[i - 1].signalValue != null ? sortedPoints[i - 1].signalValue : 0;
                                    const prevSmoothedSignal = smoothedSignals[i - 1];
                                    
                                    if (currentSignal !== prevSignal) {
                                        // Signal changed - start new transition over 5 candles
                                        transitionStartIndex = i;
                                        transitionStartValue = prevSmoothedSignal;
                                        transitionTargetValue = currentSignal;
                                        const candlesIntoTransition = 1;
                                        const progress = candlesIntoTransition / SMOOTH_CANDLES;
                                        const smoothedSignal = transitionStartValue + (transitionTargetValue - transitionStartValue) * progress;
                                        smoothedSignals.push(smoothedSignal);
                                    } else {
                                        // Check if we're in the middle of a transition
                                        const candlesSinceTransitionStart = i - transitionStartIndex;
                                        
                                        if (transitionStartIndex >= 0 && candlesSinceTransitionStart < SMOOTH_CANDLES) {
                                            // Still transitioning - continue smoothing
                                            const progress = candlesSinceTransitionStart / SMOOTH_CANDLES;
                                            const smoothedSignal = transitionStartValue + (transitionTargetValue - transitionStartValue) * progress;
                                            smoothedSignals.push(smoothedSignal);
                                        } else {
                                            // Transition complete or no transition - use target value
                                            smoothedSignals.push(currentSignal);
                                            transitionStartValue = currentSignal;
                                            transitionTargetValue = currentSignal;
                                        }
                                    }
                                }
                            }
                            
                            // Calculate weighted value: sentiment + 70% of signal
                            sortedPoints.forEach((point, index) => {
                                const smoothedSignal = smoothedSignals[index];
                                const sentimentValue = point.sentiment != null ? point.sentiment : 0;
                                
                                // Add sentiment score with 80% of signal score (both already in -100 to +100 range)
                                // Clamp to [-100, 100]
                                point.weightedValue = Math.min(100, Math.max(-100, sentimentValue + (smoothedSignal * 0.8)));
                            });
                        }

                        // News mode: Process news scores with hold/decay logic
                        const newsModeActive = radio.value === 'news';
                        const newsCompositeModeActive = radio.value === 'news-composite';
                        const newsPriceModeActive = radio.value === 'news-price';
                        
                        if (newsModeActive && window.currentChartData && window.currentChartData.length > 0) {
                            console.log('ðŸ“° News mode activated - processing news scores with hold/decay');
                            processNewsScoresWithHoldDecay(window.currentChartData);
                        } else if (newsCompositeModeActive && window.currentChartData && window.currentChartData.length > 0) {
                            console.log('ðŸ“° News + Composite mode activated');
                            // Ensure processedNews is calculated
                            if (!document.getElementById('scale-news')?.checked) {
                                let initialProcessedNews = null;
                                if (window.currentChartData[0] && sentimentDataset && sentimentDataset.length > 0) {
                                    const latestMinutePoints = [...sentimentDataset]
                                        .filter(p => p.news != null && !isNaN(p.news))
                                        .sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime())
                                        .slice(-100);
                                    if (latestMinutePoints.length > 0) {
                                        processNewsScoresWithHoldDecay(latestMinutePoints);
                                        const latestPoint = latestMinutePoints[latestMinutePoints.length - 1];
                                        if (latestPoint.processedNews != null && !isNaN(latestPoint.processedNews)) {
                                            initialProcessedNews = latestPoint.processedNews;
                                        }
                                    }
                                }
                                processNewsScoresWithHoldDecay(window.currentChartData, initialProcessedNews);
                            }
                            // Calculate newsCompositeValue
                            window.currentChartData.forEach(point => {
                                const sentimentValue = point.sentiment != null ? point.sentiment : 0;
                                const processedNewsValue = point.processedNews != null ? point.processedNews : 0;
                                point.newsCompositeValue = sentimentValue + (processedNewsValue * 0.7);
                            });
                        } else if (newsPriceModeActive && window.currentChartData && window.currentChartData.length > 0) {
                            console.log('ðŸ“° News + Price mode activated');
                            // Ensure processedNews is calculated
                            if (!document.getElementById('scale-news')?.checked && !newsCompositeModeActive) {
                                let initialProcessedNews = null;
                                if (window.currentChartData[0] && sentimentDataset && sentimentDataset.length > 0) {
                                    const latestMinutePoints = [...sentimentDataset]
                                        .filter(p => p.news != null && !isNaN(p.news))
                                        .sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime())
                                        .slice(-100);
                                    if (latestMinutePoints.length > 0) {
                                        processNewsScoresWithHoldDecay(latestMinutePoints);
                                        const latestPoint = latestMinutePoints[latestMinutePoints.length - 1];
                                        if (latestPoint.processedNews != null && !isNaN(latestPoint.processedNews)) {
                                            initialProcessedNews = latestPoint.processedNews;
                                        }
                                    }
                                }
                                processNewsScoresWithHoldDecay(window.currentChartData, initialProcessedNews);
                            }
                            // Calculate newsPriceValue = previous candle's price + (processedNews * 0.7)
                            // Use previous candle's price to allow live replication
                            window.currentChartData.forEach((point, index) => {
                                // Get previous candle's price (or current if it's the first point)
                                let previousPrice = 0;
                                if (index > 0 && window.currentChartData[index - 1].price != null) {
                                    previousPrice = window.currentChartData[index - 1].price;
                                } else if (point.price != null) {
                                    // Fallback to current price if no previous candle available
                                    previousPrice = point.price;
                                }
                                const processedNewsValue = point.processedNews != null ? point.processedNews : 0;
                                point.newsPriceValue = previousPrice + (processedNewsValue * 0.7);
                            });
                        }

                        // Candle-Based Decay mode: Process news up signals with candle-triggered decay
                        // CRITICAL: Process FULL sentimentDataset once, then copy to visible points
                        const candleDecayModeActive = radio.value === 'candle-decay';
                        if (candleDecayModeActive) {
                            // Process the full dataset ONCE
                            if (sentimentDataset && sentimentDataset.length > 0) {
                                const firstPoint = sentimentDataset[0];
                                if (!firstPoint._candleDecayProcessed) {
                                    console.log(`ðŸ•¯ï¸ Candle-Based Decay mode activated: Processing FULL dataset (${sentimentDataset.length} points)`);
                                    processCandleBasedDecay(sentimentDataset);
                                    // Mark all points as processed
                                    sentimentDataset.forEach(p => p._candleDecayProcessed = true);
                                } else {
                                    console.log(`âœ… Candle-Based Decay: Already processed, skipping`);
                                }

                                // Copy candleDecayValue from sentimentDataset to visible currentChartData
                                if (window.currentChartData && window.currentChartData.length > 0) {
                                    const sentimentMap = new Map();
                                    sentimentDataset.forEach(p => {
                                        if (p.timestamp) {
                                            sentimentMap.set(p.timestamp.getTime(), p.candleDecayValue);
                                        }
                                    });
                                    let copiedCount = 0;
                                    window.currentChartData.forEach(p => {
                                        if (p.timestamp) {
                                            const value = sentimentMap.get(p.timestamp.getTime());
                                            if (value !== undefined) {
                                                p.candleDecayValue = value;
                                                copiedCount++;
                                            }
                                        }
                                    });
                                    console.log(`âœ… Copied candleDecayValue to ${copiedCount}/${window.currentChartData.length} visible points`);
                                }
                            }
                        }

                        // Signal values are already attached in updateChart(), so no need to attach here
                        // Redraw oscillator with new scale mode
                        if (window.currentChartData) {
                            drawSentimentOscillator(window.currentChartData, window.currentFullTimeframeData, window.currentTimeLabels || []);
                        }

                        // Update the oscillator score display with the last value from current view
                        // This ensures the score box shows the correct value based on the current mode
                        if (window.currentChartData && window.currentChartData.length > 0) {
                            const signalModeActive = radio.value === 'signal';
                            const candleDecayModeActive = radio.value === 'candle-decay';
                            const lastPoint = window.currentChartData[window.currentChartData.length - 1];
                            let displayValue;
                            
                            if (candleDecayModeActive && lastPoint.candleDecayValue != null) {
                                // In candle-decay mode, use candleDecayValue
                                displayValue = lastPoint.candleDecayValue;
                            } else if (signalModeActive && lastPoint.signalValue != null) {
                                // In signal mode, use signal value
                                displayValue = lastPoint.signalValue;
                            } else if (weightedModeActive && lastPoint.weightedValue != null) {
                                // In weighted mode, use weighted average value
                                displayValue = lastPoint.weightedValue;
                            } else if (newsCompositeModeActive && lastPoint.newsCompositeValue != null) {
                                // In news + composite mode, use newsCompositeValue
                                displayValue = lastPoint.newsCompositeValue;
                            } else if (newsPriceModeActive && lastPoint.newsPriceValue != null) {
                                // In news + price mode, use newsPriceValue
                                displayValue = lastPoint.newsPriceValue;
                            } else if (newsModeActive) {
                                // In news mode, use processedNews if available, otherwise fallback to news
                                displayValue = lastPoint.processedNews != null ? lastPoint.processedNews : (lastPoint.news != null ? lastPoint.news : 0);
                            } else {
                                // In regular mode, use sentiment value
                                displayValue = lastPoint.sentiment ?? currentCompositeScore ?? 0;
                            }
                            
                            updateSentimentDisplay({
                                composite_score: displayValue
                            });
                        } else {
                            // Fallback to current composite score if no chart data
                            updateSentimentDisplay({
                                composite_score: currentCompositeScore
                            });
                        }
                    });
                });

                // Candle-Decay Quick Button (9th View) - Click handler
                if (candleDecayQuickBtn && candleDecayRadio) {
                    // Click handler: toggle the radio button
                    candleDecayQuickBtn.addEventListener('click', () => {
                        candleDecayRadio.checked = true;
                        candleDecayRadio.dispatchEvent(new Event('change'));
                        updateCandleDecayQuickButton();
                    });
                    
                    // Sync state when radio button changes
                    candleDecayRadio.addEventListener('change', updateCandleDecayQuickButton);
                    
                    // Initial state sync
                    updateCandleDecayQuickButton();
                }

                console.log('Dashboard initialized successfully');
            } catch (error) {
                console.error('Error initializing dashboard:', error);
                // Show fallback values
                const scoreElement = document.querySelector('.score-value');
                const statusElement = document.querySelector('.score-status');
                if (scoreElement) scoreElement.textContent = '0.0';
                if (statusElement) statusElement.textContent = 'LOADING...';
            }
        }

        // ===== GRANULAR DATA AUTO-REFRESH (dynamic interval based on timeframe) =====

        function startGranularRefresh() {
            // Stop any existing interval
            stopGranularRefresh();

            // Get the update interval for the current timeframe
            const config = timeframeConfig[currentTimeframe];
            const updateInterval = config?.updateInterval || 1000; // Default to 1 second if not specified

            console.log(`ðŸ”„ Starting granular data auto-refresh (${updateInterval}ms interval for ${currentTimeframe} timeframe)`);

            granularRefreshInterval = setInterval(async () => {
                console.log(`â±ï¸ Auto-refresh tick (market: ${isMarketOpen ? 'OPEN' : 'CLOSED'}, scroll: ${scrollPosition}%)`);

                // Only refresh if market is open
                if (!isMarketOpen) {
                    console.log('âŒ Market is closed - skipping granular refresh');
                    return;
                }

                // Only auto-update if viewing most recent data
                if (scrollPosition !== 100) {
                    console.log('âŒ User viewing historical data - skipping granular refresh');
                    return;
                }

                console.log('âœ… Proceeding with data fetch...');

                try {
                    // Store dataset length before fetch
                    const beforeLength = granularDataType === 'second'
                        ? secondCandlesDataset.length
                        : tickCandlesDataset.length;

                    // Fetch incremental updates
                    if (granularDataType === 'second') {
                        await fetchSecondCandles(lastGranularTimestamp);
                    } else {
                        await fetchTickCandles(lastGranularTimestamp);
                    }

                    // Check if dataset actually grew
                    const afterLength = granularDataType === 'second'
                        ? secondCandlesDataset.length
                        : tickCandlesDataset.length;

                    if (afterLength > beforeLength) {
                        console.log(`âœ… Dataset grew by ${afterLength - beforeLength} candles (${beforeLength} â†’ ${afterLength})`);
                    } else {
                        console.log(`â„¹ï¸ No new data added (dataset still ${afterLength} candles)`);
                    }

                    // Log the latest timestamp in the dataset
                    const latestCandle = granularDataType === 'second'
                        ? secondCandlesDataset[secondCandlesDataset.length - 1]
                        : tickCandlesDataset[tickCandlesDataset.length - 1];
                    if (latestCandle) {
                        const dataAge = (Date.now() - latestCandle.timestamp.getTime()) / 1000;
                        console.log(`ðŸ“… Latest candle in dataset: ${latestCandle.timestamp.toISOString()} (${dataAge.toFixed(0)}s ago)`);

                        // Warn if data is stale (more than 10 seconds old)
                        if (dataAge > 10) {
                            console.warn(`âš ï¸ DATA IS STALE! Latest data is ${dataAge.toFixed(0)} seconds old. Backend may not be saving new data.`);
                        }
                    }

                    // ALWAYS update chart, even if no new data
                    // This ensures the sliding window moves forward with current time
                    await updateChart(currentTimeframe);

                } catch (error) {
                    console.error('Error in granular auto-refresh:', error);
                }
            }, updateInterval); // Use dynamic interval based on timeframe
        }
        
        function stopGranularRefresh() {
            if (granularRefreshInterval) {
                console.log('â¹ï¸ Stopping granular data auto-refresh');
                clearInterval(granularRefreshInterval);
                granularRefreshInterval = null;
            }
        }

        // Update data periodically (every 60 seconds) - only when market is open
        setInterval(async () => {
            // Only refresh if market is open
            if (!isMarketOpen) {
                console.log('Market is closed - skipping auto-refresh');
                return;
            }

            try {
                console.log('Auto-refreshing dashboard data...');
                await fetchDashboardData();

                // Only auto-update chart if user is viewing the most recent data (scrollPosition = 100)
                // Otherwise, don't interrupt their historical viewing
                if (scrollPosition === 100) {
                    await updateChart(currentTimeframe);
                } else {
                    console.log('User is viewing historical data - skipping chart auto-refresh');
                }
            } catch (error) {
                console.error('Error updating dashboard:', error);
            }
        }, 60000); // Check every 60 seconds

        // Unified chart hover functionality
        const chartsWrapper = document.getElementById('charts-wrapper');
        const chartCanvas = document.getElementById('chart-canvas');
        const oscillatorDiv = document.getElementById('chart-oscillator');
        const unifiedHoverLine = document.getElementById('unified-hover-line');
        const timeLabel = document.getElementById('time-label');
        const mainTooltip = document.getElementById('chart-tooltip');
        const oscillatorTooltip = document.getElementById('oscillator-tooltip');
        const mainTooltipValue = mainTooltip.querySelector('.tooltip-value');
        const mainTooltipTime = mainTooltip.querySelector('.tooltip-time');
        const oscillatorTooltipValue = oscillatorTooltip.querySelector('.tooltip-value');
        const oscillatorTooltipTime = oscillatorTooltip.querySelector('.tooltip-time');

        function interpolateValue(x, dataPoints) {
            if (!dataPoints || dataPoints.length === 0) return { price: null, sentiment: null, time: 'Now', timestamp: new Date() };
            
            // Find the two closest data points
            let before = dataPoints[0];
            let after = dataPoints[dataPoints.length - 1];
            
            for (let i = 0; i < dataPoints.length - 1; i++) {
                if (x >= dataPoints[i].x && x <= dataPoints[i + 1].x) {
                    before = dataPoints[i];
                    after = dataPoints[i + 1];
                    break;
                }
            }
            
            // Linear interpolation for price value
            const ratio = (x - before.x) / (after.x - before.x);
            let price = null;
            if (before.price != null && after.price != null) {
                price = before.price + ratio * (after.price - before.price);
            } else if (before.price != null) {
                price = before.price;
            } else if (after.price != null) {
                price = after.price;
            }

            // Linear interpolation for sentiment (if available)
            let sentiment = null;
            if (before.sentiment != null && after.sentiment != null) {
                sentiment = before.sentiment + ratio * (after.sentiment - before.sentiment);
            } else if (before.sentiment != null) {
                sentiment = before.sentiment;
            } else if (after.sentiment != null) {
                sentiment = after.sentiment;
            }

            // Get signal value if in signal mode (no interpolation for binary values)
            let signalValue = null;
            const closestPoint = ratio < 0.5 ? before : after;
            if (closestPoint.signalValue != null) {
                signalValue = closestPoint.signalValue;
            }

            // Get other driver values from closest point (no interpolation for these)
            const news = closestPoint.news != null ? closestPoint.news : null;
            const processedNews = closestPoint.processedNews != null ? closestPoint.processedNews : null;
            const indicators = closestPoint.indicators != null ? closestPoint.indicators : null;
            const weightedValue = closestPoint.weightedValue != null ? closestPoint.weightedValue : null;
            const newsCompositeValue = closestPoint.newsCompositeValue != null ? closestPoint.newsCompositeValue : null;
            const newsPriceValue = closestPoint.newsPriceValue != null ? closestPoint.newsPriceValue : null;
            const candleDecayValue = closestPoint.candleDecayValue != null ? closestPoint.candleDecayValue : null;

            // Use the closest data point's time
            const time = closestPoint.timeLabel || closestPoint.timestamp?.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            }) || 'N/A';

            return { 
                price: price, 
                sentiment: sentiment, 
                signalValue: signalValue, 
                news: news,
                processedNews: processedNews,
                indicators: indicators,
                weightedValue: weightedValue,
                newsCompositeValue: newsCompositeValue,
                newsPriceValue: newsPriceValue,
                candleDecayValue: candleDecayValue,
                time: time, 
                timestamp: closestPoint.timestamp 
            };
        }

        // Unified hover handler for both charts
        function handleChartHover(e, isMainChart) {
            // Always use chartCanvas as reference for ALL calculations to ensure perfect alignment
            const chartCanvasRect = chartCanvas.getBoundingClientRect();
            const oscillatorRect = oscillatorDiv.getBoundingClientRect();

            // Calculate mouse X position relative to chartCanvas (unified reference point)
            const mouseX = e.clientX - chartCanvasRect.left;

            // Chart-canvas is already positioned with left: 20px and right: 10%, so it IS the effective chart area
            // No need to subtract offset or use percentage - use the full canvas width
            const effectiveChartWidth = chartCanvasRect.width;

            // Clamp to chart bounds (allow small tolerance for edge cases)
            if (mouseX < -1 || mouseX > effectiveChartWidth + 1) {
                hideAllHoverElements();
                return;
            }
            
            // Clamp mouseX to valid range for calculations
            const clampedMouseX = Math.max(0, Math.min(mouseX, effectiveChartWidth));

            // Calculate position as percentage (0-100) within the effective chart area
            const percentX = (clampedMouseX / effectiveChartWidth) * 100;

            // Use the globally stored current chart data
            if (!window.currentChartData) return;

            // Interpolate the value based on X position
            const result = interpolateValue(percentX, window.currentChartData);

            // Show unified hover line (spans both charts) - position relative to charts-wrapper
            const chartsWrapperRect = chartsWrapper.getBoundingClientRect();
            const chartCanvasOffsetX = chartCanvasRect.left - chartsWrapperRect.left;
            unifiedHoverLine.style.display = 'block';
            unifiedHoverLine.style.left = (clampedMouseX + chartCanvasOffsetX) + 'px';

            // Show time label between charts and oscillator (follows cursor x-position)
            timeLabel.classList.add('show');
            timeLabel.innerHTML = `<strong>${result.time}</strong>`;
            // Position time label to follow cursor x-position (same as hover line)
            const labelWidth = 50;
            const labelXRelativeToCanvas = Math.max(0, Math.min(clampedMouseX - (labelWidth / 2), chartCanvasRect.width - labelWidth));
            const labelX = labelXRelativeToCanvas + chartCanvasOffsetX;
            timeLabel.style.left = labelX + 'px';

            if (isMainChart) {
                // Show main chart tooltip
                mainTooltip.style.display = 'block';
                oscillatorTooltip.style.display = 'none';

                // Display price as main value
                if (result.price != null) {
                    mainTooltipValue.textContent = `$${result.price.toFixed(2)}`;
                } else {
                    mainTooltipValue.textContent = 'N/A';
                }

                // Show sentiment score as secondary info
                const tooltipSentiment = document.getElementById('tooltip-sentiment');
                if (tooltipSentiment) {
                    // Check if signal mode, news mode, or weighted mode is active (radio buttons)
                    const signalModeActive = document.getElementById('scale-signal')?.checked || false;
                    const newsModeActive = document.getElementById('scale-news')?.checked || false;
                    const weightedModeActive = document.getElementById('scale-weighted')?.checked || false;
                    
                    // Check which eye icon is active (for driver toggles)
                    const newsEyeActive = document.getElementById('eye-news')?.classList.contains('active') || false;
                    const indicatorsEyeActive = document.getElementById('eye-indicators')?.classList.contains('active') || false;
                    const sentimentEyeActive = document.getElementById('eye-sentiment')?.classList.contains('active') || false;

                    let displayValue = null;
                    if (signalModeActive && result.signalValue != null) {
                        displayValue = result.signalValue; // Use signal value in signal mode
                    } else if (weightedModeActive && result.weightedValue != null) {
                        displayValue = result.weightedValue; // Use weighted average value
                    } else if (newsModeActive || newsEyeActive) {
                        // Use processedNews if available, otherwise fallback to news
                        displayValue = result.processedNews != null ? result.processedNews : (result.news != null ? result.news : 0);
                    } else if (indicatorsEyeActive && result.indicators != null) {
                        displayValue = result.indicators; // Use indicators value
                    } else if (sentimentEyeActive && result.sentiment != null) {
                        displayValue = result.sentiment; // Use sentiment value
                    } else if (result.sentiment != null) {
                        displayValue = result.sentiment; // Use regular sentiment as fallback
                    }

                    if (displayValue != null) {
                        const sentimentDisplay = displayValue > 0 ? `+${Math.round(displayValue)}` : Math.round(displayValue);
                        tooltipSentiment.textContent = `Score: ${sentimentDisplay}`;
                        tooltipSentiment.style.display = 'block';
                    } else {
                        tooltipSentiment.style.display = 'none';
                    }
                }

                // Position tooltip using mouse X position (relative to chartCanvas)
                const tooltipX = clampedMouseX + 15;
                const tooltipY = e.clientY - chartCanvasRect.top - 60;

                mainTooltip.style.left = tooltipX + 'px';
                mainTooltip.style.top = tooltipY + 'px';

                // Adjust tooltip position if it goes off screen (respect chart bounds)
                // Tooltip is inside chart-canvas, so bounds are the canvas width
                if (tooltipX + mainTooltip.offsetWidth > effectiveChartWidth) {
                    mainTooltip.style.left = (clampedMouseX - mainTooltip.offsetWidth - 15) + 'px';
                }
                if (tooltipY < 0) {
                    mainTooltip.style.top = '10px';
                }
            } else {
                // Show oscillator tooltip
                oscillatorTooltip.style.display = 'block';
                mainTooltip.style.display = 'none';

                // Check if signal mode, news mode, weighted mode, or new composite/price modes are active (radio buttons)
                const signalModeActive = document.getElementById('scale-signal')?.checked || false;
                const newsModeActive = document.getElementById('scale-news')?.checked || false;
                const weightedModeActive = document.getElementById('scale-weighted')?.checked || false;
                const newsCompositeModeActive = document.getElementById('scale-news-composite')?.checked || false;
                const newsPriceModeActive = document.getElementById('scale-news-price')?.checked || false;
                const candleDecayModeActive = document.getElementById('scale-candle-decay')?.checked || false;
                
                // Check which eye icon is active (for driver toggles)
                const newsEyeActive = document.getElementById('eye-news')?.classList.contains('active') || false;
                const indicatorsEyeActive = document.getElementById('eye-indicators')?.classList.contains('active') || false;
                const sentimentEyeActive = document.getElementById('eye-sentiment')?.classList.contains('active') || false;

                // Display sentiment as main value (radio buttons take priority, then eye icons)
                let displayValue = null;
                let tooltipLabel = 'Sentiment Score';
                let tooltipColor = '#ff8c42'; // Default orange
                
                if (signalModeActive && result.signalValue != null) {
                    displayValue = result.signalValue; // Use binary signal value
                    tooltipLabel = 'Signal Score';
                    tooltipColor = '#ffffff'; // White for signal
                } else if (weightedModeActive && result.weightedValue != null) {
                    displayValue = result.weightedValue; // Use weighted average value
                    tooltipLabel = 'Weighted Score';
                    tooltipColor = '#ff8c42'; // Orange for weighted
                } else if (newsCompositeModeActive && result.newsCompositeValue != null) {
                    displayValue = result.newsCompositeValue; // Use news + composite value
                    tooltipLabel = 'News + Composite';
                    tooltipColor = '#ff8c42'; // Orange
                } else if (newsPriceModeActive && result.newsPriceValue != null) {
                    displayValue = result.newsPriceValue; // Use news + price value
                    tooltipLabel = 'News + Price';
                    tooltipColor = '#10b981'; // Green
                } else if (candleDecayModeActive && result.candleDecayValue != null) {
                    displayValue = result.candleDecayValue; // Use candle decay value
                    tooltipLabel = 'Candle Decay';
                    tooltipColor = '#a855f7'; // Purple for candle-based decay
                } else if (newsModeActive || newsEyeActive) {
                    // Use processedNews if available, otherwise fallback to news
                    displayValue = result.processedNews != null ? result.processedNews : (result.news != null ? result.news : 0);
                    tooltipLabel = 'News Score';
                    tooltipColor = '#ec4899'; // Pink for news
                } else if (indicatorsEyeActive && result.indicators != null) {
                    displayValue = result.indicators; // Use indicators value
                    tooltipLabel = 'Indicators Score';
                    tooltipColor = '#3b82f6'; // Blue for indicators
                } else if (sentimentEyeActive && result.sentiment != null) {
                    displayValue = result.sentiment; // Use sentiment value
                    tooltipLabel = 'Sentiment Score';
                    tooltipColor = '#ff8c42'; // Orange for sentiment
                } else if (result.sentiment != null) {
                    displayValue = result.sentiment; // Use regular sentiment as fallback
                    tooltipLabel = 'Sentiment Score';
                    tooltipColor = '#ff8c42'; // Orange for default
                }

                // Update tooltip label
                const oscillatorTooltipLabel = document.querySelector('#oscillator-tooltip .tooltip-label');
                if (oscillatorTooltipLabel) {
                    oscillatorTooltipLabel.textContent = tooltipLabel;
                }

                if (displayValue != null) {
                    const sentimentDisplay = displayValue > 0 ? `+${Math.round(displayValue)}` : Math.round(displayValue);
                    oscillatorTooltipValue.textContent = sentimentDisplay;
                    oscillatorTooltipValue.style.color = tooltipColor;
                } else {
                    oscillatorTooltipValue.textContent = 'N/A';
                    oscillatorTooltipValue.style.color = '#ff8c42';
                }

                oscillatorTooltipTime.textContent = result.time;

                // Position tooltip using mouse X position (relative to chartCanvas)
                // For oscillator, we need to calculate mouseX relative to oscillator
                const oscillatorMouseX = e.clientX - oscillatorRect.left;
                const tooltipX = oscillatorMouseX + 15;
                const tooltipY = e.clientY - oscillatorRect.top - 75;

                oscillatorTooltip.style.left = tooltipX + 'px';
                oscillatorTooltip.style.top = tooltipY + 'px';

                // Adjust tooltip position if it goes off screen (respect oscillator bounds)
                // Oscillator tooltip is inside oscillator div, so bounds are the oscillator width
                if (tooltipX + oscillatorTooltip.offsetWidth > oscillatorRect.width) {
                    oscillatorTooltip.style.left = (oscillatorMouseX - oscillatorTooltip.offsetWidth - 15) + 'px';
                }
                if (tooltipY < 0) {
                    oscillatorTooltip.style.top = '10px';
                }
            }
        }

        function hideAllHoverElements() {
            unifiedHoverLine.style.display = 'none';
            timeLabel.classList.remove('show');
            mainTooltip.style.display = 'none';
            oscillatorTooltip.style.display = 'none';
        }

        // Main chart hover events
        chartCanvas.addEventListener('mousemove', (e) => handleChartHover(e, true));
        chartCanvas.addEventListener('mouseleave', hideAllHoverElements);

        // Oscillator hover events
        oscillatorDiv.addEventListener('mousemove', (e) => handleChartHover(e, false));
        oscillatorDiv.addEventListener('mouseleave', hideAllHoverElements);

        // Double-click on oscillator score display to toggle scale selector visibility
        const oscillatorScoreDisplay = document.querySelector('.oscillator-score-display');
        const oscillatorScaleSelector = document.getElementById('oscillator-scale-selector');
        if (oscillatorScoreDisplay && oscillatorScaleSelector) {
            oscillatorScoreDisplay.addEventListener('dblclick', () => {
                oscillatorScaleSelector.classList.toggle('visible');
            });
        }

        // Hover tooltip functionality
        const hoverTooltip = document.getElementById('hover-tooltip');
        const tooltipText = document.getElementById('tooltip-text');
        const tooltipElements = document.querySelectorAll('.has-tooltip');

        tooltipElements.forEach(element => {
            element.addEventListener('mouseenter', (e) => {
                const text = element.getAttribute('data-tooltip');
                
                tooltipText.textContent = text;
                hoverTooltip.classList.add('show');
                
                // Position tooltip near cursor
                updateTooltipPosition(e);
            });

            element.addEventListener('mousemove', (e) => {
                updateTooltipPosition(e);
            });

            element.addEventListener('mouseleave', () => {
                hoverTooltip.classList.remove('show');
            });
        });

        function updateTooltipPosition(e) {
            const offsetX = 15;
            const offsetY = 15;
            let x = e.clientX + offsetX;
            let y = e.clientY + offsetY;

            // Keep tooltip on screen
            const tooltipRect = hoverTooltip.getBoundingClientRect();
            if (x + tooltipRect.width > window.innerWidth) {
                x = e.clientX - tooltipRect.width - offsetX;
            }
            if (y + tooltipRect.height > window.innerHeight) {
                y = e.clientY - tooltipRect.height - offsetY;
            }

            hoverTooltip.style.left = x + 'px';
            hoverTooltip.style.top = y + 'px';
        }

        // ===== ONBOARDING MODAL FUNCTIONALITY =====
        
        /**
         * Check if user needs onboarding and show modal if needed
         * Uses localStorage to track completion per user
         */
        async function checkAndShowOnboarding() {
            try {
                const user = window.Clerk.user;
                if (!user) return;

                const userId = user.id;
                const onboardingKey = `onboarding_completed_${userId}`;
                
                // Check if user has already completed onboarding
                const hasCompletedOnboarding = localStorage.getItem(onboardingKey) === 'true';
                
                if (!hasCompletedOnboarding) {
                    // Show onboarding modal
                    showOnboardingModal();
                }
            } catch (error) {
                console.error('Error checking onboarding status:', error);
            }
        }

        /**
         * Show the onboarding modal
         */
        function showOnboardingModal() {
            const overlay = document.getElementById('onboarding-modal-overlay');
            if (overlay) {
                overlay.classList.add('show');
                // Prevent body scroll
                document.body.style.overflow = 'hidden';
            }
        }

        /**
         * Hide the onboarding modal
         */
        function hideOnboardingModal() {
            const overlay = document.getElementById('onboarding-modal-overlay');
            if (overlay) {
                overlay.classList.remove('show');
                // Restore body scroll
                document.body.style.overflow = '';
            }
        }

        /**
         * Mark onboarding as completed
         */
        async function completeOnboarding(selectedLanguage) {
            try {
                const user = window.Clerk.user;
                if (!user) return;

                const userId = user.id;
                const onboardingKey = `onboarding_completed_${userId}`;
                
                // Save selected language (optional, for future use)
                if (selectedLanguage) {
                    localStorage.setItem(`user_language_${userId}`, selectedLanguage);
                }
                
                // Mark onboarding as completed
                localStorage.setItem(onboardingKey, 'true');
                
                // Hide modal
                hideOnboardingModal();
            } catch (error) {
                console.error('Error completing onboarding:', error);
                // Hide modal anyway
                hideOnboardingModal();
            }
        }

        // Initialize onboarding modal functionality
        document.addEventListener('DOMContentLoaded', () => {
            const languageOptions = document.querySelectorAll('.language-option');
            const languageContinueBtn = document.getElementById('language-continue-btn');
            const disclaimerContinueBtn = document.getElementById('disclaimer-continue-btn');
            const stepLanguage = document.getElementById('step-language');
            const stepDisclaimer = document.getElementById('step-disclaimer');
            const progressDot1 = document.getElementById('progress-dot-1');
            const progressDot2 = document.getElementById('progress-dot-2');

            let selectedLanguage = null;

            // Language selection
            languageOptions.forEach(option => {
                option.addEventListener('click', () => {
                    // Remove previous selection
                    languageOptions.forEach(opt => opt.classList.remove('selected'));

                    // Select new option
                    option.classList.add('selected');
                    selectedLanguage = option.dataset.lang;

                    // Apply language immediately
                    setLanguage(selectedLanguage);

                    // Enable continue button
                    languageContinueBtn.disabled = false;
                });
            });

            // Continue from language step
            languageContinueBtn.addEventListener('click', () => {
                if (!selectedLanguage) return;

                // Switch to disclaimer step
                stepLanguage.classList.remove('active');
                stepDisclaimer.classList.add('active');

                // Update progress dots
                progressDot1.classList.remove('active');
                progressDot2.classList.add('active');
            });

            // Disclaimer checkbox handling
            const disclaimerCheckbox = document.getElementById('disclaimer-checkbox');
            if (disclaimerCheckbox) {
                disclaimerCheckbox.addEventListener('change', () => {
                    // Enable/disable continue button based on checkbox state
                    disclaimerContinueBtn.disabled = !disclaimerCheckbox.checked;
                });
            }

            // Continue from disclaimer step (complete onboarding)
            disclaimerContinueBtn.addEventListener('click', () => {
                completeOnboarding(selectedLanguage);
            });
        });

        // Language selector functionality for main navigation
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Setting up language selector...');
            const languageSelector = document.getElementById('language-selector');
            console.log('Language selector element:', languageSelector);
            if (languageSelector) {
                languageSelector.addEventListener('click', (e) => {
                    e.preventDefault();
                    console.log('Language selector clicked!');
                    showLanguageModal();
                });
                console.log('Language selector event listener added');
            } else {
                console.error('Language selector element not found!');
            }
        });

        // Show language selection modal
        function showLanguageModal() {
            const languages = [
                { code: 'en', name: 'English', nativeName: 'English' },
                { code: 'es', name: 'Spanish', nativeName: 'EspaÃ±ol' },
                { code: 'fr', name: 'French', nativeName: 'FranÃ§ais' },
                { code: 'de', name: 'German', nativeName: 'Deutsch' },
                { code: 'zh', name: 'Chinese', nativeName: 'ä¸­æ–‡' },
                { code: 'ja', name: 'Japanese', nativeName: 'æ—¥æœ¬èªž' }
            ];

            const currentLang = getCurrentLanguage();

            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(4px);
                z-index: 10000; display: flex; align-items: center; justify-content: center;
            `;

            const content = document.createElement('div');
            content.style.cssText = `
                background: #1a1a1a; border: 1px solid #2a2a2a; border-radius: 16px;
                max-width: 500px; width: 90%; padding: 40px 48px; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            `;

            const title = document.createElement('h2');
            title.textContent = 'Select Language';
            title.style.cssText = `
                font-size: 28px; font-weight: 700; color: #fff;
                margin-bottom: 24px; text-align: center;
            `;

            const langGrid = document.createElement('div');
            langGrid.style.cssText = `
                display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 24px;
            `;

            languages.forEach(lang => {
                const langBtn = document.createElement('div');
                langBtn.style.cssText = `
                    background: #0f0f0f; border: 2px solid ${lang.code === currentLang ? '#10b981' : '#2a2a2a'};
                    border-radius: 12px; padding: 16px; cursor: pointer; transition: all 0.2s ease;
                    display: flex; flex-direction: column; gap: 4px; text-align: center;
                `;

                langBtn.innerHTML = `
                    <div style="font-size: 16px; font-weight: 600; color: ${lang.code === currentLang ? '#10b981' : '#fff'};">${lang.nativeName}</div>
                    <div style="font-size: 12px; color: #888; text-transform: uppercase; letter-spacing: 1px;">${lang.code}</div>
                `;

                langBtn.addEventListener('mouseenter', () => {
                    if (lang.code !== currentLang) {
                        langBtn.style.background = '#1a1a1a';
                        langBtn.style.borderColor = '#333';
                    }
                });

                langBtn.addEventListener('mouseleave', () => {
                    if (lang.code !== currentLang) {
                        langBtn.style.background = '#0f0f0f';
                        langBtn.style.borderColor = '#2a2a2a';
                    }
                });

                langBtn.addEventListener('click', () => {
                    setLanguage(lang.code);
                    document.body.removeChild(modal);
                });

                langGrid.appendChild(langBtn);
            });

            const closeBtn = document.createElement('button');
            closeBtn.textContent = 'Close';
            closeBtn.style.cssText = `
                width: 100%; padding: 14px 32px; background: #ffffff; color: #000000;
                border: none; border-radius: 12px; font-size: 16px; font-weight: 600;
                cursor: pointer; transition: all 0.2s ease; font-family: inherit;
            `;

            closeBtn.addEventListener('mouseenter', () => {
                closeBtn.style.background = '#e0e0e0';
            });

            closeBtn.addEventListener('mouseleave', () => {
                closeBtn.style.background = '#ffffff';
            });

            closeBtn.addEventListener('click', () => {
                document.body.removeChild(modal);
            });

            content.appendChild(title);
            content.appendChild(langGrid);
            content.appendChild(closeBtn);
            modal.appendChild(content);

            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });

            document.body.appendChild(modal);
        }
    </script>
</body>
</html>

