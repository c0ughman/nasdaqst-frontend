<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NASDAQ Sentiment Dashboard</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">

    <!-- Translation System -->
    <script src="translations.js"></script>

    <!-- Clerk SDK -->
    <script
        async
        crossorigin="anonymous"
        data-clerk-publishable-key="pk_test_Zmxvd2luZy1naWJib24tNjUuY2xlcmsuYWNjb3VudHMuZGV2JA"
        src="https://flowing-gibbon-65.clerk.accounts.dev/npm/@clerk/clerk-js@5/dist/clerk.browser.js"
        type="text/javascript"
    ></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            overflow: hidden;
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: black;
            min-height: 100vh;
            max-height: 100vh;
            margin: 0;
            color: white;
            padding: 10px 0px;
            overflow: hidden;
            height: 100%;
        }

        .main-wrapper {
            width: 100%;
            max-width: 100%;
        }

        .container {
            width: 95%;
            display: grid;
            grid-template-columns: 0.7fr 3.3fr;
            grid-template-rows: minmax(0, 0.6fr) auto auto auto auto auto auto;
            row-gap: 18px;
            column-gap: 15px;
            margin: 0 auto;
        }

        .card {
            background: #333333;
            border-radius: 16px;
            padding: 22px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
        }

        .card.right-top {
            padding: 8px 32px;
        }

        .left-column-wrapper {
            grid-column: 1;
            grid-row: 1 / 7;
            display: grid;
            grid-template-rows: 3fr 7fr;
            row-gap: 18px;
        }

        .left-top {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding-top: 24px;
            padding-bottom: 24px;
            padding-left: 16px;
            padding-right: 16px;
            margin-top: -5px;
            margin-bottom: 0px;
            overflow: hidden;
            box-sizing: border-box;
        }

        .left-bottom {
            display: flex;
            flex-direction: column;
            padding: 22px;
            margin-top: 0px;
        }

        .right-top {
            grid-column: 2;
            grid-row: 1 / 2;
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 8px;
            align-items: center;
            margin-bottom: 70px;
            margin-top: -5px;
            position: relative;
            z-index: 100;
        }

        .right-top-item {
            background: #282828;
            border-radius: 12px;
            padding: 8px 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 70%;
            min-height: 44px;
            position: relative;
        }


        .bottom-row {
            grid-column: 2;
            grid-row: 2 / 7;
            padding: 12px 19px 0px 19px;
            margin-top: -10px;
            position: relative;
            z-index: 1;
        }

        /* Logout link styles */
        .logout-link-container {
            grid-column: 1 / -1;
            display: flex;
            justify-content: flex-end;
            margin-top: -10px;
            margin-bottom: 20px;
            padding-top: 0;
        }

        .logout-link {
            color: #888;
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            transition: color 0.2s ease;
            cursor: pointer;
            margin-right: 30px;
        }

        .logout-link:hover {
            color: #fff;
        }

        /* Sentiment Score Styles */
        .score-label {
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 1.5px;
            color: #fff;
            margin-bottom: 10px;
            text-transform: capitalize;
        }

        .score-value {
            font-size: 64px;
            font-weight: 700;
            background: linear-gradient(135deg, #10b981 0%, #34d399 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1;
            margin-bottom: 6px;
            filter: drop-shadow(0 0 20px rgba(16, 185, 129, 0.3));
        }

        .score-status {
            font-size: 16px;
            font-weight: 600;
            color: #10b981;
            letter-spacing: 2px;
            text-shadow: 0 0 15px rgba(16, 185, 129, 0.4);
        }

        /* Time Zone Styles */
        .timezone-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 24px;
            width: 100%;
            align-items: center;
        }

        .nav-links {
            display: flex;
            gap: 24px;
            align-items: center;
        }

        .nav-link {
            color: #fff;
            font-size: 13px;
            font-weight: 500;
            text-decoration: none;
            cursor: pointer;
            transition: color 0.2s ease;
            white-space: nowrap;
        }

        .nav-link:hover {
            color: #ccc;
        }

        .time-zone-group {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .time-display {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .time-display:hover {
            opacity: 1;
        }

        .current-time {
            font-size: 15px;
            font-weight: 600;
            letter-spacing: -0.5px;
            color: #fff;
        }

        .timezone-chevron {
            font-size: 13px;
            color: #888;
            transition: transform 0.2s ease;
        }

        .time-display:hover .timezone-chevron {
            color: #ccc;
        }

        .timezone-dropdown {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 12px;
            padding: 8px;
            min-width: 420px;
            max-width: 500px;
            max-height: 400px;
            overflow-y: auto;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.8);
            opacity: 1;
        }

        .timezone-dropdown.show {
            display: block;
        }

        .timezone-option {
            padding: 10px 14px;
            color: #ccc;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 4px;
            opacity: 1;
            background: transparent;
        }

        .timezone-option:hover {
            background: #2a2a2a;
            color: white;
        }

        .timezone-option.active {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
            opacity: 1;
        }

        .timezone-option-main {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
        }

        .timezone-option-offset {
            display: inline-block;
            min-width: 60px;
            color: #10b981;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }

        .timezone-option-code {
            display: inline-block;
            padding: 2px 6px;
            background: #0f0f0f;
            border-radius: 6px;
            font-size: 10px;
            font-weight: 600;
            color: #888;
            font-family: 'Courier New', monospace;
            opacity: 1;
        }

        .timezone-option-datetime {
            font-size: 11px;
            color: #666;
            margin-left: 60px;
            font-family: 'Courier New', monospace;
        }

        .timezone-dropdown::-webkit-scrollbar {
            width: 8px;
        }

        .timezone-dropdown::-webkit-scrollbar-track {
            background: #0f0f0f;
            border-radius: 6px;
        }

        .timezone-dropdown::-webkit-scrollbar-thumb {
            background: #2a2a2a;
            border-radius: 6px;
        }

        .timezone-dropdown::-webkit-scrollbar-thumb:hover {
            background: #333;
        }

        /* Indices Dropdown Styles */
        .indices-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .indices-selector:hover {
            opacity: 0.8;
        }

        .indices-label {
            font-size: 13px;
            font-weight: 500;
            color: #fff;
        }

        .indices-chevron {
            font-size: 13px;
            color: #888;
            transition: transform 0.2s ease;
        }

        .indices-selector:hover .indices-chevron {
            color: #ccc;
        }

        .indices-dropdown {
            position: absolute;
            top: calc(100% + 8px);
            left: 0;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 12px;
            padding: 8px;
            min-width: 150px;
            display: none;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.8);
        }

        .indices-dropdown.show {
            display: block;
        }

        .indices-option {
            padding: 10px 14px;
            color: #ccc;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.2s ease;
            margin-bottom: 4px;
            background: transparent;
        }

        .indices-option:hover {
            background: #2a2a2a;
            color: white;
        }

        .indices-option.active {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .market-status {
            display: inline-block;
            padding: 6px 14px;
            background: rgba(16, 185, 129, 0.1);
            color: #10b981;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.5px;
            border: 1px solid rgba(16, 185, 129, 0.2);
        }

        .timezone-pills {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .timezone-pill {
            padding: 6px 14px;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 500;
            color: #888;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .timezone-pill:hover {
            background: #1f1f1f;
            border-color: #333;
            color: #ccc;
        }

        .timezone-pill.active {
            background: rgba(16, 185, 129, 0.1);
            border-color: rgba(16, 185, 129, 0.3);
            color: #10b981;
        }

        /* Quick Stats Styles */
        .stats-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 24px;
            color: #fff;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 0;
            border-bottom: 1px solid #1a1a1a;
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-size: 14px;
            color: #888;
            font-weight: 500;
        }

        .stat-value {
            font-size: 18px;
            font-weight: 600;
        }

        .stat-value.positive {
            color: #10b981;
            text-shadow: 0 0 10px rgba(16, 185, 129, 0.3);
        }

        .stat-value.negative {
            color: #ef4444;
            text-shadow: 0 0 10px rgba(239, 68, 68, 0.3);
        }

        .stat-value.neutral {
            color: #888;
        }

        /* Alert Badge */
        .alert-badge {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 8px;
            border: 1px solid rgba(239, 68, 68, 0.2);
        }

        /* Sentiment Drivers */
        .drivers-section {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .section-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
            color: #e0e0e0;
        }

        .drivers-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            flex: 1;
        }

        .drivers-grid-single {
            display: flex;
            flex-direction: column;
            gap: 12px;
            flex: 1;
        }

        .driver-item {
            background: transparent;
            padding: 14px 18px;
            border-radius: 12px;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .driver-item:hover {
            background: transparent;
            transform: none;
        }

        .driver-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        /* Driver Eye Icons - styles handled by .eye-icon-btn above */

        .driver-name {
            cursor: pointer;
            user-select: none;
        }

        /* Hide checkboxes for drivers without historical data */
        #checkbox-social,
        #checkbox-recommendations,
        #checkbox-vix {
            display: none;
        }

        .driver-name {
            font-size: 14px;
            font-weight: 500;
            color: #ccc;
        }

        .driver-value {
            font-size: 16px;
            font-weight: 700;
        }

        .driver-value.positive {
            color: #10b981;
        }

        .driver-value.negative {
            color: #ef4444;
        }

        .progress-bar {
            height: 6px;
            background: #0f0f0f;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            border-radius: 6px;
            transition: width 1s ease;
        }

        .progress-fill.positive {
            background: linear-gradient(90deg, #10b981 0%, #34d399 100%);
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.5);
        }

        .progress-fill.negative {
            background: linear-gradient(90deg, #ef4444 0%, #f87171 100%);
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
        }

        /* Chart Section */
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            flex-wrap: nowrap;
            gap: 16px;
        }

        .chart-title {
            font-size: 16px;
            font-weight: 600;
            color: #e0e0e0;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .chart-type-toggle {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 2px 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #e0e0e0;
            transition: all 0.2s ease;
        }
        
        .chart-type-toggle svg {
            width: 12px;
            height: 12px;
        }

        .chart-type-toggle:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }

        /* Granular data toggle (Second/Tick) */
        .granular-toggle {
            display: flex;
            gap: 4px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 4px;
            padding: 2px;
        }

        .granular-btn {
            padding: 2px 8px;
            background: transparent;
            border: none;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
            color: #888;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .granular-btn:hover {
            color: #ccc;
            background: rgba(255, 255, 255, 0.08);
        }

        .granular-btn.active {
            background: rgba(255, 140, 66, 0.15);
            color: #ff8c42;
        }

        /* Nasdaq price toggle as checkbox */
        .price-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            color: #fff;
            font-size: 12px;
            user-select: none;
        }

        .price-toggle input[type="checkbox"] {
            width: 10px;
            height: 10px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            border: 1px solid #666;
            border-radius: 3px;
            background-color: #999;
            position: relative;
        }

        .price-toggle input[type="checkbox"]:checked {
            background-color: #ffffff;
            border-color: #ffffff;
        }

        .price-toggle input[type="checkbox"]:checked::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #000;
            font-size: 10px;
            font-weight: bold;
        }

        .chart-controls {
            display: flex;
            gap: 6px;
            align-items: center;
            flex-shrink: 1;
            min-width: 0;
        }

        .timeframe-selector {
            display: flex;
            gap: 8px;
        }

        .timeframe-btn {
            padding: 4px 10px;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 10px;
            color: #888;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        .timeframe-btn:hover {
            background: #1f1f1f;
            border-color: #333;
            color: #ccc;
        }

        .timeframe-btn.active {
            background: rgba(255, 140, 66, 0.1);
            color: #ff8c42;
            border: 2px solid rgba(255, 140, 66, 0.3);
        }

        .timezone-select {
            background: #1a1a1a;
            color: #ccc;
            border: 1px solid #2a2a2a;
            padding: 6px 32px 6px 12px;
            border-radius: 10px;
            font-size: 12px;
            font-family: inherit;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1.5L6 6.5L11 1.5' stroke='%23888888' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
        }

        .timezone-select:hover {
            background-color: #1f1f1f;
            border-color: #333;
        }

        .timezone-select:focus {
            outline: none;
            border-color: #ff8c42;
        }

        .chart-container {
            flex: 1;
            position: relative;
            background: #0f0f0f;
            border-radius: 12px;
            padding: 12px 0px 0px 0px;
            min-height: 70px;
            overflow: hidden;
        }

        .chart-side-panel {
            background: #000000;
            border: 1px solid #ffffff;
            position: absolute;
            top: 20px;
            right: 40px;
            bottom: 20px;
            width: 25px;
            pointer-events: none;
        }

        .chart-side-panel-second {
            background: #000000;
            border: 1px solid #ffffff;
            position: absolute;
            top: 20px;
            right: 10px;
            bottom: 20px;
            width: 25px;
            pointer-events: none;
        }

        .market-status-indicator {
            position: absolute;
            bottom: 16px;
            left: 16px;
            font-size: 10px;
            color: #888;
            background: rgba(0, 0, 0, 0.5);
            padding: 4px 8px;
            border-radius: 4px;
            z-index: 100;
        }

        .market-status-indicator span {
            color: #aaa;
            font-weight: 500;
        }

        .charts-wrapper {
            position: relative;
        }
        

        .chart-canvas {
            position: absolute;
            top: 0;
            left: 20px;
            right: 10%;
            bottom: 0;
            width: calc(90% - 20px);
            height: 100%;
            cursor: crosshair;
        }

        .unified-hover-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 1px;
            background: transparent;
            border-left: 2px dashed rgba(255, 140, 66, 0.5);
            pointer-events: none;
            display: none;
            z-index: 10;
        }

        .chart-time-label {
            position: absolute;
            bottom: 145px;
            left: 0;
            background: #ff8c42;
            color: #000;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            font-family: monospace;
            white-space: nowrap;
            pointer-events: none;
            z-index: 9999;
            display: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .chart-time-label.show {
            display: block;
        }

        .chart-tooltip {
            position: absolute;
            background: rgba(26, 26, 26, 0.15);
            backdrop-filter: blur(1.4px);
            -webkit-backdrop-filter: blur(1.4px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 4px 8px;
            color: white;
            font-size: 11px;
            font-weight: 500;
            pointer-events: none;
            display: none;
            white-space: nowrap;
            z-index: 100;
            box-shadow: none;
        }

        .chart-tooltip .tooltip-label {
            color: #888;
            font-size: 9px;
            margin-bottom: 2px;
        }

        .chart-tooltip .tooltip-value {
            color: #ffffff;
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 2px;
        }

        .chart-tooltip .tooltip-time {
            color: #999;
            font-size: 9px;
        }
        
        #chart-tooltip .tooltip-time {
            display: none;
        }

        .chart-tooltip .tooltip-sentiment {
            color: #ff8c42;
            font-size: 10px;
            font-weight: 500;
            margin-top: 2px;
        }

        .y-axis {
            position: absolute;
            left: 0;
            top: 20px;
            bottom: 20px;
            width: 40px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            font-size: 11px;
            color: #fff;
            padding-right: 10px;
        }

        .y-axis-label {
            text-align: right;
        }

        .chart-line {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            pointer-events: none;
        }

        .chart-line svg {
            width: 100%;
            height: 100%;
        }

        .chart-path {
            fill: none;
            stroke: url(#lineGradient);
            stroke-width: 3;
            stroke-linecap: round;
            stroke-linejoin: round;
            filter: drop-shadow(0 0 15px rgba(255, 140, 66, 0.6));
            opacity: 1;
        }

        .zero-line {
            position: absolute;
            left: 50px;
            right: 20px;
            top: 50%;
            height: 1px;
            background: rgba(136, 136, 136, 0.3);
            border-top: 1px dashed rgba(136, 136, 136, 0.3);
            pointer-events: none;
        }

        .market-gap-line {
            position: absolute;
            top: 0;
            bottom: 20px;
            width: 2px;
            background: none;
            border-left: 2px dashed rgba(255, 193, 7, 0.4);
            pointer-events: none;
            z-index: 5;
        }

        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 140, 66, 0.6);
            }
            50% {
                box-shadow: 0 0 30px rgba(255, 140, 66, 0.8);
            }
        }

        .x-axis {
            position: absolute;
            left: 20px;
            right: 10%;
            bottom: 0;
            height: 20px;
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #fff;
        }

        .chart-oscillator-container {
            position: relative;
            height: 130px;
            margin-top: 15px;
            border-radius: 8px;
            background: #000000;
        }

        .chart-oscillator {
            position: absolute;
            top: 0;
            left: 20px;
            right: 10%;
            bottom: 0;
            width: calc(90% - 20px);
            height: 100%;
            cursor: crosshair;
        }

        /* Oscillator Y-axis */
        .oscillator-y-axis {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 20px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 8px 2px;
            z-index: 10;
        }

        .oscillator-y-axis span {
            font-size: 8px;
            color: #888;
            text-align: right;
            line-height: 1;
        }

        /* Oscillator Sentiment Score Panel */
        .oscillator-score-panel {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 10%;
            background: #1a1a1a;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
            border-left: 1px solid #333;
            z-index: 5;
        }

        .oscillator-score-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
        }

        .oscillator-score-value {
            font-size: 24px;
            font-weight: 600;
            color: #ff8c42;
            line-height: 1;
        }

        .oscillator-score-label {
            font-size: 8px;
            font-weight: 500;
            color: #666;
            margin-top: 2px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Eye Icon Button Styles */
        .eye-icon-btn {
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            margin-bottom: 4px;
        }

        .eye-icon-btn:hover {
            opacity: 0.7;
        }

        .eye-icon {
            width: 12.8px;
            height: 12.8px;
            stroke: #888;
            transition: stroke 0.2s ease;
        }

        .eye-icon-btn.active .eye-icon {
            stroke: #ff8c42;
        }

        .eye-icon-btn.driver-eye.active .eye-icon {
            stroke: #ec4899;
        }

        #eye-news.active .eye-icon {
            stroke: #ec4899;
        }

        #eye-indicators.active .eye-icon {
            stroke: #3b82f6;
        }

        /* Oscillator Scale Selector in Score Panel */
        #scale-fixed:checked + label,
        #scale-visible:checked + label,
        #scale-full:checked + label {
            background: rgba(255, 140, 66, 0.2) !important;
            border-color: #ff8c42 !important;
            color: #ff8c42 !important;
        }

        /* Signal Mode Toggle Active State */
        #signal-mode-toggle.active {
            background: rgba(255, 140, 66, 0.2) !important;
            border-color: #ff8c42 !important;
            color: #ff8c42 !important;
        }

        .oscillator-score-panel label:hover {
            background: rgba(255, 140, 66, 0.1) !important;
            border-color: #666 !important;
        }

        .chart-scrollbar-container {
            position: relative;
            margin-top: 5px;
            margin-bottom: 0;
            height: 16px;
            display: flex;
            align-items: center;
            width: 100%;
        }

        .chart-scrollbar {
            width: 100%;
            height: 3px;
            -webkit-appearance: none;
            appearance: none;
            background: #333;
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

        .chart-scrollbar::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 40px;
            height: 15px;
            background: #999;
            border-radius: 7.5px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .chart-scrollbar::-webkit-slider-thumb:hover {
            background: #fff;
        }

        .chart-scrollbar::-moz-range-thumb {
            width: 40px;
            height: 15px;
            background: #999;
            border-radius: 7.5px;
            cursor: pointer;
            border: none;
            transition: background 0.15s;
        }

        .chart-scrollbar::-moz-range-thumb:hover {
            background: #fff;
        }

        .chart-legend {
            position: absolute;
            left: 50px;
            right: 20px;
            bottom: 0;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            font-size: 11px;
            color: #fff;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-color {
            width: 12px;
            height: 2px;
            border-radius: 1px;
        }

        .legend-color.orange {
            background-color: #ff8c42;
        }

        .legend-color.white {
            background-color: #ffffff;
        }

        /* News Feed */
        .news-feed {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .news-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .news-title {
            font-size: 18px;
            font-weight: 600;
            color: #e0e0e0;
        }

        .news-filter {
            display: flex;
            gap: 8px;
        }

        .filter-btn {
            padding: 6px 14px;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 10px;
            color: #888;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .filter-btn:hover {
            background: #1f1f1f;
            color: #ccc;
        }

        .filter-btn.active {
            background: rgba(16, 185, 129, 0.1);
            color: #10b981;
            border-color: rgba(16, 185, 129, 0.2);
        }

        .news-items {
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
            flex: 1;
        }

        .news-item-link {
            text-decoration: none;
            color: inherit;
            display: block;
        }

        .news-item {
            background: #0f0f0f;
            padding: 16px;
            border-radius: 12px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .news-item:hover {
            background: #1a1a1a;
            transform: translateY(-1px);
        }

        .news-item-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
        }

        .news-source {
            font-size: 11px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .sentiment-tag {
            padding: 3px 10px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .sentiment-tag.positive {
            background: rgba(16, 185, 129, 0.15);
            color: #10b981;
            border: 1px solid rgba(16, 185, 129, 0.2);
        }

        .sentiment-tag.negative {
            background: rgba(239, 68, 68, 0.15);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.2);
        }

        .sentiment-tag.neutral {
            background: rgba(136, 136, 136, 0.15);
            color: #888;
            border: 1px solid rgba(136, 136, 136, 0.2);
        }

        .news-headline {
            font-size: 14px;
            font-weight: 500;
            color: #fff;
            line-height: 1.4;
            margin-bottom: 6px;
        }

        .news-description {
            font-size: 12px;
            color: #888;
            line-height: 1.5;
            margin-bottom: 8px;
        }

        .news-time {
            font-size: 11px;
            color: #666;
        }


        /* Onboarding Modal */
        .onboarding-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .onboarding-modal-overlay.show {
            display: flex;
            opacity: 1;
        }

        .onboarding-modal {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 16px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 0;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            position: relative;
        }

        .onboarding-modal-content {
            padding: 40px 48px;
        }

        .onboarding-step {
            display: none;
        }

        .onboarding-step.active {
            display: block;
        }

        .onboarding-title {
            font-size: 28px;
            font-weight: 700;
            color: #fff;
            margin-bottom: 24px;
            text-align: center;
        }

        .onboarding-subtitle {
            font-size: 16px;
            color: #888;
            margin-bottom: 32px;
            text-align: center;
            line-height: 1.6;
        }

        .language-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 32px;
        }

        .language-option {
            background: #282828;
            border: 2px solid #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .language-option:hover {
            background: #2a2a2a;
            border-color: #ffffff;
        }

        .language-option.selected {
            background: rgba(255, 255, 255, 0.06);
            border-color: #ffffff;
        }

        .language-name {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 4px;
        }

        .language-code {
            font-size: 12px;
            color: #888;
        }

        .disclaimer-content {
            background: #0f0f0f;
            border-left: 4px solid #2a2a2a;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 32px;
        }

        .disclaimer-section {
            margin-bottom: 24px;
        }

        .disclaimer-section:last-child {
            margin-bottom: 0;
        }

        .disclaimer-heading {
            font-size: 18px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .disclaimer-text {
            font-size: 14px;
            color: #ccc;
            line-height: 1.8;
        }

        .disclaimer-text p {
            margin-bottom: 12px;
        }

        .disclaimer-text p:last-child {
            margin-bottom: 0;
        }

        .disclaimer-checkbox-container {
            margin-top: 24px;
            padding-top: 24px;
            border-top: 1px solid #2a2a2a;
        }

        .disclaimer-checkbox-label {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            cursor: pointer;
            font-size: 14px;
            color: #ccc;
            line-height: 1.6;
        }

        .disclaimer-checkbox {
            width: 20px;
            height: 20px;
            margin-top: 2px;
            cursor: pointer;
            flex-shrink: 0;
        }
        
        .disclaimer-checkbox:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .disclaimer-checkbox-label:has(.disclaimer-checkbox:disabled) {
            cursor: not-allowed;
            opacity: 0.7;
        }

        .onboarding-button {
            width: 100%;
            padding: 14px 32px;
            background: #ffffff;
            color: #000000;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        .onboarding-button:hover {
            background: #e0e0e0;
            transform: translateY(-1px);
        }

        .onboarding-button:disabled {
            background: #2a2a2a;
            color: #666;
            cursor: not-allowed;
            transform: none;
        }

        .onboarding-button:disabled:hover {
            background: #2a2a2a;
        }

        .onboarding-progress {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-bottom: 32px;
        }

        .progress-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #2a2a2a;
            transition: all 0.2s ease;
        }

        .progress-dot.active {
            background: #ffffff;
            width: 24px;
            border-radius: 4px;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            body {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr;
            }

            .header {
                grid-column: 1;
                grid-row: 2;
            }

            .sidebar {
                grid-column: 1;
                grid-row: 1;
                padding: 20px;
            }

            .main-wrapper {
                grid-column: 1;
                grid-row: 3;
            }

            .container {
                grid-template-columns: 1fr;
                height: auto;
            }

            .drivers-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .onboarding-modal-content {
                padding: 32px 24px;
            }

            .onboarding-title {
                font-size: 24px;
            }

            .language-options {
                grid-template-columns: 1fr;
            }
        }

        /* Legal Disclaimer Modal - Shows on every page load */
        .disclaimer-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.50);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            z-index: 99999;
            display: none;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .disclaimer-modal-overlay.show {
            display: flex !important;
            opacity: 1 !important;
        }

        .disclaimer-modal {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 16px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 0;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9);
            position: relative;
        }

        .disclaimer-modal-content {
            padding: 40px 48px;
        }

        .disclaimer-modal-title {
            font-size: 28px;
            font-weight: 700;
            color: #fff;
            margin-bottom: 16px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        .disclaimer-modal-title img {
            width: 32px;
            height: 32px;
        }

        /* Level 1: Enter Button Screen */
        .disclaimer-modal-level-1 {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 400px;
            padding: 48px;
        }

        .disclaimer-modal-level-1 .disclaimer-modal-content {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 48px;
        }

        .disclaimer-enter-button {
            width: 100%;
            min-height: 200px;
            padding: 48px;
            background: #ffffff;
            color: #000000;
            border: none;
            border-radius: 24px;
            font-size: 48px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
            text-transform: uppercase;
            letter-spacing: 4px;
            box-shadow: 0 8px 32px rgba(255, 255, 255, 0.2);
        }

        .disclaimer-enter-button:hover {
            background: #e0e0e0;
            transform: scale(1.05);
            box-shadow: 0 12px 48px rgba(255, 255, 255, 0.3);
        }

        .disclaimer-enter-button:disabled {
            background: #2a2a2a;
            color: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .disclaimer-enter-button:disabled:hover {
            background: #2a2a2a;
            transform: none;
        }

        /* Level 2: Disclaimer Content */
        .disclaimer-modal-level-2 {
            display: none;
        }

        .disclaimer-modal-button {
            width: 100%;
            padding: 14px 32px;
            background: #ffffff;
            color: #000000;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        .disclaimer-modal-button:hover {
            background: #e0e0e0;
            transform: translateY(-1px);
        }

        .disclaimer-modal-button:disabled {
            background: #2a2a2a;
            color: #666;
            cursor: not-allowed;
            transform: none;
        }

        .disclaimer-modal-button:disabled:hover {
            background: #2a2a2a;
        }

        @media (max-width: 768px) {
            .disclaimer-modal-content {
                padding: 32px 24px;
            }

            .disclaimer-modal-title {
                font-size: 24px;
            }

            .disclaimer-modal-level-1 {
                min-height: 300px;
                padding: 32px;
            }

            .disclaimer-modal-level-1 .disclaimer-modal-content {
                gap: 32px;
            }

            .disclaimer-enter-button {
                min-height: 150px;
                padding: 32px;
                font-size: 36px;
                letter-spacing: 3px;
            }
        }
    </style>
    <!-- Disclaimer Modal Script -->
    <script src="js/disclaimer-modal.js"></script>
</head>
<body>
    <!-- Legal Disclaimer Modal - Shows on every page load -->
    <div class="disclaimer-modal-overlay" id="disclaimer-modal-overlay">
        <div class="disclaimer-modal">
            <!-- Level 1: Title and Enter Button -->
            <div class="disclaimer-modal-level-1" id="disclaimer-level-1">
                <div class="disclaimer-modal-content">
                    <h2 class="disclaimer-modal-title">
                        <img src="favicon.ico" alt="Sentiment Tracker">
                        <span>Sentiment Tracker</span>
                    </h2>
                    <button id="disclaimer-enter-button" class="disclaimer-enter-button">ENTER</button>
                </div>
            </div>

            <!-- Level 2: Disclaimer Content (hidden initially) -->
            <div class="disclaimer-modal-level-2" id="disclaimer-level-2" style="display: none;">
                <div class="disclaimer-modal-content">
                    <div class="disclaimer-content">
                        <div class="disclaimer-section">
                            <h3 class="disclaimer-heading">
                                <span>⚠️</span>
                                <span data-i18n="onboarding.disclaimer.heading">Risk Warning</span>
                            </h3>
                            <div class="disclaimer-text">
                                <p data-i18n="onboarding.disclaimer.text">Trading Futures, Forex, CFDs and Stocks involves a risk of loss. Please consider carefully if such trading is appropriate for you. Past performance is not indicative of future results. Any and all signals or educational advice provided by PhoenixBinary and/or Phoenix Algo, LLC and/or any indicators provided by aforementioned are for educational purposes only and do not constitute investment recommendations or advice.</p>
                            </div>
                        </div>
                        <div class="disclaimer-checkbox-container">
                            <label class="disclaimer-checkbox-label">
                                <input type="checkbox" id="disclaimer-modal-checkbox" class="disclaimer-checkbox">
                                <span data-i18n="onboarding.disclaimer.checkbox">I understand and acknowledge the risks associated with trading</span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Onboarding Modal -->
    <div class="onboarding-modal-overlay" id="onboarding-modal-overlay">
        <div class="onboarding-modal">
            <div class="onboarding-modal-content">
                <!-- Progress Indicator -->
                <div class="onboarding-progress">
                    <div class="progress-dot active" id="progress-dot-1"></div>
                    <div class="progress-dot" id="progress-dot-2"></div>
                </div>

                <!-- Step 1: Language Selection -->
                <div class="onboarding-step active" id="step-language">
                    <h2 class="onboarding-title" data-i18n="onboarding.title.language">Select Your Language</h2>
                    <p class="onboarding-subtitle" data-i18n="onboarding.subtitle.language">Choose your preferred language for the dashboard</p>
                    <div class="language-options">
                        <div class="language-option" data-lang="en">
                            <div class="language-name">English</div>
                            <div class="language-code">EN</div>
                        </div>
                        <div class="language-option" data-lang="es">
                            <div class="language-name">Español</div>
                            <div class="language-code">ES</div>
                        </div>
                        <div class="language-option" data-lang="fr">
                            <div class="language-name">Français</div>
                            <div class="language-code">FR</div>
                        </div>
                        <div class="language-option" data-lang="de">
                            <div class="language-name">Deutsch</div>
                            <div class="language-code">DE</div>
                        </div>
                        <div class="language-option" data-lang="zh">
                            <div class="language-name">中文</div>
                            <div class="language-code">ZH</div>
                        </div>
                        <div class="language-option" data-lang="ja">
                            <div class="language-name">日本語</div>
                            <div class="language-code">JA</div>
                        </div>
                    </div>
                    <button class="onboarding-button" id="language-continue-btn" data-i18n="onboarding.button.continue" disabled>Continue</button>
                </div>

                <!-- Step 2: Disclaimer -->
                <div class="onboarding-step" id="step-disclaimer">
                    <h2 class="onboarding-title" data-i18n="onboarding.title.disclaimer">Important Disclaimer</h2>
                    <div class="disclaimer-content">
                        <div class="disclaimer-section">
                            <h3 class="disclaimer-heading">
                                <span>⚠️</span>
                                <span data-i18n="onboarding.disclaimer.heading">Risk Warning</span>
                            </h3>
                            <div class="disclaimer-text">
                                <p data-i18n="onboarding.disclaimer.text">Trading Futures, Forex, CFDs and Stocks involves a risk of loss. Please consider carefully if such trading is appropriate for you. Past performance is not indicative of future results. Any and all signals or educational advice provided by PhoenixBinary and/or Phoenix Algo, LLC and/or any indicators provided by aforementioned are for educational purposes only and do not constitute investment recommendations or advice.</p>
                            </div>
                        </div>
                        <div class="disclaimer-checkbox-container">
                            <label class="disclaimer-checkbox-label">
                                <input type="checkbox" id="disclaimer-checkbox" class="disclaimer-checkbox">
                                <span data-i18n="onboarding.disclaimer.checkbox">I understand and acknowledge the risks associated with trading</span>
                            </label>
                        </div>
                    </div>
                    <button class="onboarding-button" id="disclaimer-continue-btn" data-i18n="onboarding.button.continue" disabled>Continue</button>
                </div>
            </div>
        </div>
    </div>
    <div class="main-wrapper">
    <div class="container">
            <!-- Left Column Wrapper -->
            <div class="left-column-wrapper">
                <!-- Left Top: Title -->
                <div class="card left-top">
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; gap: 16px;">
                        <div style="text-align: left;">
                            <div style="font-size: 40px; font-weight: 700; color: #fff; line-height: 0.9; margin-bottom: 4px;">Sentiment</div>
                            <div style="font-size: 40px; font-weight: 700; color: #fff; line-height: 0.9;">Tracker</div>
                        </div>
                        <div style="width: 85px; height: 85px; background: #1a1a1a; border-radius: 12px; display: flex; align-items: center; justify-content: center; color: #666; font-size: 12px; border: 2px dashed #333;">
                            Logo
                        </div>
                    </div>
                </div>

                <!-- Left Bottom: Sentiment Drivers -->
                <div class="card left-bottom">
                    <h2 class="section-title" data-i18n="dashboard.drivers.title">Sentiment Drivers</h2>
                    <div class="drivers-grid-single">
                        <div class="driver-item">
                            <div class="driver-header">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <button type="button" class="eye-icon-btn driver-eye" data-line="news" id="eye-news" title="Toggle news sentiment line">
                                        <svg class="eye-icon eye-closed" width="12.8" height="12.8" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
                                            <line x1="1" y1="1" x2="23" y2="23"></line>
                                        </svg>
                                        <svg class="eye-icon eye-open" width="12.8" height="12.8" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
                                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                            <circle cx="12" cy="12" r="3"></circle>
                                        </svg>
                                    </button>
                                    <span class="driver-name" data-i18n="dashboard.driver.news">News</span>
                                </div>
                                <span class="driver-value negative">-1.2</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill negative" style="width: 30%"></div>
                            </div>
                        </div>

                        <div class="driver-item">
                            <div class="driver-header">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <input type="checkbox" class="driver-checkbox" data-driver="social" id="checkbox-social">
                                    <label for="checkbox-social" class="driver-name" data-i18n="dashboard.driver.social">Social Media</label>
                                </div>
                                <span class="driver-value positive">+0.5</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill positive" style="width: 65%"></div>
                            </div>
                        </div>

                        <div class="driver-item">
                            <div class="driver-header">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <button type="button" class="eye-icon-btn driver-eye" data-line="indicators" id="eye-indicators" title="Toggle technical indicators line">
                                        <svg class="eye-icon eye-closed" width="12.8" height="12.8" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
                                            <line x1="1" y1="1" x2="23" y2="23"></line>
                                        </svg>
                                        <svg class="eye-icon eye-open" width="12.8" height="12.8" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
                                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                            <circle cx="12" cy="12" r="3"></circle>
                                        </svg>
                                    </button>
                                    <span class="driver-name" data-i18n="dashboard.driver.indicators">Indicators</span>
                                </div>
                                <span class="driver-value positive">+0.1</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill positive" style="width: 55%"></div>
                            </div>
                        </div>

                        <!-- New Driver 1 -->
                        <div class="driver-item">
                            <div class="driver-header">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <input type="checkbox" class="driver-checkbox" data-driver="recommendations" id="checkbox-recommendations">
                                    <label for="checkbox-recommendations" class="driver-name" data-i18n="dashboard.driver.recommendations">Recommendations</label>
                                </div>
                                <span class="driver-value positive">+0.3</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill positive" style="width: 60%"></div>
                            </div>
                        </div>

                        <!-- VIX Driver -->
                        <div class="driver-item">
                            <div class="driver-header">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <input type="checkbox" class="driver-checkbox" data-driver="vix" id="checkbox-vix">
                                    <label for="checkbox-vix" class="driver-name" data-i18n="dashboard.driver.vix">VIX</label>
                                </div>
                                <span class="driver-value neutral">0.0</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill neutral" style="width: 50%"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Top: Navigation & Time -->
            <div class="right-top">
                <div class="right-top-item">
                    <a href="about.html" class="nav-link" data-i18n="nav.about">About Us</a>
                </div>
                <div class="right-top-item">
                    <div class="indices-selector" id="indices-selector">
                        <span class="indices-label" data-i18n="nav.indices">Indices</span>
                        <span class="indices-chevron">▼</span>
                        <div class="indices-dropdown" id="indices-dropdown">
                            <div class="indices-option active" data-index="nasdaq">Nasdaq</div>
                        </div>
                    </div>
                </div>
                <div class="right-top-item">
                    <a href="news.html" class="nav-link" data-i18n="nav.news">News</a>
                </div>
                <div class="right-top-item">
                    <a href="#" class="nav-link" data-i18n="nav.trading">Trading</a>
                </div>
                <div class="right-top-item">
                    <a href="#" class="nav-link" id="language-selector" data-i18n="nav.language">Language</a>
                </div>
                <div class="right-top-item">
                    <a href="#" class="nav-link" id="logout-link" data-i18n="nav.logout">Logout</a>
                </div>
                <div class="right-top-item">
                    <div class="time-display" id="timezone-selector" style="position: relative;">
                        <span class="current-time" id="current-time">09:45:32</span>
                        <span class="timezone-chevron">▼</span>
                        <div class="timezone-dropdown" id="timezone-dropdown">
                            <!-- Timezone options will be populated dynamically -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Bottom Row: News Feed -->
            <!-- <div class="card bottom-row">
                <div class="news-feed">
                    <div class="news-header">
                        <div class="news-title">Live News Feed</div>
                        <div class="news-filter">
                            <button class="filter-btn active">All</button>
                            <button class="filter-btn">Positive</button>
                            <button class="filter-btn">Negative</button>
                            <button class="filter-btn">Breaking</button>
                        </div>
                    </div>
                    <div class="news-items">
                        <a href="https://www.bloomberg.com/markets" target="_blank" class="news-item-link">
                            <div class="news-item">
                                <div class="news-item-header">
                                    <span class="news-source">Bloomberg</span>
                                    <span class="sentiment-tag positive">POSITIVE</span>
                                </div>
                                <div class="news-headline">Tech stocks rally as inflation data comes in lower than expected</div>
                                <div class="news-time">2 minutes ago</div>
                            </div>
                        </a>
                        <a href="https://www.reuters.com/markets" target="_blank" class="news-item-link">
                            <div class="news-item">
                                <div class="news-item-header">
                                    <span class="news-source">Reuters</span>
                                    <span class="sentiment-tag positive">POSITIVE</span>
                                </div>
                                <div class="news-headline">NASDAQ futures surge on strong earnings reports from major tech companies</div>
                                <div class="news-time">8 minutes ago</div>
                            </div>
                        </a>
                        <a href="https://www.cnbc.com/markets" target="_blank" class="news-item-link">
                            <div class="news-item">
                                <div class="news-item-header">
                                    <span class="news-source">CNBC</span>
                                    <span class="sentiment-tag negative">NEGATIVE</span>
                                </div>
                                <div class="news-headline">Fed officials signal potential rate hike in upcoming meeting</div>
                                <div class="news-time">15 minutes ago</div>
                            </div>
                        </a>
                        <a href="https://www.wsj.com/markets" target="_blank" class="news-item-link">
                            <div class="news-item">
                                <div class="news-item-header">
                                    <span class="news-source">WSJ</span>
                                    <span class="sentiment-tag neutral">NEUTRAL</span>
                                </div>
                                <div class="news-headline">Market analysts discuss mixed signals from recent economic indicators</div>
                                <div class="news-time">22 minutes ago</div>
                            </div>
                        </a>
                        <a href="https://www.ft.com/markets" target="_blank" class="news-item-link">
                            <div class="news-item">
                                <div class="news-item-header">
                                    <span class="news-source">Financial Times</span>
                                    <span class="sentiment-tag positive">POSITIVE</span>
                                </div>
                                <div class="news-headline">Strong consumer spending data boosts market confidence heading into Q4</div>
                                <div class="news-time">35 minutes ago</div>
                            </div>
                        </a>
                    </div>
                </div>
            </div> -->

            <!-- Bottom Row: Historical Sentiment Trend -->
            <div class="card bottom-row" style="position: relative;">
                <div class="chart-header">
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <span class="chart-title" data-i18n="dashboard.chart.title">NASDAQ</span>
                        <button id="chart-type-toggle" class="chart-type-toggle" title="Toggle chart type">
                            <svg id="line-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>
                            </svg>
                            <svg id="candle-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display: none;">
                                <line x1="12" y1="2" x2="12" y2="6"></line>
                                <rect x="8" y="6" width="8" height="12" fill="currentColor"></rect>
                                <line x1="12" y1="18" x2="12" y2="22"></line>
                            </svg>
                        </button>
                        
                        <!-- Granular Data Toggle (Second/Tick) - Only visible for ≤1h timeframes -->
                        <div id="granular-toggle" class="granular-toggle" style="display: none;">
                            <button class="granular-btn active" data-type="second" title="1-Second Candles">Second</button>
                            <button class="granular-btn" data-type="tick" title="100-Tick Candles">Tick</button>
                        </div>
                    </div>
                    <div class="chart-controls">
                        <div class="timeframe-selector">
                            <button class="timeframe-btn active" data-timeframe="6h" data-i18n="dashboard.chart.timeframe.6h">Session</button>
                            <button class="timeframe-btn" data-timeframe="1m" data-i18n="dashboard.chart.timeframe.1m">1m</button>
                            <button class="timeframe-btn" data-timeframe="5m" data-i18n="dashboard.chart.timeframe.5m">5m</button>
                            <button class="timeframe-btn" data-timeframe="15m" data-i18n="dashboard.chart.timeframe.15m">15m</button>
                            <button class="timeframe-btn" data-timeframe="30m" data-i18n="dashboard.chart.timeframe.30m">30m</button>
                            <button class="timeframe-btn" data-timeframe="1h" data-i18n="dashboard.chart.timeframe.1h">1h</button>
                            <button class="timeframe-btn" data-timeframe="2h" data-i18n="dashboard.chart.timeframe.2h">2h</button>
                            <button class="timeframe-btn" data-timeframe="4h" data-i18n="dashboard.chart.timeframe.4h">4h</button>
                            <button class="timeframe-btn" data-timeframe="2d" data-i18n="dashboard.chart.timeframe.2d">2d</button>
                            <button class="timeframe-btn" data-timeframe="3d" data-i18n="dashboard.chart.timeframe.3d">3d</button>
                        </div>
                    </div>
                </div>

                <!-- Unified Charts Wrapper -->
                <div class="charts-wrapper" id="charts-wrapper">
                    <!-- Main Chart Container -->
                    <div class="chart-container" id="chart-container" style="flex: 1; min-height: 450px; display: flex; flex-direction: column;">
                        <div style="position: relative; flex: 1; min-height: 340px;">
                        <div class="chart-canvas" id="chart-canvas">
                            <div class="chart-line">
                                <svg viewBox="0 0 100 100" preserveAspectRatio="none" id="sentiment-chart">
                                    <defs>
                                        <linearGradient id="lineGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                            <stop offset="0%" style="stop-color:#ff8c42;stop-opacity:1" />
                                            <stop offset="30%" style="stop-color:#ff7b52;stop-opacity:1" />
                                            <stop offset="60%" style="stop-color:#ff6b6b;stop-opacity:1" />
                                            <stop offset="100%" style="stop-color:#ef4444;stop-opacity:1" />
                                        </linearGradient>
                                    </defs>
                                    <path class="chart-path" d="" />
                                </svg>
                            </div>
                            <svg viewBox="0 0 100 100" preserveAspectRatio="none" id="chart-dots-svg" style="position: absolute; left: 0; right: 0; top: 0; bottom: 0; width: 100%; height: 100%; pointer-events: none;">
                                <g id="chart-dots"></g>
                                <g id="nasdaq-price-line"></g>
                            </svg>
                            <div class="chart-tooltip" id="chart-tooltip">
                                <div class="tooltip-label">Nasdaq Price</div>
                                <div class="tooltip-value">$0.00</div>
                                <div class="tooltip-sentiment" id="tooltip-sentiment">Score: +0</div>
                                <div class="tooltip-time">14:32:45</div>
                            </div>
                        </div>
                        <div class="x-axis" id="x-axis-labels">
                            <span>-60m</span>
                            <span>-45m</span>
                            <span>-30m</span>
                            <span>-15m</span>
                            <span>Now</span>
                        </div>
                        </div>
                        
                        <!-- Volume Chart (below price chart) -->
                        <div class="volume-container" id="volume-container" style="height: 70px; flex-shrink: 0;">
                            <svg viewBox="0 0 100 100" preserveAspectRatio="none" id="volume-chart-svg" style="width: 100%; height: 100%; padding-left: 20px; padding-right: 10%;">
                                <g id="volume-bars"></g>
                            </svg>
                        </div>
                        
                        <div class="chart-side-panel"></div>
                        <div class="chart-side-panel-second"></div>
                    </div>

                    <!-- Oscillator -->
                    <div class="chart-oscillator-container">
                        <div class="oscillator-y-axis" id="oscillator-y-axis"></div>
                        <div class="chart-oscillator" id="chart-oscillator"></div>
                        <!-- Current Sentiment Score Panel -->
                        <div class="oscillator-score-panel">
                            <!-- Composite Score Eye Icon -->
                            <button type="button" class="eye-icon-btn active" id="eye-sentiment" data-line="sentiment" title="Toggle composite score line">
                                <svg class="eye-icon eye-open" width="12.8" height="12.8" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                    <circle cx="12" cy="12" r="3"></circle>
                                </svg>
                                <svg class="eye-icon eye-closed" width="12.8" height="12.8" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
                                    <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
                                    <line x1="1" y1="1" x2="23" y2="23"></line>
                                </svg>
                            </button>

                            <!-- Score Display -->
                            <div class="oscillator-score-display">
                                <div class="oscillator-score-value" id="oscillator-current-score">+0</div>
                                <div class="oscillator-score-label">Score</div>
                            </div>

                            <!-- Scale Mode Selector -->
                            <div style="display: flex; flex-direction: row; gap: 3px; align-items: center;">
                                <input type="radio" id="scale-fixed" name="oscillator-scale" value="fixed" style="display: none;">
                                <label for="scale-fixed" title="Fixed scale: -100 to +100" style="display: flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 2px; background: rgba(0, 0, 0, 0.3); border: 1px solid #444; cursor: pointer; color: #888; transition: all 0.2s ease;">
                                    <svg width="9" height="9" viewBox="0 0 16 16" fill="none">
                                        <rect x="2" y="2" width="12" height="12" stroke="currentColor" stroke-width="1.5" rx="1"/>
                                        <line x1="2" y1="8" x2="14" y2="8" stroke="currentColor" stroke-width="1"/>
                                    </svg>
                                </label>

                                <input type="radio" id="scale-visible" name="oscillator-scale" value="visible" checked style="display: none;">
                                <label for="scale-visible" title="Scale to visible window" style="display: flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 2px; background: rgba(0, 0, 0, 0.3); border: 1px solid #444; cursor: pointer; color: #888; transition: all 0.2s ease;">
                                    <svg width="9" height="9" viewBox="0 0 16 16" fill="none">
                                        <rect x="2" y="2" width="12" height="12" stroke="currentColor" stroke-width="1.5" rx="1"/>
                                        <path d="M5 8 L8 5 L11 10 L14 6" stroke="currentColor" stroke-width="1.5" fill="none"/>
                                    </svg>
                                </label>

                                <input type="radio" id="scale-full" name="oscillator-scale" value="full" style="display: none;">
                                <label for="scale-full" title="Scale to full timeframe" style="display: flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 2px; background: rgba(0, 0, 0, 0.3); border: 1px solid #444; cursor: pointer; color: #888; transition: all 0.2s ease;">
                                    <svg width="9" height="9" viewBox="0 0 16 16" fill="none">
                                        <rect x="2" y="2" width="12" height="12" stroke="currentColor" stroke-width="1.5" rx="1"/>
                                        <path d="M2 8 L5 5 L8 10 L11 4 L14 9" stroke="currentColor" stroke-width="1.5" fill="none"/>
                                    </svg>
                                </label>

                                <!-- Signal Mode Toggle -->
                                <button id="signal-mode-toggle" title="Toggle Signal Mode (News UP / Technical DOWN)" style="display: flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 2px; background: rgba(0, 0, 0, 0.3); border: 1px solid #444; cursor: pointer; color: #888; transition: all 0.2s ease; margin-left: 3px;">
                                    <svg width="9" height="9" viewBox="0 0 16 16" fill="none">
                                        <path d="M8 2 L8 14" stroke="currentColor" stroke-width="1.5"/>
                                        <path d="M4 6 L8 2 L12 6" stroke="currentColor" stroke-width="1.5" fill="none"/>
                                        <path d="M4 10 L8 14 L12 10" stroke="currentColor" stroke-width="1.5" fill="none"/>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <div class="chart-tooltip" id="oscillator-tooltip">
                            <div class="tooltip-label">Sentiment Score</div>
                            <div class="tooltip-value" style="color: #ff8c42;">+0</div>
                            <div class="tooltip-time">14:32:45</div>
                        </div>
                        <!-- Market Status Indicator (inside oscillator) -->
                        <div class="market-status-indicator" id="market-status-indicator" style="display: none;">
                            Market is currently closed. Latest data from <span id="market-close-time"></span>
                        </div>
                    </div>

                    <!-- Horizontal Scrollbar for Historical Data -->
                    <div class="chart-scrollbar-container" id="chart-scrollbar-container">
                        <input type="range" class="chart-scrollbar" id="chart-scrollbar" min="0" max="100" value="100" step="1">
                    </div>

                    <!-- Unified Hover Elements (span both charts) -->
                    <div class="unified-hover-line" id="unified-hover-line"></div>
                    <div class="chart-time-label" id="time-label">00:00:00</div>
                </div>
            </div>
        </div>
    </div>


    <script>
        // Clerk authentication check - redirect if not logged in
        window.addEventListener('load', async function() {
            try {
                // Wait for Clerk to be available
                if (!window.Clerk) {
                    // Wait a bit for async script to load
                    let retries = 0;
                    while (!window.Clerk && retries < 50) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        retries++;
                    }
                    
                    if (!window.Clerk) {
                        console.error('Clerk SDK failed to load');
                        window.location.href = '/index.html';
                        return;
                    }
                }
                
                await window.Clerk.load();
                
                // Check if user is authenticated
                if (!window.Clerk.user) {
                    window.location.href = '/index.html';
                    return;
                }

                // Note: Onboarding check is now handled by the disclaimer modal
                // The disclaimer modal will call checkAndShowOnboarding() after user acknowledges
                // This ensures disclaimer shows first, then onboarding if needed
                
                // Setup logout functionality
                const logoutLink = document.getElementById('logout-link');
                if (logoutLink) {
                    logoutLink.addEventListener('click', async function(e) {
                        e.preventDefault();
                        try {
                            await window.Clerk.signOut();
                            window.location.href = '/index.html';
                        } catch (error) {
                            console.error('Error signing out:', error);
                            // Fallback: redirect anyway
                            window.location.href = '/index.html';
                        }
                    });
                }
            } catch (error) {
                console.error('Error loading Clerk:', error);
                // Redirect to index if Clerk fails to load
                window.location.href = '/index.html';
            }
        });

        // Timezone data embedded directly (to avoid CORS issues with local file access)
        const timezonesData = [
            {"offset": "-12:00", "name": "Baker Island Time", "code": "BIT"},
            {"offset": "-11:00", "name": "Samoa Standard Time", "code": "SST"},
            {"offset": "-10:00", "name": "Hawaii-Aleutian Standard Time", "code": "HST"},
            {"offset": "-09:30", "name": "Marquesas Islands Time", "code": "MART"},
            {"offset": "-09:00", "name": "Alaska Standard Time", "code": "AKST"},
            {"offset": "-08:00", "name": "Pacific Standard Time", "code": "PST"},
            {"offset": "-07:00", "name": "Mountain Standard Time", "code": "MST"},
            {"offset": "-06:00", "name": "Central Standard Time", "code": "CST"},
            {"offset": "-05:00", "name": "Eastern Standard Time", "code": "EST"},
            {"offset": "-04:00", "name": "Atlantic Standard Time", "code": "AST"},
            {"offset": "-03:30", "name": "Newfoundland Standard Time", "code": "NST"},
            {"offset": "-03:00", "name": "Argentina Time", "code": "ART"},
            {"offset": "-02:00", "name": "South Georgia Time", "code": "GST"},
            {"offset": "-01:00", "name": "Azores Standard Time", "code": "AZOST"},
            {"offset": "+00:00", "name": "Coordinated Universal Time", "code": "UTC"},
            {"offset": "+01:00", "name": "Central European Time", "code": "CET"},
            {"offset": "+02:00", "name": "Eastern European Time", "code": "EET"},
            {"offset": "+03:00", "name": "Moscow Standard Time", "code": "MSK"},
            {"offset": "+03:30", "name": "Iran Standard Time", "code": "IRST"},
            {"offset": "+04:00", "name": "Gulf Standard Time", "code": "GST"},
            {"offset": "+04:30", "name": "Afghanistan Time", "code": "AFT"},
            {"offset": "+05:00", "name": "Pakistan Standard Time", "code": "PKT"},
            {"offset": "+05:30", "name": "India Standard Time", "code": "IST"},
            {"offset": "+05:45", "name": "Nepal Time", "code": "NPT"},
            {"offset": "+06:00", "name": "Bangladesh Standard Time", "code": "BST"},
            {"offset": "+06:30", "name": "Myanmar Time", "code": "MMT"},
            {"offset": "+07:00", "name": "Indochina Time", "code": "ICT"},
            {"offset": "+08:00", "name": "China Standard Time", "code": "CST"},
            {"offset": "+08:45", "name": "Australian Central Western Standard Time", "code": "ACWST"},
            {"offset": "+09:00", "name": "Japan Standard Time", "code": "JST"},
            {"offset": "+09:30", "name": "Australian Central Standard Time", "code": "ACST"},
            {"offset": "+10:00", "name": "Australian Eastern Standard Time", "code": "AEST"},
            {"offset": "+10:30", "name": "Lord Howe Standard Time", "code": "LHST"},
            {"offset": "+11:00", "name": "Solomon Islands Time", "code": "SBT"},
            {"offset": "+12:00", "name": "New Zealand Standard Time", "code": "NZST"},
            {"offset": "+12:45", "name": "Chatham Islands Standard Time", "code": "CHAST"},
            {"offset": "+13:00", "name": "Tonga Time", "code": "TOT"},
            {"offset": "+14:00", "name": "Line Islands Time", "code": "LINT"}
        ];
        
        let currentTimezoneData = null;
        
        // Parse offset string to decimal hours (e.g., "-05:00" -> -5, "+05:30" -> 5.5)
        function parseOffset(offsetStr) {
            const sign = offsetStr.charAt(0) === '-' ? -1 : 1;
            const parts = offsetStr.substring(1).split(':');
            const hours = parseInt(parts[0]);
            const minutes = parseInt(parts[1]);
            return sign * (hours + minutes / 60);
        }
        
        // Format date and time for a given timezone
        function getTimezoneDateTime(offsetHours) {
            const now = new Date();
            const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
            const localTime = new Date(utc + (3600000 * offsetHours));
            
            const year = localTime.getFullYear();
            const month = String(localTime.getMonth() + 1).padStart(2, '0');
            const day = String(localTime.getDate()).padStart(2, '0');
            const hours = String(localTime.getHours()).padStart(2, '0');
            const minutes = String(localTime.getMinutes()).padStart(2, '0');
            const seconds = String(localTime.getSeconds()).padStart(2, '0');
            
            return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
        }
        
        // Update the main clock display
        function updateTime() {
            if (!currentTimezoneData) {
                // Default to local time if no timezone selected
                const now = new Date();
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');
                document.getElementById('current-time').textContent = `${hours}:${minutes}:${seconds}`;
                return;
            }
            
            const offsetHours = parseOffset(currentTimezoneData.offset);
            const now = new Date();
            const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
            const localTime = new Date(utc + (3600000 * offsetHours));
            
            const hours = String(localTime.getHours()).padStart(2, '0');
            const minutes = String(localTime.getMinutes()).padStart(2, '0');
            const seconds = String(localTime.getSeconds()).padStart(2, '0');
            document.getElementById('current-time').textContent = `${hours}:${minutes}:${seconds}`;
        }
        
        // Initialize timezone system
        function loadTimezones() {
            console.log('Initializing timezones...');
            console.log('Timezones loaded:', timezonesData.length);
            
            // Set default timezone to EST
            currentTimezoneData = timezonesData.find(tz => tz.code === 'EST') || timezonesData[0];
            console.log('Default timezone set to:', currentTimezoneData);
            
            populateTimezoneDropdown();
            updateTime();
        }
        
        // Populate the timezone dropdown with all options
        function populateTimezoneDropdown() {
            const dropdown = document.getElementById('timezone-dropdown');
            
            if (!dropdown) {
                console.error('Timezone dropdown element not found!');
                return;
            }
            
            console.log('Populating dropdown with', timezonesData.length, 'timezones');
            dropdown.innerHTML = '';
            
            timezonesData.forEach((tz, index) => {
                const offsetHours = parseOffset(tz.offset);
                const dateTime = getTimezoneDateTime(offsetHours);
                
                const option = document.createElement('div');
                option.className = 'timezone-option';
                if (currentTimezoneData && currentTimezoneData.code === tz.code) {
                    option.classList.add('active');
                }
                
                option.innerHTML = `
                    <div class="timezone-option-main">
                        <span class="timezone-option-offset">${tz.offset}</span>
                        <span class="timezone-option-code">${tz.code}</span>
                        <span>${tz.name}</span>
                    </div>
                    <div class="timezone-option-datetime">${dateTime}</div>
                `;
                
                option.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectTimezone(tz);
                });
                
                dropdown.appendChild(option);
            });
            
            console.log('Dropdown populated. Children count:', dropdown.children.length);
        }
        
        // Select a timezone
        function selectTimezone(tz) {
            currentTimezoneData = tz;
            
            // Update active state
            document.querySelectorAll('.timezone-option').forEach(opt => opt.classList.remove('active'));
            event.currentTarget.classList.add('active');
            
            // Update time immediately
            updateTime();
            
            // Update chart with new timezone
            if (typeof currentTimeframe !== 'undefined' && typeof updateChart === 'function') {
                updateChart(currentTimeframe);
            }
            
            // Close dropdown
            document.getElementById('timezone-dropdown').classList.remove('show');
            document.getElementById('timezone-selector').classList.remove('open');
        }
        
        // Update dropdown times every second
        function updateDropdownTimes() {
            const options = document.querySelectorAll('.timezone-option');
            timezonesData.forEach((tz, index) => {
                if (options[index]) {
                    const offsetHours = parseOffset(tz.offset);
                    const dateTime = getTimezoneDateTime(offsetHours);
                    const dateTimeElem = options[index].querySelector('.timezone-option-datetime');
                    if (dateTimeElem) {
                        dateTimeElem.textContent = dateTime;
                    }
                }
            });
        }
        
        // Animate progress bars on load
        window.addEventListener('load', () => {
            const progressBars = document.querySelectorAll('.progress-fill');
            progressBars.forEach(bar => {
                const width = bar.style.width;
                bar.style.width = '0';
                setTimeout(() => {
                    bar.style.width = width;
                }, 100);
            });
        });

        // Initialize timezones and dashboard after DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            loadTimezones();
            initializeDashboard();
        });
        
        // Update time every second
        setInterval(() => {
            updateTime();
            // Only update dropdown times if dropdown is open
            const dropdown = document.getElementById('timezone-dropdown');
            if (dropdown && dropdown.classList.contains('show')) {
                updateDropdownTimes();
            }
        }, 1000);

        // News filter buttons
        const filterBtns = document.querySelectorAll('.filter-btn');
        const newsItemLinks = document.querySelectorAll('.news-item-link');
        
        filterBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                filterBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                const filter = btn.textContent.toLowerCase();
                
                newsItemLinks.forEach(link => {
                    const sentimentTag = link.querySelector('.sentiment-tag');
                    const sentiment = sentimentTag ? sentimentTag.textContent.toLowerCase() : '';
                    
                    if (filter === 'all') {
                        link.style.display = 'block';
                    } else if (filter === 'breaking') {
                        // Show first 2 items for "breaking" news
                        const isBreaking = Array.from(newsItemLinks).indexOf(link) < 2;
                        link.style.display = isBreaking ? 'block' : 'none';
                    } else {
                        link.style.display = sentiment === filter ? 'block' : 'none';
                    }
                });
            });
        });

        // Timezone dropdown toggle - initialize after DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            const timezoneSelector = document.getElementById('timezone-selector');
            const timezoneDropdown = document.getElementById('timezone-dropdown');

            if (timezoneSelector && timezoneDropdown) {
                timezoneSelector.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('timezone-option')) {
                        timezoneDropdown.classList.toggle('show');
                        timezoneSelector.classList.toggle('open');
                        
                        // Update all dropdown times when opening
                        if (timezoneDropdown.classList.contains('show')) {
                            updateDropdownTimes();
                        }
                    }
                });

                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!timezoneSelector.contains(e.target)) {
                        timezoneDropdown.classList.remove('show');
                        timezoneSelector.classList.remove('open');
                    }
                });
            }

            // Indices dropdown toggle
            const indicesSelector = document.getElementById('indices-selector');
            const indicesDropdown = document.getElementById('indices-dropdown');

            if (indicesSelector && indicesDropdown) {
                indicesSelector.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('indices-option')) {
                        indicesDropdown.classList.toggle('show');
                    }
                });

                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!indicesSelector.contains(e.target)) {
                        indicesDropdown.classList.remove('show');
                    }
                });

                // Handle indices option selection
                const indicesOptions = document.querySelectorAll('.indices-option');
                indicesOptions.forEach(option => {
                    option.addEventListener('click', (e) => {
                        e.stopPropagation();
                        
                        // Update active state
                        indicesOptions.forEach(opt => opt.classList.remove('active'));
                        option.classList.add('active');
                        
                        // Get selected index
                        const selectedIndex = option.getAttribute('data-index');
                        console.log('Selected index:', selectedIndex);
                        
                        // Close dropdown
                        indicesDropdown.classList.remove('show');
                        
                        // You can add additional functionality here when more indices are added
                        // For now, only Nasdaq is available
                    });
                });
            }
        });

        // Timeframe selector and chart update
        const timeframeBtns = document.querySelectorAll('.timeframe-btn');
        const xAxisLabels = document.getElementById('x-axis-labels');
        const chartPath = document.querySelector('.chart-path');
        let currentTimeframe = '6h'; // Declare timeframe variable globally
        let scrollPosition = 100; // 100 = rightmost (most recent data), 0 = leftmost (oldest data)
        let chartType = 'candlestick'; // 'line' or 'candlestick'
        
        // ===== REAL NASDAQ SENTIMENT DATA =====
        // Fetch real composite sentiment data from the API
        let sentimentDataset = [];
        let sentimentDataset2d = [];
        let sentimentDataset3d = [];
        let currentCompositeScore = 0;
        
        // ===== GRANULAR DATA (SECOND & TICK CANDLES) =====
        let secondCandlesDataset = [];
        let tickCandlesDataset = [];
        let granularDataType = 'second'; // 'second' or 'tick'
        let lastGranularTimestamp = null;
        let granularRefreshInterval = null;
        
        // API Base URL - adjust if needed
        // Dynamic API URL - detects localhost, file://, or production
        const API_BASE_URL = (
            window.location.protocol === 'file:' ||
            window.location.hostname === 'localhost' ||
            window.location.hostname === '127.0.0.1' ||
            window.location.hostname === ''
        ) ? 'http://localhost:8000/api'
          : (window.BACKEND_URL || 'https://nasdaqsentimenttracker-production.up.railway.app/api');

        // Fetch dashboard data (composite score + 3 drivers + historical data)
        async function fetchDashboardData() {
            try {
                console.log('🔄 Fetching dashboard data from API...');
                const response = await fetch(`${API_BASE_URL}/dashboard/`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                console.log('✓ Dashboard data received:', data.composite_score);
                
                // DEBUG: Check what the backend is actually sending for price data
                console.log('🔍 BACKEND RESPONSE DEBUG:');
                if (data.historical && data.historical.length > 0) {
                    console.log('📦 Raw historical[0]:', JSON.stringify(data.historical[0], null, 2));
                    console.log('📦 Keys in historical[0]:', Object.keys(data.historical[0]));
                    console.log('📦 "price" field exists?', 'price' in data.historical[0]);
                    console.log('📦 "price" value:', data.historical[0].price);
                    console.log('📦 Type of price:', typeof data.historical[0].price);
                }
 
                // Update current composite score
                currentCompositeScore = data.composite_score;

                // Update sentiment display and drivers
                updateSentimentDisplay(data);
                updateSentimentDrivers(data.drivers, data.vxn_index);

                // Populate sentimentDataset for chart (24 hours)
                if (data.historical && data.historical.length > 0) {
                    console.log('📊 Mapping historical data - first raw point:', data.historical[0]);
                    sentimentDataset = data.historical.map(point => {
                        const mapped = {
                            timestamp: new Date(point.timestamp),
                            sentiment: point.composite_score,
                            price: point.price,
                            // OHLC data for candlestick charts
                            open: point.open,
                            high: point.high,
                            low: point.low,
                            volume: point.volume,
                            // Include individual driver scores (using actual API field names)
                            news: point.news_composite || null,
                            indicators: point.technical_composite || null
                        };
                        return mapped;
                    });
                    console.log(`✓ Loaded ${sentimentDataset.length} historical data points (24h)`);
                    console.log('📊 First mapped point:', sentimentDataset[0]);
                    // Debug: Check price data
                    const pricesWithData = sentimentDataset.filter(p => p.price != null && !isNaN(p.price));
                    console.log(`📊 Price data check: ${pricesWithData.length}/${sentimentDataset.length} points have price data`);
                    if (pricesWithData.length > 0) {
                        console.log(`📊 Sample prices: ${pricesWithData.slice(0, 3).map(p => `$${p.price.toFixed(2)}`).join(', ')}`);
                    } else {
                        console.warn('⚠️ No prices found! Sample point:', sentimentDataset[0]);
                    }
                } else {
                    console.warn('⚠️  No historical data in API response');
                    sentimentDataset = [];
                }

                // Populate sentimentDataset2d for chart (2 days)
                if (data.historical_2d && data.historical_2d.length > 0) {
                    sentimentDataset2d = data.historical_2d.map(point => ({
                        timestamp: new Date(point.timestamp),
                        sentiment: point.composite_score,
                        price: point.price,
                        open: point.open,
                        high: point.high,
                        low: point.low,
                        volume: point.volume,
                        news: point.news_composite || null,
                        indicators: point.technical_composite || null
                    }));
                    console.log(`✓ Loaded ${sentimentDataset2d.length} historical data points (2d)`);
                } else {
                    console.warn('⚠️  No 2-day historical data in API response');
                    sentimentDataset2d = [];
                }

                // Populate sentimentDataset3d for chart (3 days)
                if (data.historical_3d && data.historical_3d.length > 0) {
                    sentimentDataset3d = data.historical_3d.map(point => ({
                        timestamp: new Date(point.timestamp),
                        sentiment: point.composite_score,
                        price: point.price,
                        open: point.open,
                        high: point.high,
                        low: point.low,
                        volume: point.volume,
                        news: point.news_composite || null,
                        indicators: point.technical_composite || null
                    }));
                    console.log(`✓ Loaded ${sentimentDataset3d.length} historical data points (3d)`);
                } else {
                    console.warn('⚠️  No 3-day historical data in API response');
                    sentimentDataset3d = [];
                }

                // Update market status AFTER datasets are populated so we can use latest timestamp
                updateMarketStatus(data.market_status);

                return data;
            } catch (error) {
                console.error('❌ Error fetching dashboard data:', error);
                // Fallback to default values
                currentCompositeScore = 0;
                sentimentDataset = [];
                sentimentDataset2d = [];
                sentimentDataset3d = [];
                updateSentimentDisplay({
                    composite_score: currentCompositeScore,
                    sentiment_label: 'NEUTRAL'
                });
                return null;
            }
        }

        // ===== GRANULAR DATA FETCH FUNCTIONS =====
        
        // Fetch second candles (1-second OHLCV data)
        async function fetchSecondCandles(startTime = null) {
            try {
                // Always fetch ALL available data for the symbol, then client-side filter to most recent
                let url = `${API_BASE_URL}/second-candles/?symbol=QLD`;
                console.log('🔄 Fetching all second candles:', url);
                
                // Note: We removed limit and ordering because the API seems to return old data
                // Instead, we'll fetch everything and sort/filter on the client side
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();

                // Handle both API response structures: result.data or result.data_points
                const dataArray = result.data_points || result.data || [];
                console.log(`✅ Received ${dataArray.length} second candles from API`);
                console.log('🔍 Full API Response Keys:', Object.keys(result));

                // Debug: Log the API response structure
                if (dataArray.length > 0) {
                    console.log('🔍 API Response Structure Sample:', dataArray[0]);
                    console.log('🔍 Available fields:', Object.keys(dataArray[0]));
                }

                if (dataArray.length === 0) {
                    console.warn('⚠️ No second candles data available from API');
                    return [];
                }

                // Log the timestamp range of received data
                if (dataArray.length > 0) {
                    const firstTs = new Date(dataArray[0].timestamp);
                    const lastTs = new Date(dataArray[dataArray.length - 1].timestamp);
                    console.log(`📅 API data range: ${firstTs.toISOString()} to ${lastTs.toISOString()}`);
                    console.log(`⏰ Current time: ${new Date().toISOString()}`);
                }

                // Map to internal format
                let mappedData = dataArray.map(candle => ({
                    timestamp: new Date(candle.timestamp),
                    open: candle.open,
                    high: candle.high,
                    low: candle.low,
                    price: candle.close, // 'close' from API maps to 'price' internally
                    volume: candle.volume,
                    tick_count: candle.tick_count || 0,
                    sentiment: candle.composite_score ?? 0, // Composite score from API
                    news: candle.news_component ?? null, // News component from API
                    indicators: candle.technical_component ?? null // Technical component from API
                }));
                
                // ALWAYS sort by timestamp descending (newest first) on client side
                mappedData.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());

                // If market is closed, filter to show the last hour of trading (3pm-4pm ET)
                if (!isMarketOpen && mappedData.length > 0) {
                    // Get today's date in ET timezone
                    const now = new Date();
                    const etFormatter = new Intl.DateTimeFormat('en-US', {
                        timeZone: 'America/New_York',
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit'
                    });
                    const etParts = etFormatter.formatToParts(now);
                    const etYear = parseInt(etParts.find(p => p.type === 'year').value);
                    const etMonth = parseInt(etParts.find(p => p.type === 'month').value) - 1;
                    const etDay = parseInt(etParts.find(p => p.type === 'day').value);

                    // Helper to convert ET to UTC
                    const etToUTC = (year, month, day, hour, minute) => {
                        const isoStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}T${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}:00`;
                        let testUTC = new Date(isoStr + '-05:00');
                        return testUTC;
                    };

                    // Market close at 4pm ET, last hour is 3pm-4pm ET
                    const marketCloseTime = etToUTC(etYear, etMonth, etDay, 16, 0);
                    const lastHourStartTime = etToUTC(etYear, etMonth, etDay, 15, 0);

                    console.log(`🕒 Market closed - filtering for last trading hour: ${lastHourStartTime.toISOString()} to ${marketCloseTime.toISOString()}`);

                    // Filter data to show only the last hour of trading
                    mappedData = mappedData.filter(candle => {
                        return candle.timestamp >= lastHourStartTime && candle.timestamp <= marketCloseTime;
                    });

                    console.log(`📊 Filtered to last trading hour: ${mappedData.length} candles`);
                } else {
                    // Market is open - keep only the most recent 4000 candles (about 66 minutes of 1-second data)
                    mappedData = mappedData.slice(0, 4000);
                    console.log(`📊 After client-side sort and limit: ${mappedData.length} candles`);
                }
                if (mappedData.length > 0) {
                    console.log(`   Newest: ${mappedData[0].timestamp.toISOString()}`);
                    console.log(`   Oldest: ${mappedData[mappedData.length - 1].timestamp.toISOString()}`);
                    console.log(`   📊 SENTIMENT DATA CHECK:`, {
                        sentiment: mappedData[0].sentiment,
                        news: mappedData[0].news,
                        indicators: mappedData[0].indicators,
                        raw_api_data: result.data[0]
                    });
                }
                
                // ALWAYS replace the dataset with the freshest data
                // This ensures the chart updates every second even if no NEW candles exist
                secondCandlesDataset = mappedData;
                console.log(`📊 Dataset refreshed: ${secondCandlesDataset.length} candles (newest: ${mappedData[0].timestamp.toISOString()})`);
                
                // Update last timestamp for incremental updates
                if (secondCandlesDataset.length > 0) {
                    lastGranularTimestamp = secondCandlesDataset[secondCandlesDataset.length - 1].timestamp;
                }
                
                return mappedData;
            } catch (error) {
                console.error('❌ Error fetching second candles:', error);
                return [];
            }
        }
        
        // Fetch tick candles (100-tick OHLCV data)
        async function fetchTickCandles(startTime = null) {
            try {
                // If startTime is provided, we're doing an incremental update - only fetch recent data
                let url = `${API_BASE_URL}/tick-candles/?symbol=QLD`;
                if (startTime) {
                    // For incremental updates, fetch the most recent candles
                    // Order by timestamp descending to get the newest data first
                    url += `&limit=120&ordering=-timestamp`;
                    console.log('🔄 Fetching incremental tick candles (last 120, newest first):', url);
                } else {
                    // Initial load: fetch enough for the longest view
                    // Order by timestamp descending to get the newest data
                    url += `&limit=1000&ordering=-timestamp`;
                    console.log('🔄 Fetching initial tick candles (last 1000, newest first):', url);
                }
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                console.log(`✅ Received ${result.data.length} tick candles from API`);
                
                if (result.data.length === 0) {
                    console.warn('⚠️ No tick candles data available from API');
                    return [];
                }
                
                // Log the timestamp range of received data
                if (result.data.length > 0) {
                    const firstTs = new Date(result.data[0].timestamp);
                    const lastTs = new Date(result.data[result.data.length - 1].timestamp);
                    console.log(`📅 API data range: ${firstTs.toISOString()} to ${lastTs.toISOString()}`);
                    console.log(`⏰ Current time: ${new Date().toISOString()}`);
                }
                
                // Map to internal format
                const mappedData = result.data.map(candle => ({
                    timestamp: new Date(candle.timestamp),
                    open: candle.open,
                    high: candle.high,
                    low: candle.low,
                    price: candle.close, // 'close' from API maps to 'price' internally
                    volume: candle.volume,
                    tick_count: candle.tick_count || 100,
                    candle_number: candle.candle_number,
                    duration_seconds: candle.duration_seconds,
                    sentiment: candle.composite_score ?? 0, // Composite score from API
                    news: candle.news_component ?? null, // News component from API
                    indicators: candle.technical_component ?? null // Technical component from API
                }));
                
                // If this is an incremental update, merge with existing data
                if (startTime && tickCandlesDataset.length > 0) {
                    // Create a map of existing timestamps for faster lookup
                    const existingTimestamps = new Set(
                        tickCandlesDataset.map(d => d.timestamp.getTime())
                    );
                    
                    // Filter out duplicates based on timestamp
                    const uniqueNewData = mappedData.filter(d => !existingTimestamps.has(d.timestamp.getTime()));
                    
                    if (uniqueNewData.length > 0) {
                        // Merge and sort by timestamp
                        tickCandlesDataset = [...tickCandlesDataset, ...uniqueNewData]
                            .sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
                        
                        // Keep only last 1 hour
                        const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
                        tickCandlesDataset = tickCandlesDataset.filter(d => d.timestamp > oneHourAgo);
                        
                        console.log(`📊 Appended ${uniqueNewData.length} new tick candles, total ${tickCandlesDataset.length}`);
                        
                        // Log the new data range
                        if (tickCandlesDataset.length > 0) {
                            const firstDs = tickCandlesDataset[0].timestamp;
                            const lastDs = tickCandlesDataset[tickCandlesDataset.length - 1].timestamp;
                            console.log(`📊 Dataset now spans: ${firstDs.toISOString()} to ${lastDs.toISOString()}`);
                        }
                    } else {
                        console.log('✓ No new unique tick candles to append (all timestamps already exist)');
                    }
                } else {
                    tickCandlesDataset = mappedData;
                    console.log(`📊 Loaded ${tickCandlesDataset.length} tick candles`);
                }
                
                // Update last timestamp for incremental updates
                if (tickCandlesDataset.length > 0) {
                    lastGranularTimestamp = tickCandlesDataset[tickCandlesDataset.length - 1].timestamp;
                }
                
                return mappedData;
            } catch (error) {
                console.error('❌ Error fetching tick candles:', error);
                return [];
            }
        }
        
        // Aggregate candles into larger timeframes (e.g., 1s → 30s)
        function aggregateCandles(candles, intervalSeconds) {
            if (!candles || candles.length === 0) return [];
            
            console.log(`📊 Aggregating ${candles.length} candles into ${intervalSeconds}s intervals`);
            
            const aggregated = [];
            const intervalMs = intervalSeconds * 1000;
            
            // Sort by timestamp
            const sorted = [...candles].sort((a, b) => a.timestamp - b.timestamp);
            
            let currentBucket = [];
            let bucketStartTime = null;
            
            for (const candle of sorted) {
                const candleTime = candle.timestamp.getTime();
                
                if (!bucketStartTime) {
                    bucketStartTime = Math.floor(candleTime / intervalMs) * intervalMs;
                }
                
                const bucketEnd = bucketStartTime + intervalMs;
                
                if (candleTime < bucketEnd) {
                    currentBucket.push(candle);
                } else {
                    // Finalize current bucket
                    if (currentBucket.length > 0) {
                        aggregated.push(createAggregatedCandle(currentBucket, bucketStartTime));
                    }
                    
                    // Start new bucket
                    bucketStartTime = Math.floor(candleTime / intervalMs) * intervalMs;
                    currentBucket = [candle];
                }
            }
            
            // Finalize last bucket
            if (currentBucket.length > 0) {
                aggregated.push(createAggregatedCandle(currentBucket, bucketStartTime));
            }
            
            console.log(`✓ Created ${aggregated.length} aggregated candles`);

            // Debug: Log sentiment data in first aggregated candle
            if (aggregated.length > 0) {
                console.log(`   First aggregated candle sentiment: composite=${aggregated[0].sentiment}, news=${aggregated[0].news}, indicators=${aggregated[0].indicators}`);
            }

            return aggregated;
        }
        
        function createAggregatedCandle(candles, bucketStartTime) {
            const open = candles[0].open;
            const close = candles[candles.length - 1].price;
            const high = Math.max(...candles.map(c => c.high));
            const low = Math.min(...candles.map(c => c.low));
            const volume = candles.reduce((sum, c) => sum + (c.volume || 0), 0);
            const tick_count = candles.reduce((sum, c) => sum + (c.tick_count || 0), 0);

            // Average the sentiment values across all candles in this bucket
            const sentimentValues = candles.filter(c => c.sentiment != null && !isNaN(c.sentiment));
            const avgSentiment = sentimentValues.length > 0
                ? sentimentValues.reduce((sum, c) => sum + c.sentiment, 0) / sentimentValues.length
                : 0;

            const newsValues = candles.filter(c => c.news != null && !isNaN(c.news));
            const avgNews = newsValues.length > 0
                ? newsValues.reduce((sum, c) => sum + c.news, 0) / newsValues.length
                : null;

            const indicatorValues = candles.filter(c => c.indicators != null && !isNaN(c.indicators));
            const avgIndicators = indicatorValues.length > 0
                ? indicatorValues.reduce((sum, c) => sum + c.indicators, 0) / indicatorValues.length
                : null;

            return {
                timestamp: new Date(bucketStartTime),
                open,
                high,
                low,
                price: close,
                volume,
                tick_count,
                sentiment: avgSentiment,
                news: avgNews,
                indicators: avgIndicators
            };
        }
        
        // Fetch historical sentiment data for chart from dashboard endpoint
        async function fetchHistoricalData(timeframeMinutes = 240) {
            try {
                console.log('Fetching historical data from dashboard API...');
                const url = `${API_BASE_URL}/dashboard/`;
                console.log('API URL:', url);

                const response = await fetch(url);
                console.log('Response status:', response.status);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('Dashboard API response received');

                // Populate 24-hour dataset
                if (!data.historical || data.historical.length === 0) {
                    console.warn('No historical data points in API response');
                    sentimentDataset = [];
                } else {
                    sentimentDataset = data.historical.map(point => ({
                        timestamp: new Date(point.timestamp),
                        sentiment: point.composite_score,
                        price: point.price
                    }));
                    console.log('Converted 24h dataset length:', sentimentDataset.length);
                }

                // Populate 2-day dataset
                if (data.historical_2d && data.historical_2d.length > 0) {
                    sentimentDataset2d = data.historical_2d.map(point => ({
                        timestamp: new Date(point.timestamp),
                        sentiment: point.composite_score,
                        price: point.price
                    }));
                    console.log('Converted 2d dataset length:', sentimentDataset2d.length);
                } else {
                    sentimentDataset2d = [];
                }

                // Populate 3-day dataset
                if (data.historical_3d && data.historical_3d.length > 0) {
                    sentimentDataset3d = data.historical_3d.map(point => ({
                        timestamp: new Date(point.timestamp),
                        sentiment: point.composite_score,
                        price: point.price
                    }));
                    console.log('Converted 3d dataset length:', sentimentDataset3d.length);
                } else {
                    sentimentDataset3d = [];
                }

                return data;
            } catch (error) {
                console.error('Error fetching historical data:', error);
                console.error('Error details:', error.message);
                // Fallback to empty datasets
                sentimentDataset = [];
                sentimentDataset2d = [];
                sentimentDataset3d = [];
                return null;
            }
        }
        
        // Update sentiment display with real data
        function updateSentimentDisplay(data) {
            console.log('updateSentimentDisplay called with data:', data);

            let sentiment = data.composite_score;

            // Check if signal mode is active and calculate signal value
            const signalModeActive = document.getElementById('signal-mode-toggle')?.classList.contains('active') || false;
            if (signalModeActive && window.currentChartData && window.currentChartData.length > 0) {
                // Get the most recent data point's signal value
                const lastPoint = window.currentChartData[window.currentChartData.length - 1];
                if (lastPoint && lastPoint.signalValue != null) {
                    sentiment = lastPoint.signalValue;
                }
            }

            console.log('Composite score value:', sentiment);
            const sentimentDisplay = sentiment > 0 ? `+${sentiment.toFixed(1)}` : sentiment.toFixed(1);
            console.log('Formatted sentiment display:', sentimentDisplay);

            // Update oscillator current score panel (primary display for this page)
            const oscillatorScoreElement = document.getElementById('oscillator-current-score');
            console.log('Updating oscillator score panel:', sentimentDisplay, 'Element found:', !!oscillatorScoreElement);
            if (oscillatorScoreElement) {
                oscillatorScoreElement.textContent = sentimentDisplay;
                console.log('✅ Oscillator score updated to:', sentimentDisplay);
            } else {
                console.error('❌ oscillator-current-score element not found!');
            }

            // Update main score elements if they exist (they may be in a different page/section)
            const scoreValueElement = document.querySelector('.score-value');
            const scoreStatus = document.querySelector('.score-status');

            if (scoreValueElement && scoreStatus) {
                // Update score value
                scoreValueElement.textContent = sentimentDisplay;

                // Update status and colors based on sentiment
                if (sentiment >= 30) {
                    scoreStatus.textContent = t('dashboard.status.bullish');
                    scoreStatus.setAttribute('data-i18n', 'dashboard.status.bullish');
                    scoreStatus.style.color = '#10b981';
                    scoreValueElement.style.background = 'linear-gradient(135deg, #10b981 0%, #34d399 100%)';
                } else if (sentiment >= -30) {
                    scoreStatus.textContent = t('dashboard.status.neutral');
                    scoreStatus.setAttribute('data-i18n', 'dashboard.status.neutral');
                    scoreStatus.style.color = '#888';
                    scoreValueElement.style.background = 'linear-gradient(135deg, #888 0%, #aaa 100%)';
                } else {
                    scoreStatus.textContent = t('dashboard.status.bearish');
                    scoreStatus.setAttribute('data-i18n', 'dashboard.status.bearish');
                    scoreStatus.style.color = '#ef4444';
                    scoreValueElement.style.background = 'linear-gradient(135deg, #ef4444 0%, #f87171 100%)';
                }

                // Apply text styling
                scoreValueElement.style.webkitBackgroundClip = 'text';
                scoreValueElement.style.webkitTextFillColor = 'transparent';
                scoreValueElement.style.backgroundClip = 'text';
                console.log('✅ Main score elements updated');
            } else {
                console.log('ℹ️ Main score elements not found (may be on different page) - oscillator panel updated successfully');
            }
        }

        // Track market status globally
        let isMarketOpen = true;

        // Update market status indicator
        function updateMarketStatus(marketStatus) {
            if (!marketStatus) return;

            const indicator = document.getElementById('market-status-indicator');
            const closeTimeSpan = document.getElementById('market-close-time');

            if (!indicator || !closeTimeSpan) return;

            // Update global market status
            isMarketOpen = marketStatus.is_open;

            if (marketStatus.is_open) {
                // Market is open - hide indicator
                indicator.style.display = 'none';
            } else {
                // Market is closed - show small indicator with timestamp from latest data point
                // Find the latest timestamp from all available datasets
                let latestTimestamp = null;
                
                // Check all datasets and find the most recent timestamp
                const allDatasets = [sentimentDataset, sentimentDataset2d, sentimentDataset3d];
                for (const dataset of allDatasets) {
                    if (dataset && dataset.length > 0) {
                        // Find the latest timestamp in this dataset
                        for (const point of dataset) {
                            if (point && point.timestamp) {
                                const pointTime = point.timestamp instanceof Date ? point.timestamp : new Date(point.timestamp);
                                if (!latestTimestamp || pointTime > latestTimestamp) {
                                    latestTimestamp = pointTime;
                                }
                            }
                        }
                    }
                }
                
                // Use the latest timestamp from data, or fallback to current time
                const closeTime = latestTimestamp ? new Date(latestTimestamp) : new Date();
                const formattedTime = closeTime.toLocaleString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit',
                    timeZoneName: 'short'
                });
                closeTimeSpan.textContent = formattedTime;
                indicator.style.display = 'block';
            }
        }

        // Update sentiment drivers with real data from API
        function updateSentimentDrivers(drivers, vxnIndex) {
            if (!drivers) return;

            // Get driver elements
            const driverItems = document.querySelectorAll('.driver-item');

            // Convert VXN index to a sentiment score (-100 to +100)
            // VXN typically ranges from ~10 to ~40
            // Lower VXN = less volatility = more bullish
            // Higher VXN = more volatility = more bearish
            let vixScore = 0;
            if (vxnIndex) {
                // Normalize VXN: 15 is baseline (neutral), below is bullish, above is bearish
                // Scale: VXN 10 = +100, VXN 15 = 0, VXN 40 = -100
                vixScore = Math.max(-100, Math.min(100, ((15 - vxnIndex) / 15) * 100));
            }

            // Update the drivers with real data from API
            const driverData = [
                {
                    name: t('dashboard.driver.news'),
                    translationKey: 'dashboard.driver.news',
                    value: drivers.news_sentiment?.score || 0,
                    weight: drivers.news_sentiment?.weight || 40
                },
                {
                    name: t('dashboard.driver.social'),
                    translationKey: 'dashboard.driver.social',
                    value: drivers.social_media?.score || 0,
                    weight: drivers.social_media?.weight || 30
                },
                {
                    name: t('dashboard.driver.indicators'),
                    translationKey: 'dashboard.driver.indicators',
                    value: drivers.technical_indicators?.score || 0,
                    weight: drivers.technical_indicators?.weight || 30
                },
                {
                    name: t('dashboard.driver.recommendations'),
                    translationKey: 'dashboard.driver.recommendations',
                    value: drivers.analyst_recommendations?.score || 0,
                    weight: drivers.analyst_recommendations?.weight || 0
                },
                {
                    name: t('dashboard.driver.vix'),
                    translationKey: 'dashboard.driver.vix',
                    value: vixScore,
                    weight: 0,
                    rawValue: vxnIndex // Store raw VXN value for display
                }
            ];

            driverData.forEach((driver, index) => {
                if (driverItems[index]) {
                    const driverItem = driverItems[index];
                    const nameElement = driverItem.querySelector('.driver-name');
                    const valueElement = driverItem.querySelector('.driver-value');
                    const progressFill = driverItem.querySelector('.progress-fill');

                    // Update name
                    if (nameElement) {
                        nameElement.textContent = driver.name;
                        // Add translation key as data attribute for future updates
                        if (driver.translationKey) {
                            nameElement.setAttribute('data-i18n', driver.translationKey);
                        }
                    }

                    // Update value with +/- sign
                    if (valueElement) {
                        // Special handling for VIX - show raw VXN value instead of normalized score
                        let displayValue;
                        if (driver.rawValue !== undefined) {
                            displayValue = driver.rawValue.toFixed(2);
                        } else {
                            displayValue = driver.value > 0 ? `+${driver.value.toFixed(1)}` : driver.value.toFixed(1);
                        }
                        valueElement.textContent = displayValue;

                        // Update color based on positive/negative
                        valueElement.classList.remove('positive', 'negative', 'neutral');
                        if (driver.value > 0) {
                            valueElement.classList.add('positive');
                        } else if (driver.value < 0) {
                            valueElement.classList.add('negative');
                        } else {
                            valueElement.classList.add('neutral');
                        }
                    }

                    // Update progress bar
                    if (progressFill) {
                        // Calculate width based on absolute value (0-100 scale)
                        // -80 and +80 both fill 80% of the bar
                        const width = Math.abs(driver.value);
                        const clampedWidth = Math.max(0, Math.min(100, width));

                        progressFill.style.width = `${clampedWidth}%`;

                        // Update color based on positive/negative
                        progressFill.classList.remove('positive', 'negative', 'neutral');
                        if (driver.value > 0) {
                            progressFill.classList.add('positive');
                        } else if (driver.value < 0) {
                            progressFill.classList.add('negative');
                        } else {
                            progressFill.classList.add('neutral');
                        }
                    }
                }
            });

            console.log('Sentiment drivers updated:', driverData);
        }
        
        // Helper function to create smooth SVG path from data points
        function createSmoothPath(points) {
            if (!points || points.length === 0) {
                console.log('No data points to create path');
                return '';
            }

            console.log('Creating path with', points.length, 'points:', points);

            // FIXED SCALE: Always use -100 to +100 range
            // This ensures 0 is always at the center (Y=50)
            const minSentiment = -100;
            const maxSentiment = 100;
            const sentimentRange = 200;

            console.log('Using fixed sentiment range: -100 to +100');

            // Convert sentiment to Y coordinate (0 to 100)
            // +100 sentiment = Y=0 (top of chart)
            // 0 sentiment = Y=50 (center line)
            // -100 sentiment = Y=100 (bottom of chart)
            const sentimentToY = (sentiment) => {
                // Map sentiment from [-100, 100] to [100, 0] (inverted Y axis)
                const y = 50 - (sentiment / 2);
                return Math.max(0, Math.min(100, y)); // Clamp between 0-100
            };

            // Start path at first point
            const x0 = 0;
            const y0 = sentimentToY(points[0].sentiment);
            let path = `M ${x0},${y0}`;

            // Create smooth curve through all points
            for (let i = 1; i < points.length; i++) {
                const x = (i / (points.length - 1)) * 100;
                const y = sentimentToY(points[i].sentiment);

                if (i === 1) {
                    // First curve - use quadratic bezier
                    const cx = x / 2;
                    const prevY = sentimentToY(points[0].sentiment);
                    path += ` Q ${cx},${prevY} ${x},${y}`;
                } else {
                    // Smooth curves using cubic bezier
                    const prevX = ((i - 1) / (points.length - 1)) * 100;
                    const prevY = sentimentToY(points[i - 1].sentiment);
                    const cx1 = prevX + (x - prevX) / 3;
                    const cy1 = prevY;
                    const cx2 = prevX + (x - prevX) * 2 / 3;
                    const cy2 = y;
                    path += ` C ${cx1},${cy1} ${cx2},${cy2} ${x},${y}`;
                }
            }

            console.log('Generated SVG path:', path);
            return path;
        }
        
        // Helper function to format time labels in HH:MM:SS format based on selected timezone
        function formatTimeLabel(minutesAgo) {
            const now = new Date();
            // Calculate the time by subtracting minutes
            const pastTime = new Date(now.getTime() - (minutesAgo * 60000));
            
            // Apply timezone offset if a timezone is selected
            let targetTime = pastTime;
            if (currentTimezoneData) {
                const offsetHours = parseOffset(currentTimezoneData.offset);
                const utc = pastTime.getTime() + (pastTime.getTimezoneOffset() * 60000);
                targetTime = new Date(utc + (3600000 * offsetHours));
            }
            
            const hours = String(targetTime.getHours()).padStart(2, '0');
            const minutes = String(targetTime.getMinutes()).padStart(2, '0');
            const seconds = String(targetTime.getSeconds()).padStart(2, '0');
            
            return `${hours}:${minutes}:${seconds}`;
        }
        
        // Timeframe configurations - how many minutes of data to show
        const timeframeConfig = {
            '1m': {
                minutes: 1,   // Show last 1 minute of data
                labelCount: 5,
                label: '1min',
                dataset: 'sentimentDataset',
                supportsGranular: true,  // Can use granular data if toggle is enabled
                candleSize: 1,  // 1-second candles
                updateInterval: 1000  // Update every 1 second (1000ms)
            },
            '5m': {
                minutes: 5,   // Show last 5 minutes of data
                labelCount: 5,
                label: '5min',
                dataset: 'sentimentDataset',
                supportsGranular: true,
                candleSize: 5,  // 5-second candles
                updateInterval: 5000  // Update every 5 seconds (5000ms)
            },
            '15m': {
                minutes: 15,  // Show last 15 minutes
                labelCount: 5,
                label: '15min',
                dataset: 'sentimentDataset',
                supportsGranular: true,
                candleSize: 5,  // 5-second candles
                updateInterval: 5000  // Update every 5 seconds (5000ms)
            },
            '30m': {
                minutes: 30,  // Show last 30 minutes
                labelCount: 6,
                label: '30min',
                dataset: 'sentimentDataset',
                supportsGranular: true,
                candleSize: 30,  // 30-second candles
                updateInterval: 30000  // Update every 30 seconds (30000ms)
            },
            '1h': {
                minutes: 60,  // Show last 1 hour
                labelCount: 5,
                label: '1hr',
                dataset: 'sentimentDataset',
                supportsGranular: true,
                candleSize: 30,  // 30-second candles
                updateInterval: 30000  // Update every 30 seconds (30000ms)
            },
            '2h': {
                minutes: 120, // Show last 2 hours
                labelCount: 6,
                label: '2hrs',
                dataset: 'sentimentDataset'
            },
            '4h': {
                minutes: 240, // Show last 4 hours
                labelCount: 6,
                label: '4hrs',
                dataset: 'sentimentDataset'
            },
            '6h': {
                minutes: 360, // Show last 6 hours (trading session)
                labelCount: 6,
                label: 'Session',
                dataset: 'sentimentDataset'
            },
            '2d': {
                minutes: 2880, // Show last 48 hours (2 days)
                labelCount: 8,
                label: '2days',
                dataset: 'sentimentDataset2d'
            },
            '3d': {
                minutes: 4320, // Show last 72 hours (3 days)
                labelCount: 10,
                label: '3days',
                dataset: 'sentimentDataset3d'
            }
        };

        function getDataForTimeframe(timeframe, scrollPos = 100) {
            const config = timeframeConfig[timeframe];
            console.log(`\n=== Getting data for ${timeframe} (last ${config.minutes} minutes, scroll: ${scrollPos}%) ===`);

            // Select the appropriate dataset based on timeframe
            let activeDataset;
            let usingGranularData = false;
            let rawGranularDataset = null; // Store raw dataset before aggregation
            
            // Try to use granular data if:
            // 1. Timeframe supports granular data
            // 2. Granular dataset has data
            // 3. User has interacted with the toggle (granular data was fetched)
            if (config.supportsGranular) {
                const granularDataset = granularDataType === 'second' ? secondCandlesDataset : tickCandlesDataset;
                
                if (granularDataset.length > 0) {
                    console.log(`✅ Using ${granularDataType} candles dataset (${granularDataset.length} points)`);
                    usingGranularData = true;

                    // Aggregate for longer timeframes to reduce point count
                    if (granularDataType === 'second') {
                        if (timeframe === '1h') {
                            // 1-hour timeframe: use 30-second candles
                            rawGranularDataset = granularDataset; // Store reference to raw data
                            activeDataset = aggregateCandles([...granularDataset], 30);
                            console.log(`📊 Aggregated to 30s candles: ${activeDataset.length} points`);
                        } else if (timeframe === '30m') {
                            // 30-minute timeframe: use 30-second candles
                            rawGranularDataset = granularDataset; // Store reference to raw data
                            activeDataset = aggregateCandles([...granularDataset], 30);
                            console.log(`📊 Aggregated to 30s candles: ${activeDataset.length} points`);
                        } else if (timeframe === '15m') {
                            // 15-minute timeframe: use 5-second candles
                            rawGranularDataset = granularDataset; // Store reference to raw data
                            activeDataset = aggregateCandles([...granularDataset], 5);
                            console.log(`📊 Aggregated to 5s candles: ${activeDataset.length} points`);
                        } else if (timeframe === '5m') {
                            // 5-minute timeframe: use 5-second candles
                            rawGranularDataset = granularDataset; // Store reference to raw data
                            activeDataset = aggregateCandles([...granularDataset], 5);
                            console.log(`📊 Aggregated to 5s candles: ${activeDataset.length} points`);
                        } else {
                            // For 1m or any other second-based timeframe: full 1-second resolution (no aggregation)
                            // IMPORTANT: secondCandlesDataset is sorted DESCENDING (newest first)
                            // But other timeframes use aggregateCandles() which sorts ASCENDING
                            // We need to reverse it to match the expected order for scrollback
                            rawGranularDataset = granularDataset;
                            activeDataset = [...granularDataset].reverse(); // Reverse to ascending (oldest first)
                            console.log(`📊 Using 1s candles (no aggregation, reversed to ascending): ${activeDataset.length} points for ${timeframe}`);
                        }
                    } else {
                        // For tick data, no aggregation needed
                        rawGranularDataset = granularDataset;
                        activeDataset = granularDataset;
                    }
                } else {
                    // Fallback to regular dataset if granular data not available
                    console.log('⚠️ Granular data not available, using regular sentimentDataset as fallback');
                    activeDataset = sentimentDataset;
                }
            } else if (config.dataset === 'sentimentDataset2d') {
                activeDataset = sentimentDataset2d;
                console.log('Using 2-day dataset');
            } else if (config.dataset === 'sentimentDataset3d') {
                activeDataset = sentimentDataset3d;
                console.log('Using 3-day dataset');
            } else {
                activeDataset = sentimentDataset;
                console.log('Using 24-hour dataset');
            }

            console.log('Total dataset length:', activeDataset.length);

            if (!activeDataset || activeDataset.length === 0) {
                console.log('❌ No sentiment data available for this timeframe');
                return { labels: [], path: '', dataPoints: [], count: 0 };
            }

            // Calculate cutoff time
            // When market is closed, use the last data point's time as "now"
            // When market is open, use current time
            const now = isMarketOpen
                ? new Date()
                : (activeDataset.length > 0 ? new Date(activeDataset[activeDataset.length - 1].timestamp) : new Date());

            let cutoffTime;
            let endTime; // For Session timeframe or scroll window end time

            // Helper function to convert ET time to UTC
            const etToUTC = (year, month, day, hour, minute) => {
                const isoStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}T${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}:00`;
                let testUTC = new Date(isoStr + '-05:00');
                let etParts = new Intl.DateTimeFormat('en-US', {
                    timeZone: 'America/New_York',
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                }).formatToParts(testUTC);

                let matches = parseInt(etParts.find(p => p.type === 'year').value) === year &&
                             parseInt(etParts.find(p => p.type === 'month').value) === (month + 1) &&
                             parseInt(etParts.find(p => p.type === 'day').value) === day &&
                             parseInt(etParts.find(p => p.type === 'hour').value) === hour &&
                             parseInt(etParts.find(p => p.type === 'minute').value) === minute;

                if (!matches) {
                    testUTC = new Date(isoStr + '-04:00');
                }

                return testUTC;
            };

            // Get current date in Eastern Time
            const etFormatter = new Intl.DateTimeFormat('en-US', {
                timeZone: 'America/New_York',
                year: 'numeric',
                month: '2-digit',
                day: '2-digit'
            });

            const parts = etFormatter.formatToParts(now);
            const etYear = parseInt(parts.find(p => p.type === 'year').value);
            const etMonth = parseInt(parts.find(p => p.type === 'month').value) - 1;
            const etDay = parseInt(parts.find(p => p.type === 'day').value);

            // Special handling for Session (6h), 2-day, and 3-day timeframes
            if (timeframe === '6h') {
                // Session: Show current trading day only
                cutoffTime = etToUTC(etYear, etMonth, etDay, 9, 30);
                endTime = etToUTC(etYear, etMonth, etDay, 16, 0);

                console.log('Session timeframe: Current trading day');
                console.log('Market open (9:30 AM ET):', cutoffTime.toISOString());
                console.log('Market close (4:00 PM ET):', endTime.toISOString());
            } else if (timeframe === '2d') {
                // 2-day: Show last 2 complete trading days (yesterday + today)
                const yesterday = new Date(etYear, etMonth, etDay);
                yesterday.setDate(yesterday.getDate() - 1);
                const yParts = etFormatter.formatToParts(yesterday);
                const yYear = parseInt(yParts.find(p => p.type === 'year').value);
                const yMonth = parseInt(yParts.find(p => p.type === 'month').value) - 1;
                const yDay = parseInt(yParts.find(p => p.type === 'day').value);

                cutoffTime = etToUTC(yYear, yMonth, yDay, 9, 30);
                endTime = isMarketOpen ? now : etToUTC(etYear, etMonth, etDay, 16, 0);

                console.log('2-day timeframe: From', cutoffTime.toISOString(), 'to', endTime.toISOString());
            } else if (timeframe === '3d') {
                // 3-day: Show last 3 complete trading days
                const twoDaysAgo = new Date(etYear, etMonth, etDay);
                twoDaysAgo.setDate(twoDaysAgo.getDate() - 2);
                const tParts = etFormatter.formatToParts(twoDaysAgo);
                const tYear = parseInt(tParts.find(p => p.type === 'year').value);
                const tMonth = parseInt(tParts.find(p => p.type === 'month').value) - 1;
                const tDay = parseInt(tParts.find(p => p.type === 'day').value);

                cutoffTime = etToUTC(tYear, tMonth, tDay, 9, 30);
                endTime = isMarketOpen ? now : etToUTC(etYear, etMonth, etDay, 16, 0);

                console.log('3-day timeframe: From', cutoffTime.toISOString(), 'to', endTime.toISOString());
            } else {
                // Regular timeframes: scrollable window within today's data
                const marketOpenTime = etToUTC(etYear, etMonth, etDay, 9, 30);

                // Calculate the window end time based on scroll position
                // scrollPos = 100 means endTime = now (most recent)
                // scrollPos = 0 means endTime = marketOpenTime + window size
                const windowSizeMs = config.minutes * 60 * 1000;
                
                // If using granular seconds, ensure we respect proper window calculation for all granular timeframes
                if (usingGranularData && granularDataType === 'second' && (timeframe === '1m' || timeframe === '5m' || timeframe === '15m' || timeframe === '30m' || timeframe === '1h')) {
                    // CRITICAL: Use activeDataset (aggregated) timestamps for BOTH calculation AND filtering
                    // This prevents timestamp mismatch between window calculation and data filtering
                    const latestDataTime = activeDataset.length > 0
                        ? activeDataset[activeDataset.length - 1].timestamp
                        : new Date();

                    const oldestDataTime = activeDataset.length > 0
                        ? activeDataset[0].timestamp
                        : new Date();

                    console.log(`🔍 Active dataset range: ${oldestDataTime.toISOString()} to ${latestDataTime.toISOString()}`);
                    console.log(`🔍 Active dataset size: ${activeDataset.length} candles`);

                    if (scrollPos >= 100) {
                        // When viewing live data and market is open, use current time
                        // This ensures the window slides forward in real-time
                        if (isMarketOpen) {
                            endTime = now; // Use current time for live updates
                            cutoffTime = new Date(endTime.getTime() - windowSizeMs);
                            console.log(`📍 Live mode: window from ${cutoffTime.toISOString()} to ${endTime.toISOString()}`);
                        } else {
                            // Market closed: window ends at latest data
                            endTime = latestDataTime;
                            cutoffTime = new Date(endTime.getTime() - windowSizeMs);
                            console.log(`📍 Replay mode: window from ${cutoffTime.toISOString()} to ${endTime.toISOString()}`);
                        }
                    } else {
                        // Scrolling back - use sliding window approach like standard timeframes
                        console.log(`📜 Scrollback mode: data range from ${oldestDataTime.toISOString()} to ${latestDataTime.toISOString()}`);

                        // Calculate the scrollable range (same logic as standard timeframes)
                        const availableDataRangeMs = latestDataTime.getTime() - oldestDataTime.getTime();
                        const maxScrollRangeMs = availableDataRangeMs - windowSizeMs;

                        if (maxScrollRangeMs > 0) {
                            // Sliding window: both cutoffTime and endTime move based on scroll position
                            const scrollFraction = scrollPos / 100;
                            endTime = new Date(oldestDataTime.getTime() + windowSizeMs + (scrollFraction * maxScrollRangeMs));
                            cutoffTime = new Date(endTime.getTime() - windowSizeMs);
                            console.log(`📍 Scrollback ${scrollPos}%: window from ${cutoffTime.toISOString()} to ${endTime.toISOString()}`);
                        } else {
                            // Not enough data for a full window, show everything we have
                            cutoffTime = oldestDataTime;
                            endTime = latestDataTime;
                            console.log(`📍 Showing all available data: ${cutoffTime.toISOString()} to ${endTime.toISOString()}`);
                        }
                    }
                } else {
                    // Standard logic for other timeframes
                    const maxScrollRangeMs = now.getTime() - marketOpenTime.getTime() - windowSizeMs;

                    if (maxScrollRangeMs > 0) {
                        // Calculate end time based on scroll position (inverse: 100 = now, 0 = earliest)
                        const scrollFraction = scrollPos / 100;
                        endTime = new Date(marketOpenTime.getTime() + windowSizeMs + (scrollFraction * maxScrollRangeMs));
                        cutoffTime = new Date(endTime.getTime() - windowSizeMs);
                    } else {
                        // Not enough data for scrolling, just show what we have
                        cutoffTime = marketOpenTime;
                        endTime = now;
                    }
                }
            }

            console.log('Cutoff time:', cutoffTime.toISOString());
            if (endTime) console.log('End time:', endTime.toISOString());
            console.log('Reference time (now):', now.toISOString());
            console.log('Market status:', isMarketOpen ? 'OPEN' : 'CLOSED');

            // For stable NASDAQ scaling, first get ALL data for the entire timeframe (before scroll window)
            // This prevents the price line from jumping as you scroll
            let fullTimeframeData;
            if (timeframe === '6h' || timeframe === '2d' || timeframe === '3d') {
                // For fixed timeframes, use the full range
                const fullCutoffTime = timeframe === '6h' ? etToUTC(etYear, etMonth, etDay, 9, 30)
                    : timeframe === '2d' ? (() => {
                        const yesterday = new Date(etYear, etMonth, etDay);
                        yesterday.setDate(yesterday.getDate() - 1);
                        const yParts = etFormatter.formatToParts(yesterday);
                        return etToUTC(parseInt(yParts.find(p => p.type === 'year').value),
                                      parseInt(yParts.find(p => p.type === 'month').value) - 1,
                                      parseInt(yParts.find(p => p.type === 'day').value), 9, 30);
                    })()
                    : (() => {
                        const twoDaysAgo = new Date(etYear, etMonth, etDay);
                        twoDaysAgo.setDate(twoDaysAgo.getDate() - 2);
                        const tParts = etFormatter.formatToParts(twoDaysAgo);
                        return etToUTC(parseInt(tParts.find(p => p.type === 'year').value),
                                      parseInt(tParts.find(p => p.type === 'month').value) - 1,
                                      parseInt(tParts.find(p => p.type === 'day').value), 9, 30);
                    })();
                const fullEndTime = isMarketOpen ? now : etToUTC(etYear, etMonth, etDay, 16, 0);
                fullTimeframeData = activeDataset.filter(d => d.timestamp >= fullCutoffTime && d.timestamp <= fullEndTime);
            } else {
                // For scrollable timeframes, get all data from market open today
                const marketOpenTime = etToUTC(etYear, etMonth, etDay, 9, 30);
                fullTimeframeData = activeDataset.filter(d => d.timestamp >= marketOpenTime && d.timestamp <= now);
            }

            // Calculate price range from FULL timeframe data (not scroll window)
            const pricesInFullTimeframe = fullTimeframeData.filter(d => d.price != null && !isNaN(d.price)).map(d => d.price);
            let priceRange = null;
            if (pricesInFullTimeframe.length > 0) {
                const sortedPrices = [...pricesInFullTimeframe].sort((a, b) => a - b);
                const medianPrice = sortedPrices.length % 2 === 0
                    ? (sortedPrices[sortedPrices.length / 2 - 1] + sortedPrices[sortedPrices.length / 2]) / 2
                    : sortedPrices[Math.floor(sortedPrices.length / 2)];
                priceRange = {
                    median: medianPrice,
                    min: Math.min(...pricesInFullTimeframe),
                    max: Math.max(...pricesInFullTimeframe)
                };
                console.log(`📊 Full timeframe price range - Median: $${medianPrice.toFixed(2)}, Range: $${priceRange.min.toFixed(2)} - $${priceRange.max.toFixed(2)}`);
            }

            // Filter data points within the timeframe using actual timestamps
            let filteredData;
            if (endTime) {
                // Use the calculated time window
                filteredData = activeDataset.filter(d => d.timestamp >= cutoffTime && d.timestamp <= endTime);
            } else {
                filteredData = activeDataset.filter(d => d.timestamp >= cutoffTime);
            }
            console.log('✓ Filtered data points:', filteredData.length);

            // Check if we have enough data
            if (filteredData.length < 3) {
                console.log('⚠️  Not enough data points in window:', filteredData.length);
                
                // FALLBACK: If we're in live mode but have no data in the current window,
                // it means the backend hasn't saved new data recently.
                // Show the most recent data aligned to the right edge of the window.
                if (usingGranularData && scrollPos >= 100 && activeDataset.length >= 3) {
                    console.log('📊 Fallback: Aligning most recent data to right edge of window');
                    
                    // Calculate window duration
                    const windowDurationMs = endTime.getTime() - cutoffTime.getTime();
                    const windowDurationSeconds = windowDurationMs / 1000;
                    
                    // Find the most recent data point
                    const latestDataPoint = activeDataset[activeDataset.length - 1];
                    const latestTimestamp = latestDataPoint.timestamp.getTime();
                    
                    // Calculate how much data we need (window duration)
                    // Get data points that fit within the window duration, ending at the latest data point
                    const windowStartTime = latestTimestamp - windowDurationMs;
                    
                    // Filter data to fit within the window duration, ending at latest data point
                    filteredData = activeDataset.filter(d => {
                        const dTime = d.timestamp.getTime();
                        return dTime >= windowStartTime && dTime <= latestTimestamp;
                    });
                    
                    // If we don't have enough data to fill the window, take the most recent data we have
                    if (filteredData.length < 3) {
                        // Calculate expected candles based on timeframe duration and candle size
                        // For aggregated data, we need fewer candles (e.g., 30s candles for 1h = 120 candles)
                        const candleSizeSeconds = config.candleSize || 1; // Default to 1-second if not specified
                        const expectedCandles = Math.min((config.minutes * 60) / candleSizeSeconds, 300);
                        filteredData = activeDataset.slice(-Math.ceil(expectedCandles));
                    }
                    
                    // The gap between latestTimestamp and endTime will create a visible gap on the right
                    // This gap grows each second as endTime advances, showing the window is moving
                    const gapSeconds = (endTime.getTime() - latestTimestamp) / 1000;
                    console.log(`📊 Using ${filteredData.length} candles ending at ${new Date(latestTimestamp).toISOString()}`);
                    console.log(`📊 Gap to window end: ${gapSeconds.toFixed(1)} seconds (window moves forward)`);
                } else {
                    return {
                        labels: [],
                        path: '',
                        dataPoints: [],
                        count: filteredData.length,
                        error: 'Not enough data - need at least 3 data points'
                    };
                }
            }

            // Sort by timestamp (oldest first for left-to-right chart)
            filteredData.sort((a, b) => a.timestamp - b.timestamp);

            const firstPoint = filteredData[0];
            const lastPoint = filteredData[filteredData.length - 1];
            console.log(`📊 Displaying ${filteredData.length} candles:`);
            console.log(`   First: ${firstPoint.timestamp.toISOString()} (price: $${firstPoint.price})`);
            console.log(`   Last:  ${lastPoint.timestamp.toISOString()} (price: $${lastPoint.price})`);
            
            // Calculate time span
            const timeSpanSeconds = (lastPoint.timestamp - firstPoint.timestamp) / 1000;
            console.log(`   Span:  ${timeSpanSeconds} seconds (${(timeSpanSeconds / 60).toFixed(1)} minutes)`);

            // Detect market gaps (periods longer than 1 hour between data points)
            const gaps = [];
            for (let i = 1; i < filteredData.length; i++) {
                const timeDiff = (filteredData[i].timestamp - filteredData[i - 1].timestamp) / (1000 * 60); // minutes
                if (timeDiff > 60) { // Gap longer than 1 hour indicates market close
                    gaps.push({
                        index: i,
                        duration: timeDiff,
                        start: filteredData[i - 1].timestamp,
                        end: filteredData[i].timestamp
                    });
                    console.log(`📊 Detected market gap: ${Math.round(timeDiff / 60)}h between ${filteredData[i - 1].timestamp.toLocaleString()} and ${filteredData[i].timestamp.toLocaleString()}`);
                }
            }

            // Use ALL data points for the chart path (smooth line)
            // Add 2% margin on each side to prevent edge clipping
            const allPoints = filteredData.map((d, index) => ({
                x: 2 + (index / (filteredData.length - 1)) * 96,
                sentiment: d.sentiment,
                price: d.price,
                open: d.open,
                high: d.high,
                low: d.low,
                volume: d.volume,
                news: d.news,
                indicators: d.indicators,
                timestamp: d.timestamp,
                timeLabel: d.timestamp.toLocaleTimeString('en-US', {
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                })
            }));

            // Select evenly spaced points for X-axis labels
            const labelIndices = [];
            const step = (filteredData.length - 1) / (config.labelCount - 1);
            for (let i = 0; i < config.labelCount; i++) {
                const index = Math.round(i * step);
                labelIndices.push(Math.min(index, filteredData.length - 1));
            }

            // Helper function to format timestamp with timezone support
            const formatTimestampLabel = (timestamp) => {
                let displayTime = timestamp;

                // Apply timezone offset if selected
                if (currentTimezoneData) {
                    const offsetHours = parseOffset(currentTimezoneData.offset);
                    const utc = timestamp.getTime() + (timestamp.getTimezoneOffset() * 60000);
                    displayTime = new Date(utc + (3600000 * offsetHours));
                }

                return displayTime.toLocaleTimeString('en-US', {
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                });
            };

            // Generate labels from selected indices
            const labels = [];
            labelIndices.forEach(index => {
                const point = filteredData[index];
                labels.push(formatTimestampLabel(point.timestamp));
            });

            console.log('✓ Generated', allPoints.length, 'data points for path,', labels.length, 'labels for X-axis');

            // Generate smooth path using ALL data points
            const path = createSmoothPath(allPoints);

            // Calculate min/max price from FULL day's data for consistent scaling
            // This prevents Y-axis from changing as you scroll
            const fullDayPrices = fullTimeframeData.filter(d => d.price != null && !isNaN(d.price)).map(d => d.price);
            const minPrice = fullDayPrices.length > 0 ? Math.min(...fullDayPrices) : 0;
            const maxPrice = fullDayPrices.length > 0 ? Math.max(...fullDayPrices) : 0;

            console.log(`📊 Full day price range: $${minPrice.toFixed(2)} to $${maxPrice.toFixed(2)}`);

            // priceRange was already calculated above from fullTimeframeData

            return {
                labels,
                path,
                dataPoints: allPoints,
                gaps: gaps,
                count: allPoints.length,
                timeRange: `${config.label} (${allPoints.length} points)`,
                minPrice,
                maxPrice,
                priceRange,
                fullTimeframeData: fullTimeframeData.map((d, index) => ({
                    x: 2 + (index / (fullTimeframeData.length - 1)) * 96,
                    sentiment: d.sentiment,
                    price: d.price,
                    news: d.news,
                    indicators: d.indicators,
                    timestamp: d.timestamp
                }))
            };
        }
        
        async function updateChart(timeframe) {
            try {
                console.log('=== UPDATE CHART START ===');
                console.log('Timeframe:', timeframe);

                // Get data for the selected timeframe with current scroll position
                const data = getDataForTimeframe(timeframe, scrollPosition);

                console.log('Chart update - timeframe:', timeframe, 'data points:', data.count || 0);

                // Handle "not enough data" case
                if (data.error) {
                    console.warn(data.error);
                    chartPath.setAttribute('d', '');
                    const dotsContainer = document.getElementById('chart-dots');
                    if (dotsContainer) dotsContainer.innerHTML = '';
                    xAxisLabels.innerHTML = `<span style="color: #ef4444; font-weight: 600;">⚠️ Not Enough Data</span>
                                            <span style="color: #888; margin-left: 10px; font-size: 12px;">(${data.count} point${data.count !== 1 ? 's' : ''} - need at least 3)</span>`;
                    return;
                }

                if (!data.path || data.path === '' || !data.dataPoints || data.dataPoints.length === 0) {
                    console.warn('No data to display');
                    chartPath.setAttribute('d', '');
                    xAxisLabels.innerHTML = '<span style="color: #666;">No data available - waiting for analysis to run...</span>';
                    return;
                }

                // Update X-axis labels (without data count - moved to header)
                if (data.labels && data.labels.length > 0) {
                    const labelsHtml = data.labels.map(label =>
                        `<span>${label}</span>`
                    ).join('');

                    xAxisLabels.innerHTML = labelsHtml;
                } else {
                    xAxisLabels.innerHTML = '<span>Loading...</span>';
                }

                // Hide the original curved path (we're using the new smooth line with dots instead)
                // console.log('Setting chart path:', data.path);
                chartPath.setAttribute('d', '');  // Clear the old path

                // Verify path was cleared
                // const verifyPath = chartPath.getAttribute('d');
                // console.log('Path verification:', verifyPath);

                // Draw chart based on chart type
                if (chartType === 'candlestick') {
                    drawCandlesticks(data.dataPoints, data.minPrice, data.maxPrice, data.priceRange);
                    // Draw volume chart for candlestick view
                    drawVolumeChart(data.dataPoints);
                } else {
                    drawDataPointDots(data.dataPoints, data.minPrice, data.maxPrice, data.priceRange);
                }

                // Draw market gap lines
                drawMarketGapLines(data.gaps || [], data.dataPoints);

                // Calculate and attach signal values if signal mode is active
                const signalModeActive = document.getElementById('signal-mode-toggle')?.classList.contains('active') || false;
                if (signalModeActive) {
                    const fullData = data.fullTimeframeData || data.dataPoints;
                    const signalValues = calculateSignalOscillator(fullData);
                    const signalValuesMap = new Map();
                    fullData.forEach((point, i) => {
                        if (point.timestamp) {
                            signalValuesMap.set(point.timestamp.getTime(), signalValues[i] || 0);
                        }
                    });
                    // Attach signal values to visible data points
                    data.dataPoints.forEach(p => {
                        if (p.timestamp) {
                            p.signalValue = signalValuesMap.get(p.timestamp.getTime()) || 0;
                        }
                    });
                }

                // Draw sentiment line in oscillator chart
                drawSentimentOscillator(data.dataPoints, data.fullTimeframeData);

                // Store current data points for hover functionality
                window.currentChartData = data.dataPoints;
                window.currentFullTimeframeData = data.fullTimeframeData;

                console.log('=== UPDATE CHART COMPLETE ===');
            } catch (error) {
                console.error('Error updating chart:', error);
                console.error('Stack trace:', error.stack);
            }
        }
        
        // Draw data point dots and connecting lines for better visibility
        function drawDataPointDots(dataPoints, minPrice, maxPrice, priceRange) {
            const dotsContainer = document.getElementById('chart-dots');
            if (!dotsContainer) return;

            // Clear existing dots
            dotsContainer.innerHTML = '';

            if (!dataPoints || dataPoints.length === 0) return;

            // Filter out points without price data
            const pricePoints = dataPoints.filter(p => p.price != null && !isNaN(p.price));

            if (pricePoints.length === 0) {
                console.warn('No Nasdaq price data available');
                return;
            }

            // Use priceRange if provided, otherwise calculate from current window
            let actualPriceRange = priceRange;
            if (!actualPriceRange) {
                const prices = pricePoints.map(p => p.price);
                actualPriceRange = {
                    min: Math.min(...prices),
                    max: Math.max(...prices)
                };
            }

            // DYNAMIC SCALE: Map price to Y coordinate (no padding for accurate scaling)
            const priceToY = (price) => {
                const range = actualPriceRange.max - actualPriceRange.min;
                if (range === 0) return 50;

                // Map to 0-100 (inverted Y axis) - no padding
                const y = ((actualPriceRange.max - price) / range) * 100;
                return Math.max(0, Math.min(100, y));
            };

            // Store for tooltip
            window.nasdaqPriceScale = actualPriceRange;

            // Create smooth path connecting all price points
            if (pricePoints.length > 1) {
                let pathD = `M ${pricePoints[0].x},${priceToY(pricePoints[0].price)}`;

                for (let i = 1; i < pricePoints.length; i++) {
                    const x = pricePoints[i].x;
                    const y = priceToY(pricePoints[i].price);

                    if (i === 1 && pricePoints.length === 2) {
                        // For just 2 points, draw a straight line
                        pathD += ` L ${x},${y}`;
                    } else {
                        // Use quadratic bezier for smooth curves
                        const prevX = pricePoints[i - 1].x;
                        const prevY = priceToY(pricePoints[i - 1].price);
                        const cpX = (prevX + x) / 2;
                        const cpY = (prevY + y) / 2;
                        pathD += ` Q ${cpX},${cpY} ${x},${y}`;
                    }
                }

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathD);
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', '#ffffff');
                path.setAttribute('stroke-width', '0.25');
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('stroke-linejoin', 'round');
                path.setAttribute('opacity', '0.9');
                dotsContainer.appendChild(path);
            }

            console.log(`Drew Nasdaq price line with ${pricePoints.length} data points`);
        }

        // Draw candlesticks for OHLC data (Heikin-Ashi style)
        function drawCandlesticks(dataPoints, minPrice, maxPrice, priceRange) {
            const dotsContainer = document.getElementById('chart-dots');
            if (!dotsContainer) return;

            // Clear existing content
            dotsContainer.innerHTML = '';

            if (!dataPoints || dataPoints.length === 0) return;

            // Filter out points without OHLC data
            const candlePoints = dataPoints.filter(p => 
                p.open != null && !isNaN(p.open) &&
                p.high != null && !isNaN(p.high) &&
                p.low != null && !isNaN(p.low) &&
                p.price != null && !isNaN(p.price) // price is close
            );

            if (candlePoints.length === 0) {
                console.warn('No OHLC data available for candlesticks');
                return;
            }

            // Calculate Heikin-Ashi values
            const heikinAshiCandles = [];
            let prevHAOpen = candlePoints[0].open;
            let prevHAClose = candlePoints[0].price;

            candlePoints.forEach((point, index) => {
                const close = point.price;
                const open = point.open;
                const high = point.high;
                const low = point.low;

                // Heikin-Ashi calculations
                const haClose = (open + high + low + close) / 4;
                const haOpen = index === 0 ? open : (prevHAOpen + prevHAClose) / 2;
                const haHigh = Math.max(high, haOpen, haClose);
                const haLow = Math.min(low, haOpen, haClose);

                heikinAshiCandles.push({
                    ...point,
                    haOpen,
                    haHigh,
                    haLow,
                    haClose,
                    isBullish: haClose >= haOpen
                });

                prevHAOpen = haOpen;
                prevHAClose = haClose;
            });

            // Use heikinAshiCandles instead of regular candles
            const displayCandles = heikinAshiCandles;

            // Use VISIBLE candles' price range for better proportions (not full day range)
            // This prevents vertical compression - use HA values for range
            const allPrices = [];
            displayCandles.forEach(p => {
                allPrices.push(p.haOpen, p.haHigh, p.haLow, p.haClose);
            });
            const visibleMin = Math.min(...allPrices);
            const visibleMax = Math.max(...allPrices);
            
            // Add 5% padding top and bottom to prevent candles from being cut off
            const visibleRange = visibleMax - visibleMin;
            const padding = visibleRange * 0.05;
            const actualPriceRange = {
                min: visibleMin - padding,
                max: visibleMax + padding
            };

            // Map price to Y coordinate with proper scaling
            const priceToY = (price) => {
                const range = actualPriceRange.max - actualPriceRange.min;
                if (range === 0) return 50;
                const y = ((actualPriceRange.max - price) / range) * 100;
                return Math.max(0, Math.min(100, y));
            };

            // Store for tooltip
            window.nasdaqPriceScale = actualPriceRange;

            // Industry-standard candlestick proportions (TradingView style)
            // Candles should fill 65% of space, with 35% gap between them
            // Use 96 instead of 100 because candles span from x=2 to x=98
            const spacePerCandle = 96 / displayCandles.length;
            // Cap at 4 to prevent overflow on small datasets, but allow to be thin on large datasets
            const candleWidth = Math.max(spacePerCandle * 0.65, 0.5); 
            
            // Wick should be about 1/8th the width of candle body for clean look, but visible
            // Ensure wick is always visible (at least 0.5px width equivalent)
            const wickWidth = Math.max(0.05, candleWidth * 0.125);

            // Draw each Heikin-Ashi candlestick
            displayCandles.forEach(point => {
                const x = point.x;
                
                // Use Heikin-Ashi values
                const open = point.haOpen;
                const high = point.haHigh;
                const low = point.haLow;
                const close = point.haClose;
                const isBullish = point.isBullish;

                const openY = priceToY(open);
                const highY = priceToY(high);
                const lowY = priceToY(low);
                const closeY = priceToY(close);
                
                // Color scheme: white for bullish, blue for bearish
                const candleColor = isBullish ? '#ffffff' : '#3b82f6';

                // Draw wick (high to low)
                const wick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                wick.setAttribute('x1', x);
                wick.setAttribute('y1', highY);
                wick.setAttribute('x2', x);
                wick.setAttribute('y2', lowY);
                wick.setAttribute('stroke', candleColor);
                wick.setAttribute('stroke-width', wickWidth);
                wick.setAttribute('opacity', '0.9');
                dotsContainer.appendChild(wick);

                // Draw body (open to close)
                const bodyTop = Math.min(openY, closeY);
                const bodyHeight = Math.abs(openY - closeY);
                
                // Minimum body height for doji candles - should be visible as a line
                // Scale with candle width for consistency
                const minBodyHeight = wickWidth * 1.5;
                const displayBodyHeight = Math.max(bodyHeight, minBodyHeight);

                const body = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                body.setAttribute('x', x - candleWidth / 2);
                body.setAttribute('y', bodyTop);
                body.setAttribute('width', candleWidth);
                body.setAttribute('height', displayBodyHeight);
                body.setAttribute('fill', candleColor);
                body.setAttribute('opacity', '0.95');
                dotsContainer.appendChild(body);
            });

            console.log(`Drew ${displayCandles.length} Heikin-Ashi candlesticks`);
        }

        // Draw volume bars
        function drawVolumeChart(dataPoints) {
            const volumeBarsContainer = document.getElementById('volume-bars');
            if (!volumeBarsContainer) return;

            // Clear existing volume bars
            volumeBarsContainer.innerHTML = '';

            if (!dataPoints || dataPoints.length === 0) return;

            // Filter points with volume data
            const volumePoints = dataPoints.filter(p => p.volume != null && !isNaN(p.volume));

            if (volumePoints.length === 0) {
                console.warn('No volume data available');
                return;
            }

            // Find max volume for scaling
            const maxVolume = Math.max(...volumePoints.map(p => p.volume));
            if (maxVolume === 0) return;

            // Calculate bar width (same as candles)
            // Use 96 instead of 100 because bars span from x=2 to x=98
            const spacePerBar = 96 / volumePoints.length;
            // Cap at 4 to prevent overflow, but ensure visibility on large datasets
            const barWidth = Math.max(spacePerBar * 0.65, 0.5); 

            // Draw each volume bar
            volumePoints.forEach(point => {
                const x = point.x;
                const volume = point.volume;
                
                // Calculate bar height (volume as % of max)
                const heightPercent = (volume / maxVolume) * 100;
                // Minimum height for visibility
                const barHeight = Math.max(heightPercent, 0.5);
                const barY = 100 - barHeight; // Start from bottom

                // Determine color: green for bullish (close > open), red for bearish
                let barColor;
                if (point.haClose !== undefined && point.haOpen !== undefined) {
                    // Use Heikin-Ashi values if available
                    barColor = point.haClose >= point.haOpen ? '#10b981' : '#ef4444';
                } else if (point.price !== undefined && point.open !== undefined) {
                    // Fall back to regular OHLC
                    barColor = point.price >= point.open ? '#10b981' : '#ef4444';
                } else {
                    barColor = '#888'; // Neutral if can't determine
                }

                // Draw bar
                const bar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                bar.setAttribute('x', x - barWidth / 2);
                bar.setAttribute('y', barY);
                bar.setAttribute('width', barWidth);
                bar.setAttribute('height', barHeight);
                bar.setAttribute('fill', barColor);
                // Increased opacity for better visibility, matching the requested style
                bar.setAttribute('opacity', '0.9'); 
                volumeBarsContainer.appendChild(bar);
            });

            console.log(`Drew ${volumePoints.length} volume bars`);
        }

        // Draw vertical dotted lines for market gaps
        function drawMarketGapLines(gaps, dataPoints) {
            // Remove existing gap lines
            const existingLines = document.querySelectorAll('.market-gap-line');
            existingLines.forEach(line => line.remove());

            if (!gaps || gaps.length === 0 || !dataPoints || dataPoints.length === 0) {
                return;
            }

            const chartContainer = document.getElementById('chart-container');
            if (!chartContainer) return;

            // Draw a vertical line at each gap
            gaps.forEach(gap => {
                // Find the x position for this gap (at the start of the gap index)
                const xPercent = (gap.index / (dataPoints.length - 1)) * 100;

                // Create the gap line element
                const gapLine = document.createElement('div');
                gapLine.className = 'market-gap-line';
                gapLine.style.left = `calc(50px + (100% - 70px) * ${xPercent / 100})`;

                chartContainer.appendChild(gapLine);

                console.log(`📊 Drew market gap line at ${xPercent.toFixed(1)}% (${Math.round(gap.duration / 60)}h gap)`);
            });
        }

        // Update Y-axis labels for price range
        function updateYAxisLabels(dataPoints, minPrice, maxPrice, priceRange) {
            const yAxis = document.querySelector('.y-axis');
            if (!yAxis) return;

            // Use priceRange if provided
            let actualPriceRange = priceRange;
            if (!actualPriceRange) {
                const prices = dataPoints.filter(p => p.price != null).map(p => p.price);
                if (prices.length === 0) return;
                actualPriceRange = {
                    min: Math.min(...prices),
                    max: Math.max(...prices)
                };
            }

            // DYNAMIC SCALE: Show actual price range with padding
            const range = actualPriceRange.max - actualPriceRange.min;
            const padding = range * 0.1;
            const paddedMin = actualPriceRange.min - padding;
            const paddedMax = actualPriceRange.max + padding;

            // Calculate 5 evenly spaced labels
            const step = (paddedMax - paddedMin) / 4;
            const labels = [];
            for (let i = 4; i >= 0; i--) {
                const value = paddedMin + (step * i);
                labels.push(`<span class="y-axis-label">$${value.toFixed(0)}</span>`);
            }

            yAxis.innerHTML = labels.join('');
        }

        // Calculate signal-based oscillator values from historical data
        // Returns array with +100 (News UP active), -100 (Technical DOWN active), or 0 (no signal)
        function calculateSignalOscillator(dataPoints) {
            if (!dataPoints || dataPoints.length === 0) return [];

            const signalValues = [];
            let activeSignal = null; // { type: 'news_up' | 'technical_down', value: 100 | -100, expiresAt: timestamp }

            for (let i = 0; i < dataPoints.length; i++) {
                const current = dataPoints[i];
                const previous = i > 0 ? dataPoints[i - 1] : null;

                // Check if current active signal has expired
                if (activeSignal && current.timestamp >= activeSignal.expiresAt) {
                    activeSignal = null; // Signal expired
                }

                let newSignal = null;

                // Detect News UP signal (news score increases by ≥5)
                if (previous && current.news != null && previous.news != null) {
                    const newsChange = current.news - previous.news;
                    if (newsChange >= 5) {
                        newSignal = {
                            type: 'news_up',
                            value: 100,
                            expiresAt: new Date(current.timestamp.getTime() + 15 * 60 * 1000) // 15 minutes
                        };
                    }
                }

                // Detect Technical DOWN signal (technical score decreases by ≥5)
                if (previous && current.indicators != null && previous.indicators != null) {
                    const technicalChange = current.indicators - previous.indicators;
                    if (technicalChange <= -5) {
                        const technicalSignal = {
                            type: 'technical_down',
                            value: -100,
                            expiresAt: new Date(current.timestamp.getTime() + 5 * 60 * 1000) // 5 minutes
                        };

                        // If both signals trigger at same timestamp, News UP wins
                        if (newSignal && newSignal.type === 'news_up') {
                            // Keep news signal, ignore technical
                        } else {
                            newSignal = technicalSignal;
                        }
                    }
                }

                // Most recent signal wins (overrides previous)
                if (newSignal) {
                    activeSignal = newSignal;
                }

                // Store the current signal value for this data point
                signalValues.push(activeSignal ? activeSignal.value : 0);
            }

            return signalValues;
        }

        // Draw sentiment line in oscillator chart with optional driver overlays
        function drawSentimentOscillator(dataPoints, fullTimeframeData) {
            const oscillatorDiv = document.getElementById('chart-oscillator');
            if (!oscillatorDiv) {
                console.error('❌ chart-oscillator container not found');
                return;
            }

            // Clear existing content
            oscillatorDiv.innerHTML = '';

            if (!dataPoints || dataPoints.length === 0) {
                console.warn('⚠️ No dataPoints provided for oscillator');
                return;
            }

            // Create SVG container for oscillator
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 100 100');
            svg.setAttribute('preserveAspectRatio', 'none');
            svg.style.width = '100%';
            svg.style.height = '100%';

            // Determine scale mode
            const scaleMode = document.querySelector('input[name="oscillator-scale"]:checked')?.value || 'visible';

            // Calculate min/max range based on scale mode
            let minValue, maxValue;

            if (scaleMode === 'fixed') {
                // Mode 1: Fixed -100 to +100
                minValue = -100;
                maxValue = 100;
            } else {
                // Collect all values from enabled drivers
                const driverKeys = ['sentiment', 'news', 'indicators'];
                const allValues = [];

                // Determine which dataset to use
                const datasetToUse = scaleMode === 'visible' ? dataPoints : (fullTimeframeData || dataPoints);

                driverKeys.forEach(key => {
                    const eyeBtn = document.getElementById(`eye-${key}`);
                    const shouldInclude = !eyeBtn || eyeBtn.classList.contains('active');

                    if (shouldInclude) {
                        datasetToUse.forEach(point => {
                            if (point[key] != null && !isNaN(point[key])) {
                                allValues.push(point[key]);
                            }
                        });
                    }
                });

                if (allValues.length > 0) {
                    minValue = Math.min(...allValues);
                    maxValue = Math.max(...allValues);
                } else {
                    // Fallback to fixed scale
                    minValue = -100;
                    maxValue = 100;
                }
            }

            // Update Y-axis labels
            const yAxisDiv = document.getElementById('oscillator-y-axis');
            if (yAxisDiv) {
                // Display: max at top, 0 in middle, min at bottom
                const formatValue = (val) => {
                    if (val === 0) return '0';
                    return val > 0 ? `+${val.toFixed(0)}` : val.toFixed(0);
                };

                yAxisDiv.innerHTML = `
                    <span>${formatValue(maxValue)}</span>
                    <span>0</span>
                    <span>${formatValue(minValue)}</span>
                `;
            }

            // Create value to Y mapping function with padding to keep lines visible
            // Midpoint of range is at Y=50 (visual center)
            const valueToY = (value) => {
                const range = maxValue - minValue;
                if (range === 0) return 50;

                const midpoint = (minValue + maxValue) / 2;
                // Add 5% padding on top and bottom so extreme values are visible
                // Map to Y range [5, 95] instead of [0, 100]
                const y = 50 - ((value - midpoint) / range) * 90;
                return Math.max(5, Math.min(95, y));
            };

            // Draw center line at value = 0 (may be off-screen if range doesn't include 0)
            const zeroY = valueToY(0);
            if (zeroY >= 0 && zeroY <= 100) {
                const centerLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                centerLine.setAttribute('x1', '2');
                centerLine.setAttribute('y1', zeroY.toString());
                centerLine.setAttribute('x2', '98');
                centerLine.setAttribute('y2', zeroY.toString());
                centerLine.setAttribute('stroke', 'rgba(136, 136, 136, 0.5)');
                centerLine.setAttribute('stroke-width', '1.0');
                centerLine.setAttribute('stroke-dasharray', '2,2');
                svg.appendChild(centerLine);
            }

            // Check if signal mode is active
            const signalModeActive = document.getElementById('signal-mode-toggle')?.classList.contains('active') || false;

            // Calculate signal values if in signal mode
            let signalValuesMap = new Map();
            if (signalModeActive) {
                const fullData = fullTimeframeData || dataPoints;
                const signalValues = calculateSignalOscillator(fullData);

                // Create a map of timestamp -> signal value for accurate matching
                fullData.forEach((point, i) => {
                    if (point.timestamp) {
                        signalValuesMap.set(point.timestamp.getTime(), signalValues[i] || 0);
                    }
                });
            }

            // Define which drivers to plot and their colors
            // Only include drivers that have historical data from the API
            const driverConfig = [
                { key: 'sentiment', color: '#ff8c42', label: 'Composite', eyeBtn: document.getElementById('eye-sentiment') }, // Orange - toggleable
                { key: 'news', color: '#ec4899', label: 'News', eyeBtn: document.getElementById('eye-news') }, // Pink
                { key: 'indicators', color: '#3b82f6', label: 'Indicators', eyeBtn: document.getElementById('eye-indicators') } // Blue
            ];

            // Draw each enabled driver
            driverConfig.forEach(driver => {
                // Check if this driver should be displayed (check eye button active state)
                const shouldDisplay = !driver.eyeBtn || driver.eyeBtn.classList.contains('active');
                if (!shouldDisplay) return;

                // For sentiment line in signal mode, use calculated signal values
                let points;
                if (driver.key === 'sentiment' && signalModeActive) {
                    // Map signal values to visible data points using timestamp matching
                    points = dataPoints.map(p => ({
                        ...p,
                        signalValue: p.timestamp ? signalValuesMap.get(p.timestamp.getTime()) || 0 : 0
                    })).filter(p => p.signalValue != null);
                } else {
                    // Filter points that have this driver data
                    points = dataPoints.filter(p => p[driver.key] != null && !isNaN(p[driver.key]));
                }

                if (points.length === 0) {
                    console.warn(`❌ No ${driver.label} data available`);
                    return;
                }

                // Create smooth path
                if (points.length > 1) {
                    // Helper to get value (use signalValue in signal mode for sentiment)
                    const getValue = (point) => {
                        return (driver.key === 'sentiment' && signalModeActive) ? point.signalValue : point[driver.key];
                    };

                    let pathD = `M ${points[0].x},${valueToY(getValue(points[0]))}`;

                    for (let i = 1; i < points.length; i++) {
                        const x = points[i].x;
                        const y = valueToY(getValue(points[i]));

                        if (i === 1 && points.length === 2) {
                            pathD += ` L ${x},${y}`;
                        } else {
                            const prevX = points[i - 1].x;
                            const prevY = valueToY(getValue(points[i - 1]));
                            const cpX = (prevX + x) / 2;
                            const cpY = (prevY + y) / 2;
                            pathD += ` Q ${cpX},${cpY} ${x},${y}`;
                        }
                    }

                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('d', pathD);
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke', driver.color);
                    // Use 0.3 width for sentiment line in signal mode, 0.08 otherwise
                    const strokeWidth = (driver.key === 'sentiment' && signalModeActive) ? '0.3' : '0.08';
                    path.setAttribute('stroke-width', strokeWidth);
                    path.setAttribute('stroke-linecap', 'round');
                    path.setAttribute('stroke-linejoin', 'round');
                    path.setAttribute('opacity', '0.9');
                    path.classList.add(`oscillator-line-${driver.key}`);
                    svg.appendChild(path);

                    console.log(`✅ Drew ${driver.label} line with ${points.length} points`);
                }
            });

            oscillatorDiv.appendChild(svg);
        }

        // Nasdaq price overlay toggle state - DEFAULT TO TRUE so line shows immediately
        window.nasdaqPriceEnabled = true;

        // Checkbox toggle handler
        const priceToggleCheckbox = document.getElementById('price-toggle');
        if (priceToggleCheckbox) {
            priceToggleCheckbox.checked = true;
            priceToggleCheckbox.addEventListener('change', async () => {
                window.nasdaqPriceEnabled = !!priceToggleCheckbox.checked;
                console.log(`☑️ Show Nasdaq: ${window.nasdaqPriceEnabled}`);
                await updateChart(currentTimeframe);
            });
        }

        // Chart type toggle button
        const chartTypeToggle = document.getElementById('chart-type-toggle');
        const lineIcon = document.getElementById('line-icon');
        const candleIcon = document.getElementById('candle-icon');
        
        if (chartTypeToggle) {
            chartTypeToggle.addEventListener('click', async () => {
                // Toggle chart type
                if (chartType === 'candlestick') {
                    chartType = 'line';
                    lineIcon.style.display = 'none';
                    candleIcon.style.display = 'block';
                } else {
                    chartType = 'candlestick';
                    lineIcon.style.display = 'block';
                    candleIcon.style.display = 'none';
                }
                
                console.log('Chart type changed to:', chartType);
                await updateChart(currentTimeframe);
            });
        }

        // Granular data toggle (Second/Tick)
        const granularToggle = document.getElementById('granular-toggle');
        const granularBtns = document.querySelectorAll('.granular-btn');
        
        granularBtns.forEach(btn => {
            btn.addEventListener('click', async () => {
                const newType = btn.dataset.type;
                if (newType === granularDataType) return; // Already selected
                
                const previousType = granularDataType;
                granularDataType = newType;
                console.log(`📊 Switched from ${previousType} to ${granularDataType} candles`);
                
                // Update button states
                granularBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // Fetch granular data if not already loaded
                const config = timeframeConfig[currentTimeframe];
                if (config && config.supportsGranular) {
                    console.log(`🔄 Fetching ${granularDataType} candles data...`);
                    
                    // Always fetch when switching to ensure we have fresh data
                    if (granularDataType === 'second') {
                        if (secondCandlesDataset.length === 0) {
                            await fetchSecondCandles();
                        }
                    } else if (granularDataType === 'tick') {
                        if (tickCandlesDataset.length === 0) {
                            await fetchTickCandles();
                        }
                    }
                    
                    // Restart auto-refresh for the new granular data type
                    stopGranularRefresh();
                    startGranularRefresh();
                    
                    // Update chart with new data type
                    await updateChart(currentTimeframe);
                }
            });
        });
        
        // Function to update granular toggle visibility
        function updateGranularToggleVisibility() {
            const config = timeframeConfig[currentTimeframe];
            if (granularToggle && config) {
                if (config.supportsGranular) {
                    granularToggle.style.display = 'flex';
                } else {
                    granularToggle.style.display = 'none';
                }
            }
        }

        timeframeBtns.forEach(btn => {
            btn.addEventListener('click', async () => {
                timeframeBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                const timeframe = btn.dataset.timeframe;
                currentTimeframe = timeframe;

                // Reset scroll position to rightmost (most recent data)
                scrollPosition = 100;
                const scrollbar = document.getElementById('chart-scrollbar');
                if (scrollbar) scrollbar.value = '100';
                
                // Update granular toggle visibility
                updateGranularToggleVisibility();
                
                // Automatically fetch granular data for granular-capable timeframes
                const config = timeframeConfig[timeframe];
                if (config && config.supportsGranular) {
                    console.log(`📊 Granular timeframe selected, fetching ${granularDataType} candles...`);
                    
                    // Fetch the appropriate granular data based on toggle selection
                    // ALWAYS fetch fresh data when switching tabs to ensure the chart updates immediately
                    // instead of relying on cached data which might be stale or empty
                    if (granularDataType === 'second') {
                         // Reset dataset to force refresh or just call fetch directly
                         await fetchSecondCandles();
                    } else if (granularDataType === 'tick') {
                         await fetchTickCandles();
                    }
                    
                    // Start granular auto-refresh (1 second)
                    startGranularRefresh();
                } else {
                    // Stop granular refresh if switching away from granular-capable timeframes
                    stopGranularRefresh();
                }

                await updateChart(timeframe);
                currentTimeframe = timeframe; // Update current timeframe for hover
            });
        });

        // Scrollbar event listener
        const chartScrollbar = document.getElementById('chart-scrollbar');
        if (chartScrollbar) {
            chartScrollbar.addEventListener('input', async (e) => {
                scrollPosition = parseInt(e.target.value);
                console.log('Scroll position changed to:', scrollPosition);
                await updateChart(currentTimeframe);
            });
        }
        
        // Initialize the dashboard
        async function initializeDashboard() {
            try {
                console.log('Initializing NASDAQ Sentiment Dashboard...');
                console.log('Current time:', new Date().toISOString());

                // Fetch dashboard data (composite score + drivers)
                const dashboardData = await fetchDashboardData();
                if (dashboardData) {
                    console.log('Dashboard data loaded - Composite score:', dashboardData.composite_score);
                    console.log('Drivers:', dashboardData.drivers);
                }

                // Initialize chart with default timeframe (6h = Session)
                currentTimeframe = '6h';
                
                // Set initial granular toggle visibility
                updateGranularToggleVisibility();
                
                await updateChart(currentTimeframe);

                // Function to toggle eye icon state and update visibility
                function toggleEyeIcon(eyeBtn, isActive) {
                    const openEye = eyeBtn.querySelector('.eye-open');
                    const closedEye = eyeBtn.querySelector('.eye-closed');
                    
                    if (isActive) {
                        eyeBtn.classList.add('active');
                        if (openEye) openEye.style.display = 'block';
                        if (closedEye) closedEye.style.display = 'none';
                    } else {
                        eyeBtn.classList.remove('active');
                        if (openEye) openEye.style.display = 'none';
                        if (closedEye) closedEye.style.display = 'block';
                    }
                }

                // Function to handle eye icon clicks with mutual exclusivity
                function handleEyeClick(clickedBtn, lineType) {
                    const allEyeBtns = {
                        sentiment: document.getElementById('eye-sentiment'),
                        news: document.getElementById('eye-news'),
                        indicators: document.getElementById('eye-indicators')
                    };

                    const isCurrentlyActive = clickedBtn.classList.contains('active');

                    // If clicking an active button, close it (toggle off)
                    if (isCurrentlyActive) {
                        toggleEyeIcon(clickedBtn, false);
                    } else {
                        // Close all other buttons
                        Object.keys(allEyeBtns).forEach(key => {
                            if (key !== lineType && allEyeBtns[key]) {
                                toggleEyeIcon(allEyeBtns[key], false);
                            }
                        });
                        // Open the clicked button
                        toggleEyeIcon(clickedBtn, true);
                    }

                    // Redraw oscillator with current data
                    if (window.currentChartData) {
                        drawSentimentOscillator(window.currentChartData, window.currentFullTimeframeData);
                    }
                }

                // Initialize sentiment score as active (open eye)
                const sentimentEyeBtn = document.getElementById('eye-sentiment');
                if (sentimentEyeBtn) {
                    toggleEyeIcon(sentimentEyeBtn, true);
                }

                // Add event listeners to all eye icon buttons
                const allEyeButtons = [
                    { btn: document.getElementById('eye-sentiment'), line: 'sentiment' },
                    { btn: document.getElementById('eye-news'), line: 'news' },
                    { btn: document.getElementById('eye-indicators'), line: 'indicators' }
                ];

                allEyeButtons.forEach(({ btn, line }) => {
                    if (btn) {
                        btn.addEventListener('click', () => {
                            handleEyeClick(btn, line);
                        });
                    }
                });

                // Add event listeners to scale mode radio buttons
                const scaleRadios = document.querySelectorAll('input[name="oscillator-scale"]');
                scaleRadios.forEach(radio => {
                    radio.addEventListener('change', () => {
                        console.log(`Scale mode changed to: ${radio.value}`);
                        // Redraw oscillator with new scale mode
                        if (window.currentChartData) {
                            drawSentimentOscillator(window.currentChartData, window.currentFullTimeframeData);
                        }
                    });
                });

                // Add event listener for signal mode toggle button
                const signalModeToggle = document.getElementById('signal-mode-toggle');
                if (signalModeToggle) {
                    signalModeToggle.addEventListener('click', () => {
                        signalModeToggle.classList.toggle('active');
                        const isActive = signalModeToggle.classList.contains('active');
                        console.log(`Signal mode ${isActive ? 'enabled' : 'disabled'}`);
                        // Redraw oscillator with signal mode
                        if (window.currentChartData) {
                            drawSentimentOscillator(window.currentChartData, window.currentFullTimeframeData);
                        }
                    });
                }

                console.log('Dashboard initialized successfully');
            } catch (error) {
                console.error('Error initializing dashboard:', error);
                // Show fallback values
                const scoreElement = document.querySelector('.score-value');
                const statusElement = document.querySelector('.score-status');
                if (scoreElement) scoreElement.textContent = '0.0';
                if (statusElement) statusElement.textContent = 'LOADING...';
            }
        }

        // ===== GRANULAR DATA AUTO-REFRESH (dynamic interval based on timeframe) =====

        function startGranularRefresh() {
            // Stop any existing interval
            stopGranularRefresh();

            // Get the update interval for the current timeframe
            const config = timeframeConfig[currentTimeframe];
            const updateInterval = config?.updateInterval || 1000; // Default to 1 second if not specified

            console.log(`🔄 Starting granular data auto-refresh (${updateInterval}ms interval for ${currentTimeframe} timeframe)`);

            granularRefreshInterval = setInterval(async () => {
                console.log(`⏱️ Auto-refresh tick (market: ${isMarketOpen ? 'OPEN' : 'CLOSED'}, scroll: ${scrollPosition}%)`);

                // Only refresh if market is open
                if (!isMarketOpen) {
                    console.log('❌ Market is closed - skipping granular refresh');
                    return;
                }

                // Only auto-update if viewing most recent data
                if (scrollPosition !== 100) {
                    console.log('❌ User viewing historical data - skipping granular refresh');
                    return;
                }

                console.log('✅ Proceeding with data fetch...');

                try {
                    // Store dataset length before fetch
                    const beforeLength = granularDataType === 'second'
                        ? secondCandlesDataset.length
                        : tickCandlesDataset.length;

                    // Fetch incremental updates
                    if (granularDataType === 'second') {
                        await fetchSecondCandles(lastGranularTimestamp);
                    } else {
                        await fetchTickCandles(lastGranularTimestamp);
                    }

                    // Check if dataset actually grew
                    const afterLength = granularDataType === 'second'
                        ? secondCandlesDataset.length
                        : tickCandlesDataset.length;

                    if (afterLength > beforeLength) {
                        console.log(`✅ Dataset grew by ${afterLength - beforeLength} candles (${beforeLength} → ${afterLength})`);
                    } else {
                        console.log(`ℹ️ No new data added (dataset still ${afterLength} candles)`);
                    }

                    // Log the latest timestamp in the dataset
                    const latestCandle = granularDataType === 'second'
                        ? secondCandlesDataset[secondCandlesDataset.length - 1]
                        : tickCandlesDataset[tickCandlesDataset.length - 1];
                    if (latestCandle) {
                        const dataAge = (Date.now() - latestCandle.timestamp.getTime()) / 1000;
                        console.log(`📅 Latest candle in dataset: ${latestCandle.timestamp.toISOString()} (${dataAge.toFixed(0)}s ago)`);

                        // Warn if data is stale (more than 10 seconds old)
                        if (dataAge > 10) {
                            console.warn(`⚠️ DATA IS STALE! Latest data is ${dataAge.toFixed(0)} seconds old. Backend may not be saving new data.`);
                        }
                    }

                    // ALWAYS update chart, even if no new data
                    // This ensures the sliding window moves forward with current time
                    await updateChart(currentTimeframe);

                } catch (error) {
                    console.error('Error in granular auto-refresh:', error);
                }
            }, updateInterval); // Use dynamic interval based on timeframe
        }
        
        function stopGranularRefresh() {
            if (granularRefreshInterval) {
                console.log('⏹️ Stopping granular data auto-refresh');
                clearInterval(granularRefreshInterval);
                granularRefreshInterval = null;
            }
        }

        // Update data periodically (every 60 seconds) - only when market is open
        setInterval(async () => {
            // Only refresh if market is open
            if (!isMarketOpen) {
                console.log('Market is closed - skipping auto-refresh');
                return;
            }

            try {
                console.log('Auto-refreshing dashboard data...');
                await fetchDashboardData();

                // Only auto-update chart if user is viewing the most recent data (scrollPosition = 100)
                // Otherwise, don't interrupt their historical viewing
                if (scrollPosition === 100) {
                    await updateChart(currentTimeframe);
                } else {
                    console.log('User is viewing historical data - skipping chart auto-refresh');
                }
            } catch (error) {
                console.error('Error updating dashboard:', error);
            }
        }, 60000); // Check every 60 seconds

        // Unified chart hover functionality
        const chartsWrapper = document.getElementById('charts-wrapper');
        const chartCanvas = document.getElementById('chart-canvas');
        const oscillatorDiv = document.getElementById('chart-oscillator');
        const unifiedHoverLine = document.getElementById('unified-hover-line');
        const timeLabel = document.getElementById('time-label');
        const mainTooltip = document.getElementById('chart-tooltip');
        const oscillatorTooltip = document.getElementById('oscillator-tooltip');
        const mainTooltipValue = mainTooltip.querySelector('.tooltip-value');
        const mainTooltipTime = mainTooltip.querySelector('.tooltip-time');
        const oscillatorTooltipValue = oscillatorTooltip.querySelector('.tooltip-value');
        const oscillatorTooltipTime = oscillatorTooltip.querySelector('.tooltip-time');

        function interpolateValue(x, dataPoints) {
            if (!dataPoints || dataPoints.length === 0) return { price: null, sentiment: null, time: 'Now', timestamp: new Date() };
            
            // Find the two closest data points
            let before = dataPoints[0];
            let after = dataPoints[dataPoints.length - 1];
            
            for (let i = 0; i < dataPoints.length - 1; i++) {
                if (x >= dataPoints[i].x && x <= dataPoints[i + 1].x) {
                    before = dataPoints[i];
                    after = dataPoints[i + 1];
                    break;
                }
            }
            
            // Linear interpolation for price value
            const ratio = (x - before.x) / (after.x - before.x);
            let price = null;
            if (before.price != null && after.price != null) {
                price = before.price + ratio * (after.price - before.price);
            } else if (before.price != null) {
                price = before.price;
            } else if (after.price != null) {
                price = after.price;
            }

            // Linear interpolation for sentiment (if available)
            let sentiment = null;
            if (before.sentiment != null && after.sentiment != null) {
                sentiment = before.sentiment + ratio * (after.sentiment - before.sentiment);
            } else if (before.sentiment != null) {
                sentiment = before.sentiment;
            } else if (after.sentiment != null) {
                sentiment = after.sentiment;
            }

            // Get signal value if in signal mode (no interpolation for binary values)
            let signalValue = null;
            const closestPoint = ratio < 0.5 ? before : after;
            if (closestPoint.signalValue != null) {
                signalValue = closestPoint.signalValue;
            }

            // Use the closest data point's time
            const time = closestPoint.timeLabel || closestPoint.timestamp?.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            }) || 'N/A';

            return { price: price, sentiment: sentiment, signalValue: signalValue, time: time, timestamp: closestPoint.timestamp };
        }

        // Unified hover handler for both charts
        function handleChartHover(e, isMainChart) {
            // Always use chartCanvas as reference for ALL calculations to ensure perfect alignment
            const chartCanvasRect = chartCanvas.getBoundingClientRect();
            const oscillatorRect = oscillatorDiv.getBoundingClientRect();

            // Calculate mouse X position relative to chartCanvas (unified reference point)
            const mouseX = e.clientX - chartCanvasRect.left;

            // Chart-canvas is already positioned with left: 20px and right: 10%, so it IS the effective chart area
            // No need to subtract offset or use percentage - use the full canvas width
            const effectiveChartWidth = chartCanvasRect.width;

            // Clamp to chart bounds (allow small tolerance for edge cases)
            if (mouseX < -1 || mouseX > effectiveChartWidth + 1) {
                hideAllHoverElements();
                return;
            }
            
            // Clamp mouseX to valid range for calculations
            const clampedMouseX = Math.max(0, Math.min(mouseX, effectiveChartWidth));

            // Calculate position as percentage (0-100) within the effective chart area
            const percentX = (clampedMouseX / effectiveChartWidth) * 100;

            // Use the globally stored current chart data
            if (!window.currentChartData) return;

            // Interpolate the value based on X position
            const result = interpolateValue(percentX, window.currentChartData);

            // Show unified hover line (spans both charts) - position relative to charts-wrapper
            const chartsWrapperRect = chartsWrapper.getBoundingClientRect();
            const chartCanvasOffsetX = chartCanvasRect.left - chartsWrapperRect.left;
            unifiedHoverLine.style.display = 'block';
            unifiedHoverLine.style.left = (clampedMouseX + chartCanvasOffsetX) + 'px';

            // Show time label between charts and oscillator (follows cursor x-position)
            timeLabel.classList.add('show');
            timeLabel.innerHTML = `<strong>${result.time}</strong>`;
            // Position time label to follow cursor x-position (same as hover line)
            const labelWidth = 90;
            const labelXRelativeToCanvas = Math.max(0, Math.min(clampedMouseX - (labelWidth / 2), chartCanvasRect.width - labelWidth));
            const labelX = labelXRelativeToCanvas + chartCanvasOffsetX;
            timeLabel.style.left = labelX + 'px';

            if (isMainChart) {
                // Show main chart tooltip
                mainTooltip.style.display = 'block';
                oscillatorTooltip.style.display = 'none';

                // Display price as main value
                if (result.price != null) {
                    mainTooltipValue.textContent = `$${result.price.toFixed(2)}`;
                } else {
                    mainTooltipValue.textContent = 'N/A';
                }

                // Show sentiment score as secondary info
                const tooltipSentiment = document.getElementById('tooltip-sentiment');
                if (tooltipSentiment) {
                    if (result.sentiment != null) {
                        const sentimentDisplay = result.sentiment > 0 ? `+${Math.round(result.sentiment)}` : Math.round(result.sentiment);
                        tooltipSentiment.textContent = `Score: ${sentimentDisplay}`;
                        tooltipSentiment.style.display = 'block';
                    } else {
                        tooltipSentiment.style.display = 'none';
                    }
                }

                // Position tooltip using mouse X position (relative to chartCanvas)
                const tooltipX = clampedMouseX + 15;
                const tooltipY = e.clientY - chartCanvasRect.top - 60;

                mainTooltip.style.left = tooltipX + 'px';
                mainTooltip.style.top = tooltipY + 'px';

                // Adjust tooltip position if it goes off screen (respect chart bounds)
                // Tooltip is inside chart-canvas, so bounds are the canvas width
                if (tooltipX + mainTooltip.offsetWidth > effectiveChartWidth) {
                    mainTooltip.style.left = (clampedMouseX - mainTooltip.offsetWidth - 15) + 'px';
                }
                if (tooltipY < 0) {
                    mainTooltip.style.top = '10px';
                }
            } else {
                // Show oscillator tooltip
                oscillatorTooltip.style.display = 'block';
                mainTooltip.style.display = 'none';

                // Check if signal mode is active
                const signalModeActive = document.getElementById('signal-mode-toggle')?.classList.contains('active') || false;

                // Display sentiment as main value (use signal value if in signal mode)
                let displayValue = null;
                if (signalModeActive && result.signalValue != null) {
                    displayValue = result.signalValue; // Use binary signal value
                } else if (result.sentiment != null) {
                    displayValue = result.sentiment; // Use regular sentiment
                }

                if (displayValue != null) {
                    const sentimentDisplay = displayValue > 0 ? `+${Math.round(displayValue)}` : Math.round(displayValue);
                    oscillatorTooltipValue.textContent = sentimentDisplay;
                } else {
                    oscillatorTooltipValue.textContent = 'N/A';
                }

                oscillatorTooltipTime.textContent = result.time;

                // Position tooltip using mouse X position (relative to chartCanvas)
                // For oscillator, we need to calculate mouseX relative to oscillator
                const oscillatorMouseX = e.clientX - oscillatorRect.left;
                const tooltipX = oscillatorMouseX + 15;
                const tooltipY = e.clientY - oscillatorRect.top - 75;

                oscillatorTooltip.style.left = tooltipX + 'px';
                oscillatorTooltip.style.top = tooltipY + 'px';

                // Adjust tooltip position if it goes off screen (respect oscillator bounds)
                // Oscillator tooltip is inside oscillator div, so bounds are the oscillator width
                if (tooltipX + oscillatorTooltip.offsetWidth > oscillatorRect.width) {
                    oscillatorTooltip.style.left = (oscillatorMouseX - oscillatorTooltip.offsetWidth - 15) + 'px';
                }
                if (tooltipY < 0) {
                    oscillatorTooltip.style.top = '10px';
                }
            }
        }

        function hideAllHoverElements() {
            unifiedHoverLine.style.display = 'none';
            timeLabel.classList.remove('show');
            mainTooltip.style.display = 'none';
            oscillatorTooltip.style.display = 'none';
        }

        // Main chart hover events
        chartCanvas.addEventListener('mousemove', (e) => handleChartHover(e, true));
        chartCanvas.addEventListener('mouseleave', hideAllHoverElements);

        // Oscillator hover events
        oscillatorDiv.addEventListener('mousemove', (e) => handleChartHover(e, false));
        oscillatorDiv.addEventListener('mouseleave', hideAllHoverElements);

        // Hover tooltip functionality
        const hoverTooltip = document.getElementById('hover-tooltip');
        const tooltipText = document.getElementById('tooltip-text');
        const tooltipElements = document.querySelectorAll('.has-tooltip');

        tooltipElements.forEach(element => {
            element.addEventListener('mouseenter', (e) => {
                const text = element.getAttribute('data-tooltip');
                
                tooltipText.textContent = text;
                hoverTooltip.classList.add('show');
                
                // Position tooltip near cursor
                updateTooltipPosition(e);
            });

            element.addEventListener('mousemove', (e) => {
                updateTooltipPosition(e);
            });

            element.addEventListener('mouseleave', () => {
                hoverTooltip.classList.remove('show');
            });
        });

        function updateTooltipPosition(e) {
            const offsetX = 15;
            const offsetY = 15;
            let x = e.clientX + offsetX;
            let y = e.clientY + offsetY;

            // Keep tooltip on screen
            const tooltipRect = hoverTooltip.getBoundingClientRect();
            if (x + tooltipRect.width > window.innerWidth) {
                x = e.clientX - tooltipRect.width - offsetX;
            }
            if (y + tooltipRect.height > window.innerHeight) {
                y = e.clientY - tooltipRect.height - offsetY;
            }

            hoverTooltip.style.left = x + 'px';
            hoverTooltip.style.top = y + 'px';
        }

        // ===== ONBOARDING MODAL FUNCTIONALITY =====
        
        /**
         * Check if user needs onboarding and show modal if needed
         * Uses localStorage to track completion per user
         */
        async function checkAndShowOnboarding() {
            try {
                const user = window.Clerk.user;
                if (!user) return;

                const userId = user.id;
                const onboardingKey = `onboarding_completed_${userId}`;
                
                // Check if user has already completed onboarding
                const hasCompletedOnboarding = localStorage.getItem(onboardingKey) === 'true';
                
                if (!hasCompletedOnboarding) {
                    // Show onboarding modal
                    showOnboardingModal();
                }
            } catch (error) {
                console.error('Error checking onboarding status:', error);
            }
        }

        /**
         * Show the onboarding modal
         */
        function showOnboardingModal() {
            const overlay = document.getElementById('onboarding-modal-overlay');
            if (overlay) {
                overlay.classList.add('show');
                // Prevent body scroll
                document.body.style.overflow = 'hidden';
            }
        }

        /**
         * Hide the onboarding modal
         */
        function hideOnboardingModal() {
            const overlay = document.getElementById('onboarding-modal-overlay');
            if (overlay) {
                overlay.classList.remove('show');
                // Restore body scroll
                document.body.style.overflow = '';
            }
        }

        /**
         * Mark onboarding as completed
         */
        async function completeOnboarding(selectedLanguage) {
            try {
                const user = window.Clerk.user;
                if (!user) return;

                const userId = user.id;
                const onboardingKey = `onboarding_completed_${userId}`;
                
                // Save selected language (optional, for future use)
                if (selectedLanguage) {
                    localStorage.setItem(`user_language_${userId}`, selectedLanguage);
                }
                
                // Mark onboarding as completed
                localStorage.setItem(onboardingKey, 'true');
                
                // Hide modal
                hideOnboardingModal();
            } catch (error) {
                console.error('Error completing onboarding:', error);
                // Hide modal anyway
                hideOnboardingModal();
            }
        }

        // Initialize onboarding modal functionality
        document.addEventListener('DOMContentLoaded', () => {
            const languageOptions = document.querySelectorAll('.language-option');
            const languageContinueBtn = document.getElementById('language-continue-btn');
            const disclaimerContinueBtn = document.getElementById('disclaimer-continue-btn');
            const stepLanguage = document.getElementById('step-language');
            const stepDisclaimer = document.getElementById('step-disclaimer');
            const progressDot1 = document.getElementById('progress-dot-1');
            const progressDot2 = document.getElementById('progress-dot-2');

            let selectedLanguage = null;

            // Language selection
            languageOptions.forEach(option => {
                option.addEventListener('click', () => {
                    // Remove previous selection
                    languageOptions.forEach(opt => opt.classList.remove('selected'));

                    // Select new option
                    option.classList.add('selected');
                    selectedLanguage = option.dataset.lang;

                    // Apply language immediately
                    setLanguage(selectedLanguage);

                    // Enable continue button
                    languageContinueBtn.disabled = false;
                });
            });

            // Continue from language step
            languageContinueBtn.addEventListener('click', () => {
                if (!selectedLanguage) return;

                // Switch to disclaimer step
                stepLanguage.classList.remove('active');
                stepDisclaimer.classList.add('active');

                // Update progress dots
                progressDot1.classList.remove('active');
                progressDot2.classList.add('active');
            });

            // Disclaimer checkbox handling
            const disclaimerCheckbox = document.getElementById('disclaimer-checkbox');
            if (disclaimerCheckbox) {
                disclaimerCheckbox.addEventListener('change', () => {
                    // Enable/disable continue button based on checkbox state
                    disclaimerContinueBtn.disabled = !disclaimerCheckbox.checked;
                });
            }

            // Continue from disclaimer step (complete onboarding)
            disclaimerContinueBtn.addEventListener('click', () => {
                completeOnboarding(selectedLanguage);
            });
        });

        // Language selector functionality for main navigation
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Setting up language selector...');
            const languageSelector = document.getElementById('language-selector');
            console.log('Language selector element:', languageSelector);
            if (languageSelector) {
                languageSelector.addEventListener('click', (e) => {
                    e.preventDefault();
                    console.log('Language selector clicked!');
                    showLanguageModal();
                });
                console.log('Language selector event listener added');
            } else {
                console.error('Language selector element not found!');
            }
        });

        // Show language selection modal
        function showLanguageModal() {
            const languages = [
                { code: 'en', name: 'English', nativeName: 'English' },
                { code: 'es', name: 'Spanish', nativeName: 'Español' },
                { code: 'fr', name: 'French', nativeName: 'Français' },
                { code: 'de', name: 'German', nativeName: 'Deutsch' },
                { code: 'zh', name: 'Chinese', nativeName: '中文' },
                { code: 'ja', name: 'Japanese', nativeName: '日本語' }
            ];

            const currentLang = getCurrentLanguage();

            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(4px);
                z-index: 10000; display: flex; align-items: center; justify-content: center;
            `;

            const content = document.createElement('div');
            content.style.cssText = `
                background: #1a1a1a; border: 1px solid #2a2a2a; border-radius: 16px;
                max-width: 500px; width: 90%; padding: 40px 48px; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            `;

            const title = document.createElement('h2');
            title.textContent = 'Select Language';
            title.style.cssText = `
                font-size: 28px; font-weight: 700; color: #fff;
                margin-bottom: 24px; text-align: center;
            `;

            const langGrid = document.createElement('div');
            langGrid.style.cssText = `
                display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 24px;
            `;

            languages.forEach(lang => {
                const langBtn = document.createElement('div');
                langBtn.style.cssText = `
                    background: #0f0f0f; border: 2px solid ${lang.code === currentLang ? '#10b981' : '#2a2a2a'};
                    border-radius: 12px; padding: 16px; cursor: pointer; transition: all 0.2s ease;
                    display: flex; flex-direction: column; gap: 4px; text-align: center;
                `;

                langBtn.innerHTML = `
                    <div style="font-size: 16px; font-weight: 600; color: ${lang.code === currentLang ? '#10b981' : '#fff'};">${lang.nativeName}</div>
                    <div style="font-size: 12px; color: #888; text-transform: uppercase; letter-spacing: 1px;">${lang.code}</div>
                `;

                langBtn.addEventListener('mouseenter', () => {
                    if (lang.code !== currentLang) {
                        langBtn.style.background = '#1a1a1a';
                        langBtn.style.borderColor = '#333';
                    }
                });

                langBtn.addEventListener('mouseleave', () => {
                    if (lang.code !== currentLang) {
                        langBtn.style.background = '#0f0f0f';
                        langBtn.style.borderColor = '#2a2a2a';
                    }
                });

                langBtn.addEventListener('click', () => {
                    setLanguage(lang.code);
                    document.body.removeChild(modal);
                });

                langGrid.appendChild(langBtn);
            });

            const closeBtn = document.createElement('button');
            closeBtn.textContent = 'Close';
            closeBtn.style.cssText = `
                width: 100%; padding: 14px 32px; background: #ffffff; color: #000000;
                border: none; border-radius: 12px; font-size: 16px; font-weight: 600;
                cursor: pointer; transition: all 0.2s ease; font-family: inherit;
            `;

            closeBtn.addEventListener('mouseenter', () => {
                closeBtn.style.background = '#e0e0e0';
            });

            closeBtn.addEventListener('mouseleave', () => {
                closeBtn.style.background = '#ffffff';
            });

            closeBtn.addEventListener('click', () => {
                document.body.removeChild(modal);
            });

            content.appendChild(title);
            content.appendChild(langGrid);
            content.appendChild(closeBtn);
            modal.appendChild(content);

            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });

            document.body.appendChild(modal);
        }
    </script>
</body>
</html>

